'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Open API documentation for node.js and Express.js
 * @module openapi-doc
 * @typicalname openapi-doc
 *
 * @example <caption>Quick start</caption>
 * ```javascript
 *     const Swagger = require('openapi-doc');
 *     const swagger = new Swagger();
 *     swagger.info('My API', '1.0', 'This is *API*');
 *
 *     // describe API endpoint and action
 *     swagger.get('/logs')
 *         .operationId('getLogs')
 *         .tag('logging')
 *         .summary('Gets an array of logs.')
 *         .response(200)
 *         .action((req, res) => {
 *             res.sendStatus(200);
 *         });
 * ```
 *
 * @example <caption>Bind API to Express endpoint</caption>
 * ```javascript
 *     const prefix = '/api';
 *     Swagger.forEachAction(swagger, (verb, path) => {
 *         const endpoint = Swagger.endpointToExpress(prefix + path);
 *         // express app
 *         app[verb](
 *             endpoint,
 *             Swagger.actionMiddleware(swagger, verb, path)
 *         );
 *     });
 * ```
 *
 * @example <caption>Apply security</caption>
 * ```javascript
 *     const prefix = '/api';
 *     swagger.securityDefinition(
 *         'basicAuth', {
 *             type: 'basic',
 *             description: 'Username and password',
 *         },
 *         (req) => {
 *             return true;
 *         }
 *     );
 *     Swagger.forEachAction(swagger, (verb, path) => {
 *         const endpoint = Swagger.endpointToExpress(prefix + path);
 *         // express app
 *         app[verb](
 *             endpoint,
 *             Swagger.securityMiddleware(swagger, verb, path),
 *             Swagger.actionMiddleware(swagger, verb, path)
 *         );
 *     });
 * ```
 *
 * @example <caption>Bind generated Swagger API document to Express endpoint</caption>
 * ```javascript
 *     app.get('/api-doc', function (req, resp) {
 *         resp.send(swagger.apidoc());
 *     });
 * ```
 */
var urljoin = require('url-join');

var PATH_PATTERN = /(?:\{.*?\})/g;
var EXTENSION_PATTERN = /^x-/;

var HTTP_STATUS_CODES = {
	100: 'Continue',
	101: 'Switching Protocols',
	102: 'Processing',
	200: 'OK',
	201: 'Created',
	202: 'Accepted',
	203: 'Non-Authoritative Information',
	204: 'No Content',
	205: 'Reset Content',
	206: 'Partial Content',
	207: 'Multi-Status',
	300: 'Multiple Choices',
	301: 'Moved Permanently',
	302: 'Moved Temporarily',
	303: 'See Other',
	304: 'Not Modified',
	305: 'Use Proxy',
	307: 'Temporary Redirect',
	400: 'Bad Request',
	401: 'Unauthorized',
	402: 'Payment Required',
	403: 'Forbidden',
	404: 'Not Found',
	405: 'Method Not Allowed',
	406: 'Not Acceptable',
	407: 'Proxy Authentication Required',
	408: 'Request Time-out',
	409: 'Conflict',
	410: 'Gone',
	411: 'Length Required',
	412: 'Precondition Failed',
	413: 'Request Entity Too Large',
	414: 'Request-URI Too Large',
	415: 'Unsupported Media Type',
	416: 'Requested Range Not Satisfiable',
	417: 'Expectation Failed',
	418: 'I\'m a teapot',
	422: 'Unprocessable Entity',
	423: 'Locked',
	424: 'Failed Dependency',
	425: 'Unordered Collection',
	426: 'Upgrade Required',
	428: 'Precondition Required',
	429: 'Too Many Requests',
	431: 'Request Header Fields Too Large',
	500: 'Internal Server Error',
	501: 'Not Implemented',
	502: 'Bad Gateway',
	503: 'Service Unavailable',
	504: 'Gateway Time-out',
	505: 'HTTP Version Not Supported',
	506: 'Variant Also Negotiates',
	507: 'Insufficient Storage',
	509: 'Bandwidth Limit Exceeded',
	510: 'Not Extended',
	511: 'Network Authentication Required'
};

// some common licenses
var SPDX_LICENSES = {
	'apache-1.0': 'https://spdx.org/licenses/Apache-1.0.html',
	'apache-1.1': 'https://spdx.org/licenses/Apache-1.1.html',
	'apache-2.0': 'https://spdx.org/licenses/Apache-2.0.html',
	mit: 'https://spdx.org/licenses/MIT.html',
	'gpl-1.0': 'https://spdx.org/licenses/GPL-1.0.html',
	'gpl-2.0': 'https://spdx.org/licenses/GPL-2.0.html',
	'gpl-3.0': 'https://spdx.org/licenses/GPL-3.0.html',
	'lgpl-2.1': 'https://spdx.org/licenses/LGPL-2.1.html',
	'lgpl-2.0': 'https://spdx.org/licenses/LGPL-2.0.html',
	'lgpl-3.0': 'https://spdx.org/licenses/LGPL-3.0.html',
	'mpl-1.0': 'https://spdx.org/licenses/MPL-1.0.html',
	'mpl-1.1': 'https://spdx.org/licenses/MPL-1.1.html',
	'mpl-2.0': 'https://spdx.org/licenses/MPL-2.0.html'
};

/**
 * @class
 */

var Swagger = function () {
	/**
  * Construct a Swagger builder.
  */
	function Swagger() {
		_classCallCheck(this, Swagger);

		this.currentPath = null;
		this.doc = {
			swagger: '2.0',
			info: {
				title: '',
				description: undefined,
				termsOfService: undefined,
				contact: undefined,
				license: undefined,
				version: '1.0.0'
			},
			host: undefined,
			basePath: undefined,
			schemes: undefined,
			consumes: undefined,
			produces: undefined,
			paths: {},
			definitions: undefined,
			parameters: undefined,
			responses: undefined,
			securityDefinitions: undefined,
			security: undefined,
			tags: undefined,
			externalDocs: undefined
		};
		this._actions = {};
		this._securityHandlers = {};
	}

	/**
  * Adds information for the API.
  * @public
  * @param {string} title - the title of the API
  * @param {string} version - the version of the API
  * @param {string} description - the description of the API
  * @example
  * swagger.info('My API', '1.0', 'This is *API*');
  * @return {Swagger} The current object (this).
  */


	_createClass(Swagger, [{
		key: 'info',
		value: function info(title, version, description) {
			if (typeof title !== 'string') {
				if (!title) {
					throw new Error('missing required argument: title');
				}
				throw new Error('illegal argument: title');
			}
			if (typeof version !== 'string') {
				if (!version) {
					throw new Error('missing required argument: version');
				}
				throw new Error('illegal argument: version');
			}
			if (typeof description === 'string') {
				this.doc.info.description = description;
			} else if (description) {
				throw new Error('illegal argument: description');
			}
			this.doc.info.title = title;
			this.doc.info.version = version;
			return this;
		}

		/**
   * Sets the host for the API
   * @public
   * @param {string} name - the hostname of the API, e.g. 'localhost'
   * @return {Swagger} The current object (this).
   */

	}, {
		key: 'host',
		value: function host(name) {
			if (!name) {
				throw new Error('missing required argument: name');
			}
			this.doc.host = name;
			return this;
		}

		/**
   * Sets the license for the API
   * @public
   * @param {string} name - the license name
   * @return {Swagger} The current object (this).
   */

	}, {
		key: 'license',
		value: function license(name) {
			if (!name) {
				throw new Error('missing required argument: name');
			}
			this.doc.info.license = { name: name };
			var lcname = name.toLowerCase();
			if (SPDX_LICENSES.hasOwnProperty(lcname)) {
				this.doc.info.license.url = SPDX_LICENSES[lcname];
			}
			return this;
		}

		/**
   * Sets the contact name and email
   * @public
   * @param {string} name - the contact name
   * @param {string} [email] - the contact email
   * @return {Swagger} The current object (this).
   */

	}, {
		key: 'contact',
		value: function contact(name, email) {
			if (!name) {
				throw new Error('missing required argument: name');
			}
			this.doc.info.contact = { name: name };
			if (email) {
				this.doc.info.contact.email = email;
			}
			return this;
		}

		/**
   * Sets the terms of service for the API
   * @public
   * @param {string} terms - the terms of service
   * @return {Swagger} The current object (this).
   */

	}, {
		key: 'termsOfService',
		value: function termsOfService(terms) {
			if (!terms) {
				throw new Error('missing required argument: terms');
			}
			this.doc.info.termsOfService = terms;
			return this;
		}

		/**
   * Sets the API base path
   * @public
   * @param {string} path - the API base path
   * @return {Swagger} The current object (this).
   */

	}, {
		key: 'basePath',
		value: function basePath(path) {
			if (!path) {
				throw new Error('missing required argument: path');
			}
			this.doc.basePath = path;
			return this;
		}

		/**
   * Sets the schemes for the API
   * @public
   * @param {array} schemes - An array of http schemes
   * @return {Swagger} The current object (this).
   */

	}, {
		key: 'schemes',
		value: function schemes(_schemes) {
			if (!_schemes) {
				throw new Error('missing required argument: schemes');
			}
			if (!(_schemes instanceof Array)) {
				throw new Error('illegal argument: schemes is not an array');
			}
			_schemes.forEach(function (scheme) {
				if (['http', 'https', 'ws', 'wss'].indexOf(scheme) === -1) {
					throw new Error('illegal argument: schemes contains invalid value ' + scheme);
				}
			});
			this.doc.schemes = _schemes;
			return this;
		}

		/**
   * Callback function for custom authentication.
   * @public
   * @callback customAuthentication
   * @param {object} req - The express request object.
   * @return {boolean} Return `true` if valid, or `false` if invalid.
   */

		/**
   * Adds a Security Definition.
   * @public
   * @param {string} name - the name of the security definition
   * @param {object} options - The options for this security definition. See: http://swagger.io/specification/#securityDefinitionsObject
   * @param {customAuthentication} handler - The middleware handler function.
   * security definition.
   * @example
   * ```javascript
   * swagger.securityDefinition(
   *     'basicAuth',
   *     {
   *          type: 'basic',
   *          description: 'Requires username:password'
   *     },
   *     (req) => {
   *          return true;
   *     }
   * });
   * // Assign security definition globally.
   * swagger.security('basicAuth');
   * ```
   * @return {Swagger} The current object (this).
   */

	}, {
		key: 'securityDefinition',
		value: function securityDefinition(name, options, handler) {
			if (!name) {
				throw new Error('missing required argument: name');
			}
			if (typeof name !== 'string') {
				throw new Error('illegal argument: name');
			}

			if (!options.type) {
				throw new Error('missing required argument: options.type');
			}
			if (typeof options.type !== 'string') {
				throw new Error('illegal argument: options.type');
			}

			// Check the additional keys
			var keys = Object.keys(options).filter(function (k) {
				return k !== 'type' && k !== 'description';
			});
			if (options.type === 'basic') {
				if (keys.length) {
					throw new Error('illegal options for basic security: ' + keys.join(', '));
				}
			} else if (options.type === 'apiKey') {
				if (keys.indexOf('in') === -1) {
					throw new Error('missing required argument: options.in');
				}

				if (keys.indexOf('name') === -1) {
					throw new Error('missing required argument: options.name');
				}

				keys = keys.filter(function (k) {
					return k !== 'in' && k !== 'name';
				});
				if (keys.length) {
					throw new Error('illegal options for apiKey security: ' + keys.join(', '));
				}
			} else if (options.type === 'oauth2') {
				if (keys.indexOf('flow') === -1) {
					throw new Error('missing required argument: options.flow');
				}
				if (options.flow === 'implicit') {
					if (keys.indexOf('authorizationUrl') === -1) {
						throw new Error('missing required auth2 implicit flow argument: options.authorizationUrl');
					}
				} else if (options.flow === 'password' || options.flow === 'application') {
					if (keys.indexOf('tokenUrl') === -1) {
						throw new Error('missing required auth2 ' + options.flow + ' flow argument: options.tokenUrl');
					}
				} else if (options.flow === 'accessCode') {
					if (keys.indexOf('tokenUrl') === -1) {
						throw new Error('missing required auth2 accessCode flow argument: options.tokenUrl');
					}
					if (keys.indexOf('authorizationUrl') === -1) {
						throw new Error('missing required auth2 accessCode flow argument: options.authorizationUrl');
					}
				} else {
					throw new Error('invalid oauth2 options.flow argument: ' + options.flow);
				}
			} else {
				throw new Error('invalid security type: ' + options.type);
			}

			this.doc.securityDefinitions = this.doc.securityDefinitions || {};

			if (this.doc.securityDefinitions[name]) {
				throw new Error('duplicate security definition: ' + name);
			}

			this._securityHandlers[name] = handler;
			this.doc.securityDefinitions[name] = options;
			return this;
		}

		/**
   * Adds a Security Requirement to the current method (if creating a new method), or globally
   * for the API.  If `definitions` is empty, then then no security is applied.  The
   * `definitions` can be a `string`, an array of `string`, or an array of `object`.  If
   * `definitions` is an array of `object`, then it must be an array of security
   * Requirement Objects, e.g. `[{apikey: []}]`.
   * @public
   * @param {array} definitions - An array of the Security Definition to apply.
   * @return {Swagger} The current object (this).
   */

	}, {
		key: 'security',
		value: function security() {
			var _this = this;

			var definitions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

			var sec = void 0;
			var array = Array.isArray(definitions);

			if (!array && typeof definitions[0] === 'string') {
				definitions = [definitions];
			} else if (array && definitions.length > 0 && _typeof(definitions[0]) === 'object') {
				// e.g. passing in: [{apikey: []}]
				sec = definitions;
			} else if (!(array && definitions.length > 0 && typeof definitions[0] === 'string') && !(array && definitions.length === 0)) {
				throw new Error('illegal argument: definitions');
			}

			if (!sec) {
				sec = definitions.map(function (def) {
					if (!_this.doc.securityDefinitions || !_this.doc.securityDefinitions[def]) {
						throw new Error('no such security definition: ' + def);
					}
					return _defineProperty({}, def, []);
				});
			}

			if (this.currentPath) {
				// Per operation override
				if (this.currentPath.security) {
					throw new Error('security requirement already defined for this api');
				}
				this.currentPath.security = sec;
			} else {
				// Global security
				if (this.doc.security) {
					throw new Error('global security requirement already defined.');
				}
				this.doc.security = sec;
			}

			return this;
		}

		/**
   * Adds a global parameter to the document which can be referred to using $ref later.
   * @public
   * @param {object} param - A valid Swagger parameter specification.
   * @example
   * swagger.globalParameter({
   *	 in: 'path',
   *	 name: 'foo',
   *	 type: 'string',
   *	 description: 'My foo param'});
   * swagger.post('/foo')
   *	.operationId('CreateFoo')
   *	.parameter({ $ref: '#/parameters/foo' })
   *	.response(200, 'Success');
   * @return {Swagger} The current object (this).
   */

	}, {
		key: 'globalParameter',
		value: function globalParameter(param) {
			if (!param) {
				throw new Error('missing required argument: param');
			}
			if ((typeof param === 'undefined' ? 'undefined' : _typeof(param)) !== 'object') {
				throw new Error('invalid argument: param');
			}
			if (param.$ref !== undefined) {
				throw new Error('invalid argument: global param refs are not supported');
			}
			this._ensureValidParameter(param);

			if (!this.doc.parameters) {
				this.doc.parameters = {};
			} else if (this.doc.parameters[param.name]) {
				throw new Error('global parameter already exists: ' + param.name);
			}
			this.doc.parameters[param.name] = param;
			return this;
		}

		/**
   * Adds a global tag to the document.
   * @public
   * @param {object} tag - A valid Swagger tag.
   * @example
   * swagger.globalTag({
   *	 name: 'foo',
   *	 description: 'My foo tag'});
   * @return {Swagger} The current object (this).
   */

	}, {
		key: 'globalTag',
		value: function globalTag(tag) {
			if (!tag) {
				throw new Error('missing required argument: tag');
			}
			if ((typeof tag === 'undefined' ? 'undefined' : _typeof(tag)) !== 'object') {
				throw new Error('invalid argument: tag');
			}
			if (!tag.name) {
				throw new Error('invalid argument: tag.name');
			}
			if (!this.doc.tags) {
				this.doc.tags = [];
			}
			var exists = this.doc.tags.findIndex(function (a) {
				return a.name === tag.name;
			});
			if (exists >= 0) {
				// replace existing tag
				this.doc.tags[exists] = tag;
			} else {
				this.doc.tags.push(tag);
			}
			return this;
		}

		/**
   * Adds a global response to the document which can be referred to using $ref later.
   * @public
   * @param {string} name - The unique name of the response.
   * @param {string} description - The description of the response.
   * @param {string} [type] - Optional type (to be used in `$ref`).
   * @param {boolean} [isArray] - Optional indicator that the repsonse is an array of `type`.
   * @param {array} [headers] - Optional headers to include in the response.
   * @return {Swagger} The current object (this).
   */

	}, {
		key: 'globalResponse',
		value: function globalResponse(name, description, type, isArray, headers) {
			if (!name) {
				throw new Error('missing required argument: name');
			}
			if (!description) {
				throw new Error('missing required argument: description');
			}
			if (!this.doc.responses) {
				this.doc.responses = {};
			}
			this.doc.responses[name] = {
				description: description
			};
			if (type) {
				if (typeof type === 'string') {
					if (isArray === true) {
						this.doc.responses[name].schema = {
							type: 'array',
							items: {
								$ref: '#/definitions/' + type
							}
						};
					} else {
						this.doc.responses[name].schema = {
							$ref: '#/definitions/' + type
						};
					}
				} else {
					// Raw schema
					this.doc.responses[name].schema = type;
				}
			}
			if (headers) {
				this.doc.responses[name].headers = headers;
			}
			return this;
		}

		/**
   * Sets the global externalDocs of the swagger doc
   * @param  {string} doc - A valid ExternalDocumentationObject.
   * @return {Swagger} The current object (this).
   */

	}, {
		key: 'globalExternalDocs',
		value: function globalExternalDocs(doc) {
			if (!doc) {
				throw new Error('missing required argument: doc');
			}
			if ((typeof doc === 'undefined' ? 'undefined' : _typeof(doc)) !== 'object') {
				throw new Error('invalid argument: doc');
			}
			if (!doc.url || typeof doc.url !== 'string') {
				throw new Error('invalid argument: doc.url');
			}
			this.doc.externalDocs = doc;
			return this;
		}

		/**
   * Sets no security on the current method.
   * @return {Swagger} The current object (this).
   * @example
   * swagger.get('/foos/:id')
   *     .nosecurity();
   */

	}, {
		key: 'nosecurity',
		value: function nosecurity() {
			this.security([]);
			return this;
		}

		/**
   * Returns all of the security handlers associated with the API endpoints.
   * @public
   * @example
   * Object.keys(swagger.securityHandlers, (key) => {
   *     swagger.securityHandlers[key];
   * });
   * @return {object} Map of callback functions.
   */

	}, {
		key: 'schema',


		/**
   * Adds a schema definition to the API.
   * @public
   * @param {string} name - The type name.
   * @param {object} spec - A valid JSON schema draft 04 spec.
   * @example
   * ```javascript
   * const spec = { type: 'object', properties: { name: { type: 'string' } } };
   * swagger.schema('Item', spec)
   *     .get('/items')
   *     .response(200, 'Success', 'Item', true);
   * swagger.schema('Item', spec)
   *     .get('/items/:id')
   *     .response(200, 'Success', 'Item');
   * ```
   * @return {Swagger} The current object (this).
   */
		value: function schema(name, spec) {
			if (!name) {
				throw new Error('missing required argument: name');
			}
			if (typeof name !== 'string') {
				throw new Error('illegal argument: name');
			}
			if (!spec) {
				throw new Error('missing required argument: spec');
			}
			if ((typeof spec === 'undefined' ? 'undefined' : _typeof(spec)) !== 'object') {
				throw new Error('illegal argument: spec');
			}
			this.doc.definitions = this.doc.definitions || {};
			this.doc.definitions[name] = spec;
			return this;
		}

		/**
   * Adds multiple schema to the API.
   * @param {array} schemas - schemas to add
   * @return {Swagger} The current object (this).
   */

	}, {
		key: 'schemas',
		value: function schemas(_schemas) {
			var _this2 = this;

			if (_schemas === undefined) {
				throw new Error('missing required argument: schemas');
			}
			Object.keys(_schemas).forEach(function (schemaName) {
				_this2.schema(schemaName, _schemas[schemaName]);
			});
			return this;
		}

		/**
   * Creates a post method for the specified path.  Use Express style routing.
   * @public
   * @param {string} path - The path for the method.
   * @example
   * swagger.post('/foos');
   * @return {Swagger} The current object (this).
   */

	}, {
		key: 'post',
		value: function post(path) {
			return this._verb('post', path);
		}

		/**
   * Creates a get method for the specified path.  Use Express style routing.
   * @public
   * @param {string} path - The path for the method.
   * @example
   * swagger.get('/foos/:id');
   * @return {Swagger} The current object (this).
   */

	}, {
		key: 'get',
		value: function get(path) {
			return this._verb('get', path);
		}

		/**
   * Creates a put method for the specified path.  Use Express style routing.
   * @public
   * @param {string} path - The path for the method.
   * @example
   * swagger.put('/foos/:id');
   * @return {Swagger} The current object (this).
   */

	}, {
		key: 'put',
		value: function put(path) {
			return this._verb('put', path);
		}

		/**
   * Creates a delete method for the specified path.  Use Express style routing.
   * @public
   * @param {string} path - The path for the method.
   * @example
   * swagger.delete('/foos/:id');
   * @return {Swagger} The current object (this).
   */

	}, {
		key: 'delete',
		value: function _delete(path) {
			return this._verb('delete', path);
		}

		/**
   * Creates a patch method for the specified path.  Use Express style routing.
   * @public
   * @param {string} path - The path for the method.
   * @example
   * swagger.patch('/foos/:id');
   * @return {Swagger} The current object (this).
   */

	}, {
		key: 'patch',
		value: function patch(path) {
			return this._verb('patch', path);
		}

		/**
   * Creates a head method for the specified path.  Use Express style routing.
   * @public
   * @param {string} path - The path for the method.
   * @example
   * swagger.head('/foos/:id');
   * @return {Swagger} The current object (this).
   */

	}, {
		key: 'head',
		value: function head(path) {
			return this._verb('head', path);
		}

		/**
   * Creates a options method for the specified path.  Use Express style routing.
   * @public
   * @param {string} path - The path for the method.
   * @example
   * swagger.options('/foos/:id');
   * @return {Swagger} The current object (this).
   */

	}, {
		key: 'options',
		value: function options(path) {
			return this._verb('options', path);
		}

		/**
   * Sets the summary for the current method.
   * @public
   * @param {string} summary - The summary for the method.
   * @example
   * swagger.delete('/foos/:id').summary('Deletes foo.');
   * @return {Swagger} The current object (this).
   */

	}, {
		key: 'summary',
		value: function summary(_summary) {
			if (!this.currentPath) {
				throw new Error('need to start a method using one of: get, post, put, patch, head, options or delete.');
			}
			this.currentPath.summary = _summary;
			return this;
		}

		/**
   * Sets the description for the current method.
   * @public
   * @param {string} description - The description for the method.
   * @example
   * swagger.delete('/foos/:id').description('Deletes foo');
   * @return {Swagger} The current object (this).
   */

	}, {
		key: 'description',
		value: function description(_description) {
			if (!this.currentPath) {
				throw new Error('need to start a method using one of: get, post, put, patch, head, options or delete.');
			}
			this.currentPath.description = _description;
			return this;
		}

		/**
   * Sets the operationId for the current method.
   * @public
   * @param {string} name - The name for the method.
   * @example
   * swagger.delete('/foos/:id').operationId('DeleteFoo');
   * @return {Swagger} The current object (this).
   */

	}, {
		key: 'operationId',
		value: function operationId(name) {
			if (!this.currentPath) {
				throw new Error('need to start a method using one of: get, post, put, patch, head, options or delete.');
			}
			this.currentPath.operationId = name;
			return this;
		}

		/**
   * Adds a tag to the current method.
   * @public
   * @param {string} tag - The tag to add.
   * @example
   * swagger.delete('/foos/:id').tag('foo');
   * @return {Swagger} The current object (this).
   */

	}, {
		key: 'tag',
		value: function tag(_tag) {
			if (!this.currentPath) {
				throw new Error('need to start a method using one of: get, post, put, patch, head, options or delete.');
			}
			if (!this.currentPath.tags) {
				this.currentPath.tags = [];
			}
			this.currentPath.tags.push(_tag);
			return this;
		}

		/**
   * Adds multiple tags to the current method.
   * @public
   * @param {string[]} tags - The tags for the method.
   * @example
   * swagger.delete('/foos/:id').tags(['foo', 'bar']);
   * @return {Swagger} The current object (this).
   */

	}, {
		key: 'tags',
		value: function tags(_tags) {
			var _this3 = this;

			_tags.forEach(function (tag) {
				_this3.tag(tag);
			});
			return this;
		}

		/**
   * Convenience method to add a body parameter to the current method.
   * @public
   * @param {string} type - The type of object (not full ref), e.g. "Type"
   * @param {string} description - The description of the body parameter.
   * @example
   * swagger.post('/foo').body('Foo', 'Foo to create');
   * @return {Swagger} The current object (this).
   */

	}, {
		key: 'body',
		value: function body(type, description) {
			return this.parameter({
				in: 'body',
				name: 'body',
				description: description,
				required: true,
				schema: {
					$ref: '#/definitions/' + type
				}
			});
		}

		/**
   * Adds a parameter to the current method.
   * @public
   * @param {object} param - A valid Swagger parameter specification.
   * @example
   * swagger.post('/foo').parameter({
   *	 in: 'path',
   *	 name: 'foo',
   *	 type: 'string',
   *	 description: 'My foo param'});
   * @return {Swagger} The current object (this).
   */

	}, {
		key: 'parameter',
		value: function parameter(param) {
			if (!this.currentPath) {
				throw new Error('need to start a method using one of: get, post, put, patch, head, options or delete.');
			}
			if (!param) {
				throw new Error('missing required argument: param');
			}
			if ((typeof param === 'undefined' ? 'undefined' : _typeof(param)) !== 'object') {
				throw new Error('invalid argument: param');
			}

			// swagger allows references to parameters
			if (param.$ref === undefined) {
				this._ensureValidParameter(param);

				if (param.in === 'path') {
					param.required = true; // must be true

					// find path parameter
					var found = -1;
					var varname = '{' + param.name + '}';
					var match = void 0;
					PATH_PATTERN.lastIndex = 0; // < this is horrible
					match = PATH_PATTERN.exec(this._action.path);
					while (match !== null) {
						found = match.indexOf(varname) >= 0;
						if (found) {
							break;
						}
						match = PATH_PATTERN.exec(this._action.path);
					}
					if (found < 0) {
						throw new Error('expected path parameter :' + param.name);
					}
				}
			}
			if (!this.currentPath.parameters) {
				this.currentPath.parameters = [];
			}
			this.currentPath.parameters.push(param);
			return this;
		}

		/**
   * Sets multiple parameters on the current method.
   * @public
   * @param {array} parameters - A valid Swagger parameters array.
   * @return {Swagger} The current object (this).
   */

	}, {
		key: 'parameters',
		value: function parameters(_parameters) {
			var _this4 = this;

			_parameters.forEach(function (param) {
				_this4.parameter(param);
			});
			return this;
		}

		/*
   * Adds a consumes to either the current method or the doc.
   * @public
   * @param {string} mimeType - The mime-type that can be consumed.
   * @param {boolean} forceGlobal - Write to the document level consumes even if in a path.
   * @return {Swagger} The current object (this).
   */

	}, {
		key: 'extension',
		value: function extension(key, value) {
			if (!key || key === '') {
				throw new Error('missing required argument: key');
			}
			if (typeof key !== 'string' || !key.startsWith('x-')) {
				throw new Error('illegal argument: key');
			}
			if (value === undefined) {
				throw new Error('missing required argument: value');
			}

			if (this.currentPath) {
				this.currentPath[key] = value;
			} else {
				this.doc[key] = value;
			}

			return this;
		}

		/**
   * Adds a consumes to either the current method or the doc.
   * @public
   * @param {string|string[]} mimeType - The mime-type that can be consumed.
   * @param {boolean} forceGlobal - Write to the document level consumes even if in a path.
   * @return {Swagger} The current object (this).
   */

	}, {
		key: 'consumes',
		value: function consumes(mimeType, forceGlobal) {
			if (!mimeType || mimeType === '') {
				throw new Error('missing required argument: mimeType');
			}
			if (typeof mimeType !== 'string' && !(mimeType instanceof Array)) {
				throw new Error('illegal argument: mimeType');
			}

			var target = void 0;
			if (this.currentPath && !forceGlobal) {
				this.consumes(mimeType, true);
				target = this.currentPath.consumes = this.currentPath.consumes || [];
			} else {
				target = this.doc.consumes = this.doc.consumes || [];
			}

			if (!(mimeType instanceof Array)) {
				if (target.indexOf(mimeType) < 0) {
					target.push(mimeType);
				}
			} else {
				mimeType.forEach(function (type) {
					if (target.indexOf(type) < 0) {
						target.push(type);
					}
				});
			}

			return this;
		}

		/**
   * Adds a produces to either the current method or the doc.
   * @public
   * @param {string|string[]} mimeType - The mime-type that can be consumed.
   * @param {boolean} forceGlobal - Write to the document level produces even if in a path.
   * @return {Swagger} The current object (this).
   */

	}, {
		key: 'produces',
		value: function produces(mimeType, forceGlobal) {
			if (!mimeType || mimeType === '') {
				throw new Error('missing required argument: mimeType');
			}
			if (typeof mimeType !== 'string' && !(mimeType instanceof Array)) {
				throw new Error('illegal argument: mimeType');
			}

			var target = void 0;
			if (this.currentPath && !forceGlobal) {
				this.produces(mimeType, true);
				target = this.currentPath.produces = this.currentPath.produces || [];
			} else {
				target = this.doc.produces = this.doc.produces || [];
			}

			if (!(mimeType instanceof Array)) {
				if (target.indexOf(mimeType) < 0) {
					target.push(mimeType);
				}
			} else {
				mimeType.forEach(function (type) {
					if (target.indexOf(type) < 0) {
						target.push(type);
					}
				});
			}

			return this;
		}

		/**
   * Adds a response to the current method.
   * @public
   * @param {number} code - The HTTP response code.
   * @param {string} [description] - Optional description.
   *		If not specified, uses the standard HTTP response string.
   * @param {string} [type] - Optional type (to be used in `$ref`).
   * @param {boolean} [isArray] - Optional indicator that the repsonse is an array of `type`.
   * @param {array} [headers] - Optional headers to include in the response.
   * @return {Swagger} The current object (this).
   */

	}, {
		key: 'response',
		value: function response(code, description, type, isArray, headers) {
			if (!this.currentPath) {
				throw new Error('need to start a method using one of: get, post, put, patch, head, options or delete.');
			}
			if (!code) {
				throw new Error('invalid argument: code');
			}
			code += ''; // must be a string

			// check that all path parameters are defined before defining responses.
			this._checkPathParametersAreDefined();

			if (!description && HTTP_STATUS_CODES.hasOwnProperty(code)) {
				description = HTTP_STATUS_CODES[code];
			}
			this.currentPath.responses[code] = {
				description: description
			};
			if (type) {
				if (typeof type === 'string') {
					if (isArray === true) {
						this.currentPath.responses[code].schema = {
							type: 'array',
							items: {
								$ref: '#/definitions/' + type
							}
						};
					} else {
						this.currentPath.responses[code].schema = {
							$ref: '#/definitions/' + type
						};
					}
				} else {
					// Raw schema
					this.currentPath.responses[code].schema = type;
				}
			}

			if (headers) {
				this.currentPath.responses[code].headers = headers;
			}
			return this;
		}

		/**
   * Sets multiple response on the current method.
   * @public
   * @param {object} responses - A valid Swagger responses object.
   * @param {object} [options] - Options for controlling the merge.
   * @param {RegExp} [options.extensions] - Test to allow (or deny) extensions.
   * @return {Swagger} The current object (this).
   */

	}, {
		key: 'responses',
		value: function responses(_responses) {
			var _this5 = this;

			var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
			var extensions = options.extensions;

			var extensionPattern = extensions || EXTENSION_PATTERN;

			Object.keys(_responses).forEach(function (code) {
				var response = _responses[code];
				if (extensionPattern.test(code)) {
					_this5.currentPath.responses[code] = response;
					return;
				}
				if (response.$ref) {
					_this5.currentPath.responses[code] = response;
					return;
				}
				_this5.response(code, response.description || null, response.schema, null, response.headers);
			});
			return this;
		}

		/**
   * Callback for handling Express action.
   *
   * @callback expressHandlerCallback
   * @param {object} request - The Express request object.
   * @param {object} response - The Express response object.
   */

		/**
   * Applies an action to the current method to be used with Express.
   * @public
   * @param {expressHandlerCallback} handler - The Express handler function.
   * @return {Swagger} The current object (this).
   */

	}, {
		key: 'action',
		value: function action(handler) {
			if (!this.currentPath) {
				throw new Error('need to start a method using one of: get, post, put, patch, head, options or delete.');
			}
			if (this._actions.hasOwnProperty(this._action.path)) {
				if (this._actions[this._action.path].hasOwnProperty(this._action.verb)) {
					throw new Error('the action is already defined for: ' + this._action.verb + ' ' + this._action.path);
				}
			} else {
				this._actions[this._action.path] = {};
			}
			this._actions[this._action.path][this._action.verb] = handler;
			return this;
		}

		/**
   * Callback function to selectively filter out specific methods.  Return true
   * to include the path.
   * @public
   * @callback pathFilter
   * @param {object} swagger - The swagger document.
   * @param {string} path - The path.
   * @param {string} verb - The verb.
   * @return {boolean} Return `true` if include, or `false` to exclude.
   */

		/**
   * Merges a well defined swagger document into this one by merging
   * all definitions, paths, responses, tags, and externalDocs into this document.
   *
   * @public
   * @param {object} swagger - A well defined swagger document.
   * @param {object} [options] - Options for controlling the merge.
   * @param {string} [options.prefix] - All paths will be prefixed with `prefix`.
   * @param {pathFilter} [options.filter] - Selectively filter paths.
   * @return {Swagger} The current object (this).
   */

	}, {
		key: 'merge',
		value: function merge(swagger) {
			var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

			// merge in definitions - an improvement could be to not do this
			// automatically and to only merge them if they are used.
			if (swagger.definitions) {
				this.schemas(swagger.definitions);
			}
			return this._mergeGlobalParameters(swagger)._mergeGlobalResponses(swagger)._mergeGlobalTags(swagger)._mergeGlobalExternalDocs(swagger).paths(swagger, options);
		}

		/**
   * Merges in top-level parameters from a well defined swagger document
   * into the current documentation
   * @param  {object} swagger - A well defined swagger document.
   * @return {Swagger} The current object (this).
   */

	}, {
		key: '_mergeGlobalParameters',
		value: function _mergeGlobalParameters(swagger) {
			if (!swagger || !swagger.parameters) {
				return this;
			}
			// Colliding params at this level just take the latest instance of that param
			// This could be upgraded to:
			// 1) Detect the collition O(1)
			// 2) Determine a new and unique param name for the incoming collision
			// 3) Use something like json-refs to find and update all of the references inside
			// the incoming document (swagger) to the newly named param.
			this.doc.parameters = _extends({}, this.doc.parameters || {}, swagger.parameters);
			return this;
		}

		/**
   * Merges in top-level responses from a well defined swagger document
   * into the current documentation
   * @param  {object} swagger - A well defined swagger document.
   * @return {Swagger} The current object (this).
   */

	}, {
		key: '_mergeGlobalResponses',
		value: function _mergeGlobalResponses(swagger) {
			if (!swagger || !swagger.responses) {
				return this;
			}
			// Colliding params at this level just take the latest instance of that response
			// This could be upgraded to:
			// 1) Detect the collition O(1)
			// 2) Determine a new and unique response name for the incoming collision
			// 3) Use something like json-refs to find and update all of the references inside
			// the incoming document (swagger) to the newly named response.
			this.doc.responses = _extends({}, this.doc.responses || {}, swagger.responses);
			return this;
		}

		/**
   * Merges in top-level tags from a well defined swagger document
   * into the current documentation
   * @param  {object} swagger - A well defined swagger document.
   * @return {Swagger} The current object (this).
   */

	}, {
		key: '_mergeGlobalTags',
		value: function _mergeGlobalTags(swagger) {
			var _this6 = this;

			if (!swagger || !swagger.tags) {
				return this;
			}
			// the incoming document (swagger) to the newly named tag.  collisions are
			// handled by over-write.
			swagger.tags.forEach(function (tag) {
				_this6.globalTag(tag);
			});
			return this;
		}

		/**
   * Merges in top-level external docs from a well defined swagger document
   * into the current documentation
   * @param  {object} swagger - A well defined swagger document.
   * @return {Swagger} The current object (this).
   */

	}, {
		key: '_mergeGlobalExternalDocs',
		value: function _mergeGlobalExternalDocs(swagger) {
			if (!swagger || !swagger.externalDocs) {
				return this;
			}
			this.globalExternalDocs(swagger.externalDocs);
			return this;
		}

		/**
   * Sets externalDocs on the current method.
   * @param  {string} doc - A valid ExternalDocumentationObject.
   * @return {Swagger} The current object (this).
   */

	}, {
		key: 'externalDocs',
		value: function externalDocs(doc) {
			if (!this.currentPath) {
				throw new Error('need to start a method using one of: get, post, put, patch, head, options or delete.');
			}
			if ((typeof doc === 'undefined' ? 'undefined' : _typeof(doc)) !== 'object') {
				throw new Error('invalid argument: doc');
			}
			if (!doc.url) {
				throw new Error('missing required argument: doc.url');
			}
			if (typeof doc.url !== 'string') {
				throw new Error('invalid argument: doc.url');
			}
			this.currentPath.externalDocs = doc;
			return this;
		}

		/**
   * Merges a well defined swagger paths into this one by merging the paths found
   * in the supplied `swagger.paths` into this document.
   *
   * @public
   * @param {object} swagger - A well defined swagger document.
   * @param {object} [options] - Options for controlling the merge.
   * @param {string} [options.prefix] - All paths will be prefixed with `prefix`.
   * @param {pathFilter} [options.filter] - Selectively filter paths.
   * @param {RegExp} [options.extensions] - Test to allow (or deny) extensions from
   *											paths and responses.
   * @return {Swagger} The current object (this).
   */

	}, {
		key: 'paths',
		value: function paths(swagger) {
			var _this7 = this;

			var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
			var prefix = options.prefix,
			    filter = options.filter,
			    extensions = options.extensions;

			if (!swagger || !swagger.paths) {
				throw new Error('invalid argument: swagger');
			}
			var extensionPattern = extensions || EXTENSION_PATTERN;
			var cloned = JSON.parse(JSON.stringify(swagger));

			Object.keys(cloned.paths).forEach(function (part) {
				if (extensionPattern.test(part)) {
					// add extension
					_this7.doc.paths[part] = cloned.paths[part];
					return;
				}
				var path = part;
				if (prefix) {
					path = urljoin(prefix, part);
				}
				Object.keys(cloned.paths[part]).forEach(function (verb) {
					var methodOrParams = cloned.paths[part][verb];
					if (extensionPattern.test(verb) || verb === 'parameters' || verb === '$ref') {
						// add extension or parameters
						_this7.doc.paths[path] = _extends({}, _this7.doc.paths[path] || {}, _defineProperty({}, verb, methodOrParams));
					} else if (EXTENSION_PATTERN.test(verb)) {
						// this is an ignored extension that failed `extensionPattern.test` and
						// is not a verb.
					} else {
						// selectively filter out paths
						if (filter) {
							if (!filter(cloned, part, verb)) {
								return;
							}
						}

						// create the swagger path
						if (!_this7[verb]) {
							throw new Error('unrecognized verb: ' + verb);
						}
						_this7[verb](path);

						// clone properties
						['summary', 'description', 'operationId', 'consumes', 'parameters', 'produces', 'responses', 'tags', 'externalDocs'].forEach(function (key) {
							if (methodOrParams.hasOwnProperty(key) && methodOrParams[key] !== '') {
								// clone the component and set in this swagger
								if (key === 'responses') {
									_this7[key](methodOrParams[key], options);
								} else {
									_this7[key](methodOrParams[key]);
								}
							}
						});
						// clone extensions
						Object.keys(methodOrParams).filter(function (key) {
							return extensionPattern.test(key);
						}).forEach(function (extension) {
							_this7.currentPath[extension] = methodOrParams[extension];
						});
					}
				});
			});
			return this;
		}

		/**
   * Returns all of the actions associated with the API endpoints.
   * @public
   * @return {object} Map of [path][verb].
   */

	}, {
		key: 'apidoc',


		/**
   * Returns the Swagger 2.0 API document.
   * @public
   * @return {object} Swagger 2.0 API document.
   */
		value: function apidoc() {
			// strip out undefined keys since they were only used for structuring the object
			return this._removeUndefined(this.doc);
		}

		/**
   * Recursively removes undefined values from an object
   * @private
   * @param {object} obj - The object to remove undefined values from
   * @return {Swagger} The object with undefined values removed.
   */

	}, {
		key: '_removeUndefined',
		value: function _removeUndefined(obj) {
			var _this8 = this;

			if (Object.prototype.toString.call(obj) !== '[object Object]') {
				return obj;
			}
			var newObj = {},
			    keys = Object.keys(obj);
			keys.forEach(function (key) {
				if (obj[key] !== undefined) {
					newObj[key] = _this8._removeUndefined(obj[key]);
				}
			});
			return newObj;
		}

		/**
   * Internally creates a method for verb and path.
   * @private
   * @param {string} verb - The HTTP verb.
   * @param {string} path - The path in Express format.
   * @return {Swagger} The current object (this).
   */

	}, {
		key: '_verb',
		value: function _verb(verb, path) {
			if (!path || typeof path !== 'string') {
				throw new Error('invalid argument: path');
			}
			path = this._rewriteEndpointFromExpressToSwagger(path);
			if (!this.doc.paths.hasOwnProperty(path)) {
				this.doc.paths[path] = {};
			}
			this._action = {
				path: path,
				verb: verb,
				handler: null
			};
			this.currentPath = this.doc.paths[path][verb] = {
				// only responses is required for an operation
				responses: {}
			};

			return this;
		}

		/**
   * Internally checks to see if a parameter exists for the current method.
   * @private
   * @param {string} name - The name of the parameter.
   * @return {boolean} True if the parameter exists.
   */

	}, {
		key: '_parameterExists',
		value: function _parameterExists(name) {
			if (this.currentPath.parameters && this.currentPath.parameters.findIndex(function (a) {
				return a.name === name;
			}) >= 0) {
				return true;
			}
			var pathLevelParams = this.doc.paths[this._action.path] && this.doc.paths[this._action.path].parameters;
			if (pathLevelParams && pathLevelParams.findIndex(function (a) {
				return a.name === name;
			}) >= 0) {
				return true;
			}
			return false;
		}

		/**
   * Ensures that the parameter is defined correctly.
   * @param {object} param - The parameter to check.
   */

	}, {
		key: '_ensureValidParameter',
		value: function _ensureValidParameter(param) {
			if (!param.name) {
				throw new Error('invalid argument: param.name');
			}
			if (!param.in) {
				throw new Error('invalid argument: param.in');
			}
			if (['body', 'formData', 'header', 'path', 'query'].indexOf(param.in) < 0) {
				throw new Error('invalid argument param.in: ' + param.in);
			}
			if (param.type) {
				// swagger specification data types
				if (['string', 'number', 'integer', 'boolean', 'array', 'file'].indexOf(param.type) < 0) {
					throw new Error('invalid argument param.type: ' + param.type);
				}
				if (param.type === 'file') {
					if (param.in !== 'formData') {
						throw new Error('invalid argument param.type of "file" must have param.in of "formData"');
					}

					var consumes = this.currentPath.consumes || this.doc.consumes;
					if (consumes.indexOf('multipart/form-data') < 0 && consumes.indexOf('application/x-www-form-urlencoded') < 0) {
						throw new Error('invalid argument param.type of "file" must have consumes of "multipart/form-data" or "application/x-www-form-urlencoded"');
					}
				}
			} else if (!param.schema) {
				throw new Error('param.schema required when param.type is not defined');
			}
		}

		/**
   * Internally checks that all path parameters are defined.  Throws if not defined.
   * @private
   */

	}, {
		key: '_checkPathParametersAreDefined',
		value: function _checkPathParametersAreDefined() {
			if (PATH_PATTERN.test(this._action.path)) {
				var match = void 0;
				PATH_PATTERN.lastIndex = 0; // < this is horrible
				while (match = PATH_PATTERN.exec(this._action.path)) {
					match = match[0].replace(/[{}]/g, '');
					if (!this._parameterExists(match)) {
						throw new Error('expected path parameter :' + match);
					}
				}
			}
		}

		/**
   * Rewrites path string from /path/:id to /path/{id}.  Internally, the paths are
   * stored as Swagger.
   * @private
   * @param {string} endpoint - endpoint path to convert
   * @return {string} Rewritten string
   */

	}, {
		key: '_rewriteEndpointFromExpressToSwagger',
		value: function _rewriteEndpointFromExpressToSwagger(endpoint) {
			var EXP_PATH_PATTERN = new RegExp(/(?::[\w]+)/g);
			var match = EXP_PATH_PATTERN.exec(endpoint);
			while (match !== null) {
				endpoint = endpoint.replace(match[0], '{' + match[0].replace(':', '') + '}');
				match = EXP_PATH_PATTERN.exec(endpoint);
			}
			return endpoint;
		}

		/**
   * Rewrites path string from Swagger format `/path/{id}` to Express format `/path/:id`.
   * @public
   * @param {string} str - The swagger path to convert.
   * @return {string} Rewritten string
   */

	}, {
		key: 'securityHandlers',
		get: function get() {
			return this._securityHandlers;
		}
	}, {
		key: 'actions',
		get: function get() {
			return this._actions;
		}
	}], [{
		key: 'endpointToExpress',
		value: function endpointToExpress(str) {
			var match = PATH_PATTERN.exec(str);
			while (match !== null) {
				str = str.replace(/{/, ':').replace(/}/, '');
				match = PATH_PATTERN.exec(str);
			}
			return str;
		}

		/**
   * Callback for iterating over Swagger endpoint actions.
   *
   * @callback forEachActionCallback
   * @param {string} path - The endpoint path.
   * @param {string} verb - The endpoint verb.
   */

		/**
   * Iterates over each endpoint in the swagger document.  Useful for binding
   * to Express.
   * @public
   * @param {Swagger} swagger - The swagger document.
   * @param {forEachActionCallback} callback - Called for each endpoint action.
   */

	}, {
		key: 'forEachAction',
		value: function forEachAction(swagger, callback) {
			Object.keys(swagger.actions).forEach(function (path) {
				Object.keys(swagger.actions[path]).forEach(function (verb) {
					callback(verb, path);
				});
			});
		}

		/**
   * Gets the Swagger action middleware function for Express.
   * @public
   * @param {Swagger} swagger - The swagger document.
   * @param {string} verb - The HTTP verb.
   * @param {string} path - The HTTP path.
   * @return {object} The middleware for the specified endpoint
   */

	}, {
		key: 'actionMiddleware',
		value: function actionMiddleware(swagger, verb, path) {
			return swagger.actions[path][verb];
		}

		/**
   * Gets the Swagger security middleware function for Express.
   * @public
   * @param {Swagger} swagger - The swagger document.
   * @param {string} verb - The HTTP verb.
   * @param {string} path - The HTTP path.
   * @returns {function} middleware
   */

	}, {
		key: 'securityMiddleware',
		value: function securityMiddleware(swagger, verb, path) {
			var securityHandlers = null;

			if (!swagger.securityHandlers || !Object.keys(swagger.securityHandlers).length) {
				// No security definitions so no security requirements,
				securityHandlers = [];
			} else {
				// Find the operation
				var globalSecurity = swagger.doc && swagger.doc.security;

				// Find the operation
				var operation = swagger.doc && swagger.doc.paths && swagger.doc.paths[path] && swagger.doc.paths[path][verb];

				if (operation && operation.security) {
					securityHandlers = operation.security.map(function (requirement) {
						return swagger.securityHandlers[Object.keys(requirement)[0]];
					});
				}

				if (!securityHandlers && globalSecurity) {
					securityHandlers = globalSecurity.map(function (requirement) {
						return swagger.securityHandlers[Object.keys(requirement)[0]];
					});
				}
			}
			return function (req, resp, next) {
				var authorized = false;
				if (securityHandlers && securityHandlers.length > 0) {
					for (var i = 0; i < securityHandlers.length; ++i) {
						authorized = securityHandlers[i](req);
						if (authorized) {
							break;
						}
					}
				} else {
					authorized = true;
				}

				if (!authorized) {
					return resp.status(401).send('Unauthorized');
				}
				return next();
			};
		}
	}]);

	return Swagger;
}();

exports = module.exports = Swagger;