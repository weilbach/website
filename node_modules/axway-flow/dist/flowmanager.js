'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var fs = require('fs');
var path = require('path');
var events = require('events');
var chalk = require('chalk');
var parseJson = require('parse-json');
var schemas = require('axway-schema');
var consoleLogger = require('./logger');
var Flow = require('./flow');
var UpgradeManager = require('./upgrademanager');
var noderegistry = require('./noderegistry');

/**
 * Formats a node handler URI.  URI are lower-case.  The `module` must be alpha-numeric, including
 * dash, dot, underscore and forward slash.
 * @private
 * @param {string} module - A module name for scope, e.g. "twilio".
 * @param {string} type - A simple URL safe type name, e.g. "echo".
 * @returns {string} node handler URI
 */
function _formatNodeHandlerUri(module, type) {
	if (!module) {
		throw new Error('Invalid argument: module');
	}
	if (!type) {
		throw new Error('Invalid argument: type');
	}
	if (module.match(/^[\\./a-zA-Z0-9-_]+$/) === null) {
		throw new Error('Invalid node handler module: \'' + module + '\'');
	}
	if (type.match(/^[\\./a-zA-Z0-9-_]+$/) === null) {
		throw new Error('Invalid node handler type: \'' + type + '\'');
	}
	return 'nodehandler://' + module + '/' + type;
}

/**
 * Gets flow upgrades from the fs to be loaded into the upgrade manager. Placed
 * here so that it can be attached as a static method.
 * @param  {string}   dir - A directory to look for upgrades
 * @param  {Function} cb  - An optional callback to fire on error
 * @return {array}       An array of upgrades
 */
function _getUpgrades(dir, cb) {
	var upgradeDir = dir || path.join(__dirname, 'upgrades');
	var upgrades = [];
	var files = [];
	try {
		files = fs.readdirSync(upgradeDir);
	} catch (e) {
		cb && cb(e);
	}
	files.forEach(function (fileName) {
		var filePath = path.join(upgradeDir, fileName);
		try {
			// eslint-disable-next-line security/detect-non-literal-require
			var upgrade = require(filePath);
			upgrades.push(upgrade);
		} catch (e) {
			cb && cb(e);
		}
	});
	return upgrades;
}

/**
 * The Flow manager.
 * @public
 * @class
 */

var FlowManager = function (_events$EventEmitter) {
	_inherits(FlowManager, _events$EventEmitter);

	/**
  * Create a server.
  * @constructor
  * @param {object} logger - The internal logger to use.
  */
	function FlowManager(logger) {
		_classCallCheck(this, FlowManager);

		var _this = _possibleConstructorReturn(this, (FlowManager.__proto__ || Object.getPrototypeOf(FlowManager)).call(this));

		_this.cache = {};
		_this.setLogger(logger);
		var upgradeDir = path.join(__dirname, 'upgrades');
		_this.upgrades = _this.getUpgrades(upgradeDir);

		// TODO: [RDPP-1687] Handle flow versioning/schema validation better
		_this.upgrademanager = new UpgradeManager(_this.logger);
		// Register 'flow' as an upgrade type and all it's accessors
		_this.upgrademanager.registerUpgradeType('flow', {
			getId: function getId(flow, flowPath) {
				return path.basename(flowPath, path.extname(flowPath));
			},
			getVersion: function getVersion(flow) {
				return flow.schemaVersion;
			},
			setVersion: function setVersion(flow, newVersion) {
				flow.schemaVersion = newVersion;
				return flow;
			} }, _this.validate);
		_this.upgrademanager.registerUpgrades(_this.upgrades);
		return _this;
	}

	/**
  * Sets the logger.  Set to `null` to use the default logger.
  * @public
  * @param {object} logger - The internal logger to use.
  */


	_createClass(FlowManager, [{
		key: 'setLogger',
		value: function setLogger(logger) {
			this.logger = logger || consoleLogger;
		}

		/**
   * Gets flow upgrades from the fs to be loaded into the upgrade manager
   * @param  {string}   dir - A directory to look for upgrades
   * @param  {Function} cb  - An optional callback to fire on error
   * @return {array}       An array of upgrades
   */

	}, {
		key: 'getUpgrades',
		value: function getUpgrades(dir, cb) {
			return _getUpgrades(dir, cb);
		}

		/**
   * Formats a node handler URI.  URI are lower-case.
   * @public
   * @param {string} module - A module name for scope, e.g. "twilio".
   * @param {string} type - A simple URL safe type name, e.g. "echo".
   * @returns {string} formatted node handler URI
   */

	}, {
		key: 'formatNodeHandlerUri',
		value: function formatNodeHandlerUri(module, type) {
			return _formatNodeHandlerUri(module, type);
		}

		/**
   * Registers upgrades for the flow
   * @param {array} upgrades - array of upgrades to register with the flow upgrade manager
   */

	}, {
		key: 'registerUpgrades',
		value: function registerUpgrades(upgrades) {
			this.upgrademanager.registerUpgrades(upgrades);
		}

		/**
   * Unregisters upgrades which have been previously registered for the flow
   * @param {array} upgrades - array of upgrades to unregister from the flow upgrade manager
   */

	}, {
		key: 'unregisterUpgrades',
		value: function unregisterUpgrades(upgrades) {
			this.upgrademanager.unregisterUpgrades(upgrades);
		}

		/**
   * Register a node handler.
   * @public
   * @param {string} uri - The unique uri of the node the handler to unregister
   *						 (see `formatNodeHandlerUri`).
   * @param {FlowNode} handler - The handler implementation.
   * @param {function} getHandlerSpec - A function to return the node handler definition.
   */

	}, {
		key: 'registerNode',
		value: function registerNode(uri, handler, getHandlerSpec) {
			this.logger.debug('Registering node handler: ' + uri);

			// Validate the schema for the node handler.  The handler should have all its
			// dependencies met before registration (e.g. code blocks registered).
			var spec = getHandlerSpec && getHandlerSpec();
			if (spec) {
				this.logger.debug('Validating spec for: ' + uri);

				var error = schemas.validate('http://axway.com/schemas/flowschema.json#/node-handler-schema', spec);
				if (error) {
					throw new Error('Unable to register node handler \'' + uri + '\'. ' + error);
				}
			}
			noderegistry.registerNode(uri, handler, spec);
		}

		/**
   * Unregister a node handler.
   * @public
   * @param {string} uri - The unique uri of the node the handler to unregister
   *						 (see `formatNodeHandlerUri`).
   */

	}, {
		key: 'unregisterNode',
		value: function unregisterNode(uri) {
			this.logger.debug('Unregistering node handler ' + uri);
			noderegistry.unregisterNode(uri);
		}

		/**
   * Gets a registered node handler.
   * @public
   * @param {string} type - The type of the node the handler to get.
   * @return {FlowNode} The node handler.
   */

	}, {
		key: 'getRegisteredNode',
		value: function getRegisteredNode(type) {
			return noderegistry.getRegisteredNode(type);
		}

		/**
   * Gets the node handler spec for a registered node.
   * @public
   * @param {string} type - The type of the node the handler specification to get.
   * @return {object} The node handler spec.
   */

	}, {
		key: 'getRegisteredNodeSpec',
		value: function getRegisteredNodeSpec(type) {
			return noderegistry.getNodeSpec(type);
		}

		/**
   * Gets all of the available node handler specs.
   * @public
   * @returns {object|array} The node handler specs.
   */

	}, {
		key: 'getRegisteredNodeSpecs',
		value: function getRegisteredNodeSpecs() {
			return noderegistry.getNodeSpecs();
		}

		/**
   * Return a map of the flow definitions by id.
   * @public
   * @returns {Object} A map of flow definitions by id.
   */

	}, {
		key: 'getFlows',
		value: function getFlows() {
			var _this2 = this;

			return Object.keys(this.cache).reduce(function (prev, cur) {
				prev[cur] = _this2.cache[cur].flow;
				return prev;
			}, {});
		}

		/**
   * Return the flow definition.
   * @public
   * @param {string} flowId - The flow to execute.
   * @returns {Object} The flow definition.
   */

	}, {
		key: 'getFlow',
		value: function getFlow(flowId) {
			return this.cache && this.cache[flowId] && this.cache[flowId].flow;
		}

		/**
   * Exceute the flow.
   * @public
   * @param {string} flowId - The flow to execute.
   * @param {object} data - The data to execute the flow with.
   * @returns {Promise} A promise that will be resolved with the final context when the
   *				   flow execution completes.
   */

	}, {
		key: 'flow',
		value: function flow(flowId, data) {
			if (!this.cache || !this.cache[flowId]) {
				this.logger.error('Flow not found: ' + flowId);
				throw Error('Flow not found: ' + flowId);
			}
			this.emit('preflow', flowId, data);
			this.logger.debug(chalk.dim('Invoking: ' + flowId));

			var promise = this.cache[flowId].invoke(data);
			this.emit('postflow', flowId, data, promise);
			return promise;
		}

		/**
   * Load the flow.
   * @public
   * @param {string} flowPath - The path to the flow json definition.
   * @param {object} options - Options for the upgrade loader.
   * @param {boolean} options.save - Enable to save the upgraded file  (default: false)
   * @returns {Promise} A promise that when resolved contains the loaded flow.
   */

	}, {
		key: 'load',
		value: function load(flowPath, options) {
			var _this3 = this;

			return new Promise(function (resolve, reject) {
				fs.readFile(flowPath, function (err, data) {
					if (err) {
						return reject(err);
					}

					var id = path.basename(flowPath, path.extname(flowPath));

					var flow = void 0;
					try {
						flow = parseJson(data.toString(), flowPath);
					} catch (ex) {
						return reject(new Error('Unable to load flow ' + id + '. ' + ex.message));
					}

					// validate the flow
					_this3.validate(flow).catch(function (error) {
						if (error instanceof Error) {
							return Promise.reject(new Error('Unable to load flow ' + id + '. Syntax error in flow: ' + flowPath + ': ' + error.message));
						}
						return Promise.reject(error);
					}).then(function () {
						// Flow is validated. Upgrade it if needed.
						return _this3.upgrademanager.upgradeFlow(flow, flowPath, options);
					}).then(function (upgradedFlow) {
						// Flow is now the latest version. Add it to the cache.
						return Promise.resolve(_this3._addFlow(id, upgradedFlow));
					}).then(resolve, reject);
				});
			});
		}

		/**
   * Runs schema validation on a flow definition
   *
   * @param {object} flowDef - The flow definition to validate
   * @param {object} opts - validation options
   * @returns {Promise} Will reject with validation errors if any are found
   */

	}, {
		key: 'validate',
		value: function validate(flowDef) {
			var _this4 = this;

			var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { graph: false, schema: true };

			// Validate
			return new Promise(function (resolve, reject) {
				if (opts.graph) {
					var flow = new Flow(null, flowDef, _this4.logger);
					var graphValidation = flow.getValidation();
					if (!graphValidation.valid) {
						return reject(graphValidation);
					}
				}

				if (opts.schema) {
					// TODO: [RDPP-1687] Expand to validate specific flow versions with different schema
					var validation = schemas.validate('http://axway.com/schemas/flowschema.json#/flow-schema', flowDef);
					if (validation) {
						// parse the validation error
						validation = _this4._parseValidation(validation);
						return reject(validation);
					}
				}

				return resolve();
			});
		}

		/**
   * Convert known schema validation error string into something a bit more consumable
   *
   * @param {string} validation - schema validation
   * @param {object} flowDef - flow definition
   * @returns {object} validation Error or object describing validation error
   */

	}, {
		key: '_parseValidation',
		value: function _parseValidation(validation) {
			if (/\$\.start should be string/.test(validation)) {
				return {
					valid: false,
					errors: [{
						code: 'INVALID_NODE',
						type: 'invalidStart'
					}]
				};
			}
			return new Error(validation);
		}

		/**
   * Add a flow to the cache.
   * @private
   * @param {string} flowId - The id for the flow.
   * @param {object} flowDef - The flow definition.
   * @returns {object} flow - the flow
   */

	}, {
		key: '_addFlow',
		value: function _addFlow(flowId, flowDef) {
			this.cache = this.cache || {};
			var flow = this.cache[flowId] = new Flow(flowId, flowDef, this.logger);
			if (flow.getValidation().valid) {
				this.emit('loaded', flow);
			} else {
				this.logger.error('Invalid flow ' + flowId + ': ' + JSON.stringify(flow.getValidation(), null, 2));
				this.emit('invalidflow', flow);
			}
			return flow;
		}
	}]);

	return FlowManager;
}(events.EventEmitter);

// convenience 'static' method


FlowManager.formatNodeHandlerUri = _formatNodeHandlerUri;
FlowManager.getUpgrades = _getUpgrades;
exports = module.exports = FlowManager;