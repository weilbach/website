'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var chalk = require('chalk');
var consoleLogger = require('./logger');
var noderegistry = require('./noderegistry');
var jsonpath = require('jsonpath');
var FlowGraph = require('axway-flow-graph');
var FlowValidator = require('./flowvalidator');

/**
 * An invokable Flow.
 * @public
 * @class
 */

var Flow = function (_FlowGraph) {
	_inherits(Flow, _FlowGraph);

	/**
  * Create a flow.
  * @constructor
  * @param {string} flowId - The id of this flow.
  * @param {object} flowdef - The flow definition.
  * @param {Logger} logger - The logger.
  */
	function Flow(flowId, flowdef, logger) {
		_classCallCheck(this, Flow);

		var _this = _possibleConstructorReturn(this, (Flow.__proto__ || Object.getPrototypeOf(Flow)).call(this, flowId, flowdef));

		_this.logger = logger || consoleLogger;
		_this._InstantiateNodeHandlers();
		_this.registerValidator(FlowValidator);
		_this.validate();
		return _this;
	}

	/**
  * Invoke this flow with the specified context.
  *
  * @public
  * @param {object} data - The initial data to execute the flow with.
  * @returns {Promise} A promise that will be resolved with the final context when the
  *					flow execution completes.
  */


	_createClass(Flow, [{
		key: 'invoke',
		value: function invoke(data) {
			var _this2 = this;

			var validation = this.getValidation();
			if (!validation.valid) {
				// Abort the flow immediately if not valid.
				return Promise.reject(validation);
			}

			var ctx = {
				runtime: {
					paths: {
						reverse: this._getReversePaths()
					}
				},
				data: data
			};

			// Starts flow execution and returns a promise that will wait on
			// termination of all branches of flow.
			var terminationPromise = new Promise(function (resolve, reject) {
				try {
					var terminatorPromises = [];

					_this2.getTerminalNodes(true).forEach(function (nodeID) {
						terminatorPromises.push(_this2._getNodeExecutionPromise(ctx, nodeID));
					});
					Promise.all(terminatorPromises).then(function () {
						return resolve(ctx.data.response);
					}).catch(function (err) {
						return reject(err);
					});

					// resolve unreachable nodes
					_this2._resolveUnreachableNodePaths(ctx);

					// Execute the flow.
					_this2._invokeNodes(ctx, [_this2.nodeHandlers[_this2.flow.start]]);
				} catch (err) {
					reject(err);
				}
			});

			// Abort execution before the completion of the flow
			var abortPromise = this._getNodeExecutionPromise(ctx, '$$.abort').catch(function (err) {
				ctx.runtime.flowAborted = true;
				throw err;
			});

			// Race - on error abort the flow, otherwise wait until all nodes complete.
			return Promise.race([abortPromise, terminationPromise]);
		}

		/**
   * Resolve all notes that are unreachable at the outset.
   * @param {object} ctx - the node context
   * @private
   */

	}, {
		key: '_resolveUnreachableNodePaths',
		value: function _resolveUnreachableNodePaths(ctx) {
			var _this3 = this;

			var next = [this.flow.start];
			// make sure all parents of the start node are resolved before starting
			this._resolveParentNodePaths(ctx, next);

			// Find all nodes who aren't children of start and resolve them
			this.getVertices().filter(function (vertex) {
				return vertex.id !== _this3.flow.start && vertex.parents && Object.keys(vertex.parents).length === 0;
			}).forEach(function (v) {
				_this3._pruneUnexecutableBranches({ ctx: ctx, next: next }, v.id);
				_this3._getNodeExecutionPromise(ctx, v.id).resolve();
			});
		}

		/**
   * Instantiate all the node handlers
   *
   * @private
   */

	}, {
		key: '_InstantiateNodeHandlers',
		value: function _InstantiateNodeHandlers() {
			var _this4 = this;

			this.nodeHandlers = {};
			this.getVertices().forEach(function (vertex) {
				var node = _this4.getNode(vertex.id);
				if (node) {
					// Instantiate the node handlers for the flow:
					_this4.nodeHandlers[vertex.id] = noderegistry.create(vertex.id, node, _this4);
				}
			});
		}
	}, {
		key: 'getNodeHandlers',
		value: function getNodeHandlers(keys) {
			var _this5 = this;

			return Object.keys(this.nodeHandlers).map(function (handlerId) {
				if (keys) {
					return handlerId;
				} else {
					return _this5.nodeHandlers[handlerId];
				}
			});
		}
	}, {
		key: 'getNodeHandler',
		value: function getNodeHandler(handlerId) {
			return this.nodeHandlers[handlerId];
		}
	}, {
		key: '_getReversePaths',
		value: function _getReversePaths() {
			var _this6 = this;

			var paths = {};
			this.getVertices(true).forEach(function (vertexId) {
				_this6.getChildren(vertexId, true).forEach(function (childId) {
					// Add the reverse path
					paths[childId] = paths[childId] || {};
					paths[childId][vertexId] = true;
				});
			});
			return paths;
		}

		/**
   * This method handles invoke the nodes when they are ready and processing the result from the
   * node invocation when it's complete.
   *
   * @private
   * @param {object} ctx - The context to execute the node with.
   * @param {object[]} nodes - The nodes to execute.
   */

	}, {
		key: '_invokeNodes',
		value: function _invokeNodes(ctx, nodes) {
			var _this7 = this;

			if (!nodes || nodes.length === 0) {
				// Branch is complete
				return;
			}

			nodes.forEach(function (node) {
				_this7._invokeWhenReady(ctx, node).then(function (result) {
					return _this7._createNodeResponseContext(ctx, node, result);
				}, function (err) {
					_this7.logger.trace(node.id + ' rejected: ' + err);
					throw err;
				}).then(function (respCtx) {
					return _this7._stopOnAbort(respCtx);
				}).then(function (respCtx) {
					return _this7._selectOutput(respCtx);
				}).then(function (respCtx) {
					return _this7._updateContext(respCtx);
				}).then(function (respCtx) {
					return _this7._resolveExecutionPromise(respCtx);
				}).then(function (respCtx) {
					return _this7._pruneUnexecutableBranches(respCtx);
				}).then(function (respCtx) {
					return _this7._invokeNext(respCtx);
				}).catch(function (err) {
					_this7.logger.debug(chalk.dim('Aborting flow:', err), err.stack);
					_this7._getNodeExecutionPromise(ctx, '$$.abort').reject(err);
				});
			});
		}
		/**
   * Recursively prunes and resolves all nodes which occur previous in the flow to a list of nodes.
   *
   * @private
   * @param {object} ctx - The context to set the resolved state on.
   * @param {object[]} nodes - The nodes to resolve the parents of.
   */

	}, {
		key: '_resolveParentNodePaths',
		value: function _resolveParentNodePaths(ctx, nodes) {
			var _this8 = this;

			if (!nodes || nodes.length === 0) {
				return;
			}
			nodes.forEach(function (node) {
				_this8.logger.trace(' ', chalk.green(node), chalk.dim('pruning node parents'));
				// get the parents for the node
				var parents = _this8.getParents(node, true);
				if (!parents.length) {
					_this8.logger.trace(' ', chalk.green(node), chalk.dim('has no parents'));
					return;
				}
				var reversePaths = ctx.runtime.paths.reverse;
				parents.forEach(function (parent) {
					_this8.logger.trace(' ', chalk.green(node), chalk.dim('found parent ' + chalk.cyan(parent)));
					// if there isn't a path to the parent then return. (could have already been resolved)
					if (!reversePaths[node][parent]) {
						_this8.logger.trace(' ', chalk.green(node), chalk.dim('no route back to'), chalk.cyan(parent));
						return;
					}

					// get the siblings of the node (children of the parent)
					var children = _this8.getChildren(parent, true);
					_this8.logger.trace(' ', chalk.green(node), chalk.dim('parent ' + chalk.cyan(parent)), chalk.dim('has ' + children.length + ' child nodes'));
					children.forEach(function (child) {
						if (child === node) {
							_this8.logger.trace(' ', chalk.green(node), chalk.dim('parent ' + chalk.cyan(parent)), chalk.dim('skipping child ' + chalk.yellow(child) + ' since it\'s the node that we\'re resolving parents for'));
							return;
						}

						// cut the path from child to parent
						_this8.logger.trace(' ', chalk.green(node), chalk.dim('parent ' + chalk.cyan(parent)), chalk.dim('removing route back to ' + chalk.yellow(child)));
						delete reversePaths[child][parent];

						// if the only parent of the child is *this* parent we will prune it
						if (!reversePaths[child] || !Object.keys(reversePaths[child]).length) {
							// cut off all paths from the child
							_this8.logger.trace(' ', chalk.green(node), chalk.dim('cutting inactive paths from ' + chalk.yellow(child)));
							_this8._cutInactivePath(ctx, child);
							// the child doesn't have any parents remaining, resolve it
							_this8.logger.debug(' ', chalk.green(node), chalk.dim('Resolving ' + chalk.yellow(child)));
							delete reversePaths[child];
							_this8._getNodeExecutionPromise(ctx, child).resolve();
						}
					});
					// resolve all paths originating from the parent
					_this8._resolveParentNodePaths(ctx, [parent]);
					// if the parent has no parents left then resolve it
					if (!reversePaths[parent] || !Object.keys(reversePaths[parent]).length) {
						_this8.logger.debug(' ', chalk.green(node), chalk.dim('Resolving ' + chalk.cyan(parent)));
						delete reversePaths[parent];
						_this8._getNodeExecutionPromise(ctx, parent).resolve();
					}
					_this8.logger.trace(' ', chalk.green(node), chalk.dim('removing route to ' + chalk.cyan(parent)));
					// remove the link from the node to the parent
					delete reversePaths[node][parent];
				});
			});
		}

		/**
   * A node must wait until it is invocable before it can be invoked.
   *
   * A node is considered invocable if all paths to this node have been completed
   * (i.e. all parent nodes have completed.)
   *
   * @private
   * @param {object} ctx - The context to execute the node with.
   * @param {object} node - The nodes to execute.
   * @returns {Promise} A promise that is resolved when the node is invokable and that
   * invocation completes.
   */

	}, {
		key: '_invokeWhenReady',
		value: function _invokeWhenReady(ctx, node) {
			var _this9 = this;

			this.logger.debug(chalk.dim('Waiting:', node.id));

			var nodePromise = new Promise(function (resolve) {
				Promise.all(_this9._getNodeParentExecutionPromises(ctx, node.id)).then(function () {
					_this9.logger.debug(chalk.dim('Invoking:', node.id));
					resolve(node.invoke(ctx));
				});
			});

			return Promise.race([this._getNodeExecutionPromise(ctx, '$$.abort'), nodePromise]);
		}

		/**
   * Create a response context for use in the chain that processes the invoke() response.
   * The response context is:
   * {
   *	flowAborted: boolean,
   *	ctx: context,
   *	node: object,
   *	result: object,
   *	next: array
   * }
   * @private
   * @param {object} ctx - The context to execute the node with.
   * @param {string} node - The node name.
   * @param {object} result - The node invoke result.
   * @returns {object} An object with the necessary information for further processing.
   */

	}, {
		key: '_createNodeResponseContext',
		value: function _createNodeResponseContext(ctx, node, result) {
			return {
				flowAborted: !!ctx.runtime.flowAborted,
				ctx: ctx,
				node: node,
				result: result.results,
				output: result.output,
				next: []
			};
		}

		/**
   * Short circuit processing if the flow has been aborted.
   * @private
   * @param {object} responseCtx - The response context for this invocation.
   * @returns {object} The response context for this invocation (to support chaining).
   */

	}, {
		key: '_stopOnAbort',
		value: function _stopOnAbort(responseCtx) {
			if (responseCtx.flowAborted) {
				throw new Error('Aborted');
			}
			return responseCtx;
		}

		/**
   * Get the promise that will be resolved when the node is executed.
   *
   * @private
   * @param {object} ctx - The context - execution promises are stored in the context.
   * @param {string} nodeName - The name of the node to get the promise for.
   * @returns {Promise} The execution promise for nodeName.
   */

	}, {
		key: '_getNodeExecutionPromise',
		value: function _getNodeExecutionPromise(ctx, nodeName) {
			ctx.runtime = ctx.runtime || {};
			var promises = ctx.runtime.promises = ctx.runtime.promises || {};

			if (!promises[nodeName]) {
				var getPromise = function getPromise() {
					var execResolve = null;
					var execReject = null;

					var promise = new Promise(function (resolve, reject) {
						execResolve = resolve;
						execReject = reject;
					});
					promise.resolve = execResolve;
					promise.reject = execReject;
					return promise;
				};

				promises[nodeName] = getPromise();
			}

			return promises[nodeName];
		}

		/**
   * Get the promises that will be resolved when the nodes parents are executed.
   *
   * @private
   * @param {object} ctx - The context - execution promises are stored in the context.
   * @param {string} nodeId - The id of the node whose parent promises are being requested.
   * @returns {Promise[]} An array containing the execution promises for nodeNames parent nodes.
   */

	}, {
		key: '_getNodeParentExecutionPromises',
		value: function _getNodeParentExecutionPromises(ctx, nodeId) {
			var _this10 = this;

			var parentPromises = [];
			this.getParents(nodeId, true).forEach(function (parentId) {
				parentPromises.push(_this10._getNodeExecutionPromise(ctx, parentId));
			});
			return parentPromises;
		}

		/**
   * Convenience method to resolve the nodes promise in a thenable chain.
   *
   * @private
   * @param {object} responseCtx - The response context for this invocation.
   * @returns {object} The response context for this invocation (to support chaining).
   */

	}, {
		key: '_resolveExecutionPromise',
		value: function _resolveExecutionPromise(responseCtx) {
			this._getNodeExecutionPromise(responseCtx.ctx, responseCtx.node.id).resolve();
			return responseCtx;
		}

		/**
   * Update the context with the result from the node execution.
   *
   * @param {object} responseCtx - The response context for this invocation.
   * @returns {object} The response context for this invocation (to support chaining).
   */

	}, {
		key: '_updateContext',
		value: function _updateContext(responseCtx) {
			var nodeconfig = responseCtx.node.node;
			var output = responseCtx.output && nodeconfig.outputs[responseCtx.output];
			var target = output && output.context;

			if (target && responseCtx.result !== undefined) {
				var result = responseCtx.result;

				this.logger.debug(chalk.green(' ', responseCtx.node.id), chalk.dim('writing'), chalk.yellow(JSON.stringify(result)), chalk.dim('to ctx as:'), chalk.cyan(target));

				jsonpath.value(responseCtx.ctx.data, target, result);
			}

			return responseCtx;
		}

		/**
   * Update the response context with the nodes that will be executed next.
   *
   * @private
   * @param {object} respCtx - The response context for this invocation.
   * @returns {object} The response context for this invocation (to support chaining).
   */

	}, {
		key: '_selectOutput',
		value: function _selectOutput(respCtx) {
			var nodeconfig = respCtx.node.node;
			var output = respCtx.output && nodeconfig.outputs[respCtx.output];

			if (output) {
				respCtx.next = output.routes ? output.routes : [];
			}
			this.logger.debug(' ', chalk.green(respCtx.node.id), 'route:', chalk.dim(JSON.stringify(respCtx.next)));
			return respCtx;
		}

		/**
   * Remove the paths that are no longer executable
   *
   * @private
   * @param {object} responseCtx - The response context for this invocation.
   * @param {string} sourceId - optional - the id of the node to start pruning from.
   * @returns {object} The response context for this invocation (to support chaining).
   */

	}, {
		key: '_pruneUnexecutableBranches',
		value: function _pruneUnexecutableBranches(responseCtx, sourceId) {
			if (!sourceId) {
				sourceId = responseCtx.node.id;
			}
			var inactivePaths = this.getChildren(sourceId, true).filter(function (child) {
				return responseCtx.next.indexOf(child) === -1;
			}).map(function (child) {
				return { source: sourceId, target: child };
			});
			this._cutInactivePath(responseCtx.ctx, inactivePaths);
			return responseCtx;
		}

		/**
   * Remove the paths that are no longer active.
   *
   * @private
   * @param {object} ctx - The flow context.
   * @param {(object[]|string)} inactivePaths - The list of paths that are no longer
   *		active. If a single node name is specified then all children are cut.
   * @param {string} inactivePaths[].source - The source node.
   * @param {string} inactivePaths[].target - The target node.
   */

	}, {
		key: '_cutInactivePath',
		value: function _cutInactivePath(ctx, inactivePaths) {
			var _this11 = this;

			if (!inactivePaths) {
				return;
			} else if (typeof inactivePaths === 'string' || inactivePaths instanceof String) {
				// All children of the specified node
				inactivePaths = this.getChildren(inactivePaths, true).map(function (childId) {
					return { source: inactivePaths, target: childId };
				});
			}

			if (!inactivePaths.length) {
				return;
			}

			var reversePaths = ctx.runtime.paths.reverse;

			// Filter out the inactive paths from the runtime graph
			inactivePaths.forEach(function (path) {
				// if the target hasn't already been resolved, and the target still has reverse link to source
				if (reversePaths[path.target] && reversePaths[path.target][path.source]) {
					// remove the source as a parent of the target node
					delete reversePaths[path.target][path.source];
					// only resolve nodes which have no parents left
					if (!Object.keys(reversePaths[path.target]).length) {
						// No more paths to this node so resolve it's execution promise and clean up.
						delete reversePaths[path.target];
						_this11._getNodeExecutionPromise(ctx, path.target).resolve();
						_this11._cutInactivePath(ctx, path.target);
					}
				}
			});
		}

		/**
   * Invoke the next nodes, called after updateContext (which detects the next nodes).
   * Note nodes will only be invoked once.
   *
   * @private
   * @param {object} responseCtx - The response context for this invocation.
   * @returns {object} The response context for this invocation (to support chaining).
   */

	}, {
		key: '_invokeNext',
		value: function _invokeNext(responseCtx) {
			var _this12 = this;

			var ctx = responseCtx.ctx;
			var pending = ctx.pending = ctx.pending || {};
			var nextNodeKeys = responseCtx.next;
			var nextNodes = [];

			// Invoke the next node if it's not already pending
			nextNodeKeys.forEach(function (nodeKey) {
				if (!pending.hasOwnProperty(nodeKey)) {
					var next = _this12.nodeHandlers[nodeKey];
					nextNodes.push(next);
					pending[nodeKey] = true;
				}
			});

			this._invokeNodes(ctx, nextNodes);

			return responseCtx;
		}

		/**
   * Gets the node handler definition.
   * @public
   * @param {string} node - The node handler.
   * @returns {object} the node spec
   */

	}, {
		key: 'getNodeSpec',
		value: function getNodeSpec(node) {
			return noderegistry.getNodeSpec(node.type);
		}

		/**
   * @member {boolean} validateParameters
   */

	}, {
		key: 'validateParameters',
		get: function get() {
			return this._enableParameterValidation;
		},
		set: function set(enable) {
			this._enableParameterValidation = enable;
		}
	}]);

	return Flow;
}(FlowGraph);

exports = module.exports = Flow;