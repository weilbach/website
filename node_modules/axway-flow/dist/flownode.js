'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var getByJsonPath = require('./jsonpath').getByJsonPath;
var consoleLogger = require('./logger');
var chalk = require('chalk');

var FlowNode = function () {
	function FlowNode(id, node, spec, flow) {
		_classCallCheck(this, FlowNode);

		this.node = node || {};
		this.id = id;
		this.spec = spec;
		this.flow = flow;
		this.logger = this.flow.logger || consoleLogger;
		this.title = new.target;
		if (new.target === FlowNode) {
			throw new TypeError('Cannot construct FlowNode instances directly.');
		}
	}

	/**
  * Gets the action method information.
  * @private
  * @return {object} The method.
  */


	_createClass(FlowNode, [{
		key: '_getActionMethod',
		value: function _getActionMethod() {
			var methodNames = Object.keys(this.spec.methods);
			// note: spec does not allow 0 methods, so it exists
			if (methodNames.length > 1) {
				// If a node has more than one method, then `config.method` is required.
				if (!this.node.method) {
					throw new Error('expected method config for node: ' + this.id);
				}
			}

			var methodIdx = methodNames.indexOf(this.node.method);
			if (methodIdx < 0) {
				throw new Error('node \'' + this.id + '\' is configured to use an unknown method: ' + this.node.method);
			}
			var name = methodNames[methodIdx];
			var action = this[name];
			if (!action) {
				console.info(this);
				throw new Error('expected handler for node \'' + this.id + '\' to have function named: ' + name);
			}
			return {
				name: name,
				spec: this.spec,
				method: this.spec.methods[name],
				action: action.bind(this)
			};
		}

		/**
   * Resolve parameters from a context.
   * @param {object} ctx - the execution context
   * @returns {object} params - map of parameters for the current node
   */

	}, {
		key: 'resolveParameters',
		value: function resolveParameters(ctx) {
			var _this = this;

			var params = null;
			this.node.parameters && this.node.parameters.forEach(function (param) {
				params = params || {};
				var val = param.value;

				if (param.type === undefined || param.type === 'jsonpath') {
					val = getByJsonPath(val, ctx.data);
				} else {
					try {
						val = JSON.parse(val);
					} catch (e) {
						val = undefined;
					}
				}

				// if value is undefined, do not assign to params - it does not resolve.
				if (val !== undefined) {
					params[param.name] = val;
				}

				// useful for debugging parameters:
				if (param.type === undefined || param.type === 'jsonpath') {
					_this.logger.trace(chalk.dim('  resolved selector ' + param.value + ' for param \'' + param.name + '\' as ' + JSON.stringify(params[param.name])));
				} else {
					_this.logger.trace(chalk.dim('  resolved param \'' + param.name + '\' as ' + JSON.stringify(params[param.name])));
				}
			});
			return params;
		}

		/**
   * Set up the callbacks.
   * @param {object} actionMethod - the method to generate callback for
   * @param {function} cb - the callback to bind outputs to
   * @returns {object|function} the generated output callback
   */

	}, {
		key: 'curryOutputCallbacks',
		value: function curryOutputCallbacks(actionMethod, cb) {
			var self = this;
			var outputKeys = Object.keys(actionMethod.method.outputs);
			var outputCallback = void 0;

			// Set the default cb(err, result) target. This is required for upgrade where
			// existing nodehandlers may be unaware of the outputs and for handlers that have
			// no outputs.
			if (!outputKeys.length) {
				// No ouputs defined - callback is for completion only
				outputCallback = function outputCallback(err) {
					return cb(null, err);
				};
			} else if (outputKeys.length === 1) {
				// There's only one output, it's the de-facto default
				outputCallback = function outputCallback(err, result) {
					return cb(outputKeys[0], err, result);
				};
			} else {
				// Get default as defined in the spec.
				var defaultOutput = outputKeys.find(function (output) {
					return actionMethod.method.outputs[output].hasOwnProperty('default') && actionMethod.method.outputs[output].default;
				}) || outputKeys[0];
				outputCallback = function outputCallback(err, result) {
					return cb(defaultOutput, err, result);
				};
			}

			// Curry the callback with the known possible outputs. So you can do:
			// cb.<output>(<err>, <result>)
			outputCallback = outputKeys.reduce(function (col, cur) {
				col[cur] = cb.bind(self, cur);
				return col;
			}, outputCallback);

			return outputCallback;
		}
	}, {
		key: 'invoke',
		value: function invoke(ctx) {
			var _this2 = this;

			var promise = new Promise(function (resolve, reject) {
				var callback = function callback(output, err, results) {
					if (err) {
						_this2.logger.trace(_this2.id + ' rejected.');
						reject(err);
					}
					_this2.logger.trace(_this2.id + ' ' + output + ' resolved.');
					resolve({ results: results, output: output });
				};

				try {
					var params = _this2.resolveParameters(ctx);
					var actionMethod = _this2._getActionMethod();
					var callbacks = _this2.curryOutputCallbacks(actionMethod, callback);
					// Invoke
					actionMethod.action({ params: params }, callbacks);
				} catch (err) {
					_this2.logger.trace(_this2.id + ' rejected: ' + err);
					_this2.logger.trace(err);
					reject(err);
				}
			});

			return promise;
		}
	}]);

	return FlowNode;
}();

exports = module.exports = FlowNode;