'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var FlowGraph = require('axway-flow-graph');
var schemas = require('axway-schema');

/**
 * Helper for validating flows. The validation checks for:
 * - no cyclical loops
 * - no undefined nodes in the routing
 *
 * @private
 * @class
 */

var FlowValidator = function (_FlowGraph$Validator) {
	_inherits(FlowValidator, _FlowGraph$Validator);

	function FlowValidator() {
		_classCallCheck(this, FlowValidator);

		return _possibleConstructorReturn(this, (FlowValidator.__proto__ || Object.getPrototypeOf(FlowValidator)).apply(this, arguments));
	}

	_createClass(FlowValidator, [{
		key: 'checkNodeHandlers',

		/**
   * Check that the flow node handlers are valid.
  	 *
  	 * @private
  	 * @param {object} validationData - The object to add the validation errors to.
  	 * @returns {boolean} true if there are invalid nodes detected.
  	 */
		value: function checkNodeHandlers(validationData) {
			var _this2 = this;

			this.flowGraph.getNodeHandlers().forEach(function (handler) {
				if (handler.spec.hasOwnProperty('deprecated') && handler.spec.deprecated) {
					_this2._addValidationWarning(validationData, {
						type: 'deprecatedNodeHandler',
						code: 'DEPRECATED',
						detail: {
							node: handler.id,
							nodehandler: handler.spec.type
						}
					});
				}
			});
			// only warnings here
			return false;
		}
	}, {
		key: 'checkNodeParameters',
		value: function checkNodeParameters(validationData) {
			var _this3 = this;

			var invalid = false;
			this.flowGraph.getNodes(true).forEach(function (nodeId) {
				var node = _this3.flowGraph.getNode(nodeId);
				var parameters = node.parameters;
				var spec = _this3.flowGraph.getNodeSpec(node);
				var specParams = spec && spec.methods && spec.methods[node.method] && spec.methods[node.method].parameter;
				if (!specParams) {
					return;
				}

				// Check that all required parameters are accounted for
				if (specParams && specParams.required && specParams.required.length) {
					specParams.required.forEach(function (param) {
						if (!parameters.length || !parameters.some(function (nodeParam) {
							return nodeParam && nodeParam.name === param;
						})) {
							invalid = true;
							_this3._addValidationError(validationData, {
								type: 'invalidNodeParameter',
								code: 'MISSING_VALUE',
								detail: {
									node: nodeId,
									parameter: param
								}
							});
						}
					});
				}
				// map for converting schema types into corresponding flow types
				var schemaTypeMap = {
					string: 'string',
					boolean: 'boolean',
					integer: 'number',
					number: 'number',
					object: 'object',
					array: 'array',
					null: 'null'
				};

				parameters.forEach(function (param) {
					var specParam = specParams.properties && specParams.properties[param.name];
					var skipSchemaValidation = false;

					// un-spec'd params aren't allowed
					if (!specParam) {
						invalid = true;
						_this3._addValidationError(validationData, {
							type: 'invalidNodeParameter',
							code: 'NOT_IN_SPEC',
							detail: {
								node: nodeId,
								parameter: param.name
							}
						});
						return;
					}

					// Deref top level if needed
					if (!specParam) {
						skipSchemaValidation = true;
					} else if (specParam && specParam.$ref) {
						var ref = schemas.get(specParam.$ref);
						if (Array.isArray(ref) || !ref) {
							// ref was not found
							skipSchemaValidation = true;
						} else {
							specParam = ref;
						}
					} else {
						try {
							specParam = schemas.dereference(specParam);
						} catch (e) {
							skipSchemaValidation = true;
						}
					}

					// Is parameter type correct?
					if (specParam && specParam.type && param.type && param.type !== 'jsonpath') {
						// JSON schema type could be an array...
						var types = Array.isArray(specParam.type) ? specParam.type : [specParam.type];
						// map each schema type to flow param type and dedupe
						var knownTypes = types.filter(function (type) {
							return schemaTypeMap[type];
						});
						var expectedTypes = [].concat(_toConsumableArray(new Set(knownTypes.map(function (type) {
							return schemaTypeMap[type];
						}))));
						expectedTypes.push('jsonpath'); // it's not going to be jsonpath but it's an expected type.
						if (!expectedTypes.includes(param.type)) {
							invalid = true;
							_this3._addValidationError(validationData, {
								type: 'invalidNodeParameter',
								code: 'INVALID_TYPE',
								detail: {
									node: nodeId,
									parameter: param.name,
									expectedTypes: expectedTypes
								}
							});
							return;
						}
					}

					// Is parameter data parseable to specified type?
					if (param.type && param.type !== 'jsonpath' && specParam) {
						var value = null;
						var data = value = _this3._parseParamValue(param);
						if (data.error) {
							invalid = true;
							_this3._addValidationError(validationData, {
								type: 'invalidNodeParameter',
								code: data.error,
								detail: {
									node: nodeId,
									parameter: param.name
								}
							});
							return;
						}

						// Does non-jsonpath type parameter validate against spec schema?
						if (!skipSchemaValidation) {
							var validate = schemas.ajv.compile(specParam);
							var valid = validate(value.data);
							if (!valid) {
								invalid = true;
								_this3._addValidationError(validationData, {
									type: 'invalidNodeParameter',
									code: 'INVALID_VALUE',
									detail: {
										node: nodeId,
										parameter: param.name,
										errors: validate.errors
									}
								});
							}
						}
					} else {
						// Check if the jsonpath param is valid
						var _data = _this3._parseParamValue(param);
						if (_data.error) {
							invalid = true;
							_this3._addValidationError(validationData, {
								type: 'invalidNodeParameter',
								code: _data.error,
								detail: {
									node: nodeId,
									parameter: param.name
								}
							});
						}
					}
				});
			});
			return invalid;
		}

		/**
   * Check that the flow nodes have all the defined outputs.
  	 *
  	 * @private
  	 * @param {object} validationData - The object to add the validation errors to.
  	 * @returns {boolean} true if there are invalid nodes detected.
  	 */

	}, {
		key: 'checkNodeOutputs',
		value: function checkNodeOutputs(validationData) {
			var _this4 = this;

			var invalid = false;
			this.flowGraph.getNodes(true).forEach(function (nodeId) {
				var node = _this4.flowGraph.getNode(nodeId);
				var nodeOutputs = Object.keys(node.outputs);

				var spec = _this4.flowGraph.getNodeSpec(node);
				var specOutputs = spec && spec.methods && spec.methods[node.method] && spec.methods[node.method].outputs && Object.keys(spec.methods[node.method].outputs);

				if (specOutputs) {
					var missingOutputs = specOutputs.filter(function (o) {
						return nodeOutputs.indexOf(o) === -1;
					});
					var unknownOutputs = nodeOutputs.filter(function (o) {
						return specOutputs.indexOf(o) === -1;
					});
					if (missingOutputs.length) {
						missingOutputs.forEach(function (missingOutput) {
							invalid = true;
							_this4._addValidationError(validationData, {
								type: 'invalidNodeOutput',
								code: 'MISSING_KEY',
								detail: {
									output: missingOutput,
									node: nodeId
								}
							});
						});
					}
					if (unknownOutputs.length) {
						invalid = true;
						unknownOutputs.forEach(function (unknownOutput) {
							_this4._addValidationError(validationData, {
								type: 'invalidNodeOutput',
								code: 'NOT_IN_SPEC',
								detail: {
									output: unknownOutput,
									node: nodeId
								}
							});
						});
					}
				}
			});
			return invalid;
		}

		/**
   * Check that each node's method is registered with the corresponding node handler
   * @param  {object} validationData - The object containing validation errors
   * @return {bool} true if there are invalid methods detected
   */

	}, {
		key: 'checkNodeMethods',
		value: function checkNodeMethods(validationData) {
			var _this5 = this;

			var invalid = false;
			this.flowGraph.getNodes(true).forEach(function (nodeId) {
				var node = _this5.flowGraph.getNode(nodeId);
				var method = node.method || '';
				var spec = _this5.flowGraph.getNodeSpec(node);
				if (!spec.methods[method]) {
					invalid = true;
					_this5._addValidationError(validationData, {
						type: 'invalidMethod',
						code: 'INVALID_VALUE',
						detail: {
							node: nodeId,
							method: method
						}
					});
				}
			});
			return invalid;
		}

		/**
   * Run all checks on the flow and report any validation errors.
   * @returns {object} validationData object
  	 */

	}, {
		key: 'validate',
		value: function validate() {
			var validationData = _get(FlowValidator.prototype.__proto__ || Object.getPrototypeOf(FlowValidator.prototype), 'validate', this).call(this);
			this.checkNodeHandlers(validationData);
			this.checkNodeOutputs(validationData);
			this.checkNodeMethods(validationData);
			this.checkNodeParameters(validationData);
			return validationData;
		}

		/**
   * Log a deprecation warning.
   * @param {object} handler - node handler to log deprecation for
   */

	}, {
		key: 'logDeprecation',
		value: function logDeprecation(handler) {
			if (handler.spec.hasOwnProperty('deprecated')) {
				var message = void 0;
				if (typeof handler.spec.deprecated === 'string') {
					message = handler.spec.deprecated;
				} else if (_typeof(handler.spec.deprecated) === 'object') {
					// Internationalized message - just display them all
					message = Object.keys(handler.spec.deprecated).reduce(function (col, lang) {
						return col + '[' + lang + ': ' + handler.spec.deprecated[lang] + ']';
					}, '');
				} else if (typeof handler.spec.deprecated === 'boolean') {
					message = handler.spec.type + ' has been deprecated, please upgrade your flow.';
				}

				this.flowGraph.logger.warn(handler.flow.id + '[' + handler.id + ']: ' + message);
			}
		}
	}]);

	return FlowValidator;
}(FlowGraph.Validator);

exports = module.exports = FlowValidator;