'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var fs = require('fs');
var consoleLogger = require('./logger');

/**
 * Returns a new constructed error for an upgrade with a blame message
 *
 * @param {string} reason - reason why upgrade failed
 * @param {object} upgrade - the upgrade which failed
 * @param {string} details - upgrade error details
 * @returns {Error} the constructed error
 */
function errorAndBlame(reason, upgrade, details) {
	var from = upgrade.from,
	    to = upgrade.to,
	    id = upgrade.id,
	    owner = upgrade.owner,
	    stage = upgrade.stage;

	var info = 'Upgrade details: ' + JSON.stringify({ from: from, to: to, id: id, stage: stage }, null, 2);
	var err = reason + '.\n' + info;
	if (owner) {
		err += '\nThis is probably the fault of ' + owner;
	} else {
		err += '\n The owner was not specified';
	}
	if (details) {
		err += '\n' + details;
	}
	return new Error(err);
}

/**
 * Calls a callback promise asyncronously for each item in the passed array
 *
 * @param {any} items - items to iterate over
 * @param {Promise} cb - promise to call for each item
 * @param {any} originalData - this wil be what the fisrt promise resolves with
 * @returns {Promise} the promise chain
 */
function promiseForEach(items, cb, originalData) {
	var promise = Promise.resolve(originalData);
	if (items && items.length) {
		items.forEach(function (currentItem) {
			promise = promise.then(function (result) {
				return cb(currentItem, result);
			});
		});
	}
	return promise;
}

/**
 * The Upgrade manager.
 * @public
 * @class
 */

var UpgradeManager = function () {
	/**
  * Create an class which registers and perfoms upgrades on data.
  * @constructor
  * @param {object} logger - The internal logger to use.
  */
	function UpgradeManager(logger) {
		_classCallCheck(this, UpgradeManager);

		this.logger = logger || consoleLogger;
		this.types = {};
		this.upgrades = {};
		this.registerUpgrades = this.registerUpgrades.bind(this);
		this.unregisterUpgrades = this.unregisterUpgrades.bind(this);
		this.registerUpgradeType = this.registerUpgradeType.bind(this);
		this._getUpgrade = this._getUpgrade.bind(this);
		this._registerUpgrade = this._registerUpgrade.bind(this);
		this._unregisterUpgrade = this._unregisterUpgrade.bind(this);
		this._upgradeVersion = this._upgradeVersion.bind(this);
		this._runUpgrade = this._runUpgrade.bind(this);
	}

	/**
  * Registers an array of upgrades
  *
  * @param {array} upgrades - upgrades to register
  */


	_createClass(UpgradeManager, [{
		key: 'registerUpgrades',
		value: function registerUpgrades(upgrades) {
			upgrades.forEach(this._registerUpgrade);
		}

		/**
   * Unregisters an array of upgrades
   *
   * @param {array} upgrades - upgrades to unregister
   */

	}, {
		key: 'unregisterUpgrades',
		value: function unregisterUpgrades(upgrades) {
			upgrades.forEach(this._unregisterUpgrade);
		}

		/**
   * Registers a data type to handle upgrades for
   *
   * @param {string} type - the type to register
   * @param {object} accessors - functions to let the upgrade manager access and modify the data
   * @param {function} accessors.getId - function which returns the ID of the data.
   *                                     takes the data and the file path if specified
   * @param {function} accessors.getVersion - function which returns the version of the data passed
   * @param {function} accessors.setVersion - function which sets the version of the data
   *                                          passed and returns the updated data
   * @param {function} validator - function which returns a promise that validates the data.
   *                               This will be run after each upgrade
   */

	}, {
		key: 'registerUpgradeType',
		value: function registerUpgradeType(type, accessors, validator) {
			this.logger.debug('Registering upgrade handler for ' + type);

			// Validate the upgrade type
			if (this.types[type]) {
				throw new Error('Upgrade handler for ' + type + ' already exists');
			}
			['getId', 'getVersion', 'setVersion'].forEach(function (key) {
				if (!accessors[key] || typeof accessors[key] !== 'function') {
					throw new Error('Upgrade handle must register accessor method for ' + key);
				}
			});

			// Save the type (eg flow)
			this.types[type] = {
				type: type,
				validator: validator,
				accessors: {
					getId: accessors.getId,
					getVersion: accessors.getVersion,
					setVersion: accessors.setVersion
				}
			};

			// Setup a place to save this type's upgrades
			this.upgrades[type] = {};

			// Assign an updator method e.g. upgradeManager.upgradeFlow(data, filePath);
			this['upgrade' + (type.charAt(0).toUpperCase() + type.slice(1))] = this._getUpgrade(type);
		}

		/**
   * Unregisters an upgrade type and all registered upgrades for that type
   *
   * @param {string} type - the type to unregister
   */

	}, {
		key: 'unregisterUpgradeType',
		value: function unregisterUpgradeType(type) {
			if (type && this.types[type]) {
				delete this.types[type];
				delete this.upgrades[type];
				delete this['upgrade' + (type.charAt(0).toUpperCase() + type.slice(1))];
			}
		}

		/**
   * Get a function to upgrade data of a certain type
   *
   * @param {string} type - type of the data to generate an upgrade function for
   * @returns {function} upgrade function for data of the specified type
   */

	}, {
		key: '_getUpgrade',
		value: function _getUpgrade(type) {
			var _this = this;

			return function (data, filePath, options) {
				_this.logger.debug('Running upgrade for ' + type);
				var _types$type$accessors = _this.types[type].accessors,
				    getVersion = _types$type$accessors.getVersion,
				    getId = _types$type$accessors.getId;

				var upgrades = _this.upgrades[type];

				// Determine the upgrade sequence. Must be increasing
				var upgradePath = [];
				var currentVersion = getVersion(data);
				do {
					var nextVersion = upgrades[currentVersion] && upgrades[currentVersion].to;
					if (nextVersion) {
						upgradePath.push(nextVersion);
					}
					currentVersion = nextVersion;
				} while (currentVersion);

				// If we couldn't map out an upgrade sequence just resolve the un-upgraded data
				if (!upgradePath.length) {
					return Promise.resolve(data);
				}

				var id = getId(data, filePath);

				// Run each upgrade sequentially
				return promiseForEach(upgradePath, function (to, upgradedData) {
					return _this._upgradeVersion(type, upgradedData, id);
				}, data).then(function (newData) {
					return new Promise(function (resolve) {
						_this.logger.debug(type + ' upgrade was successful');
						// Save if specified
						if (options && filePath && options.save) {
							return fs.writeFile(filePath, JSON.stringify(newData, null, 2), 'utf-8', function (err) {
								if (err) {
									_this.logger.error('There was a problem saving ' + type + ' data for ' + id + ' after upgrade\n' + err);
								}
								return resolve(newData);
							});
						}
						return resolve(newData);
					});
				});
			};
		}

		/**
   * Registers an upgrade to the manager.
   * Will throw if upgrade is invalid.
   *
   * @param {object} upgrade - upgrade definition
   */

	}, {
		key: '_registerUpgrade',
		value: function _registerUpgrade(upgrade) {
			var to = upgrade.to,
			    from = upgrade.from,
			    stage = upgrade.stage,
			    type = upgrade.type;
			// validate upgrade

			var errStart = 'Cannot register ' + type + ' upgrade:';
			var validStages = ['pre', 'post', 'main'];
			var required = ['to', 'from', 'stage', 'fn', 'owner', 'id', 'type'];
			required.forEach(function (key) {
				if (!upgrade[key]) {
					throw errorAndBlame(errStart + ' missing required property \'' + key + '\'', upgrade);
				}
			});
			if (!this.types[type]) {
				throw errorAndBlame(errStart + ' type is unknown', upgrade);
			}
			if (!validStages.includes(stage)) {
				throw errorAndBlame(errStart + ' Upgrade stage must be one of ' + JSON.stringify(validStages), upgrade);
			}
			if (from >= to) {
				throw errorAndBlame(errStart + ' Upgrades cannot go to a previous version', upgrade);
			}
			var upgrades = this.upgrades[type];
			if (stage === 'main') {
				// You can only have one path from n. You can't have 1 to 2 and 1 to 4.
				if (upgrades[from]) {
					throw errorAndBlame(errStart + ' Upgrade already exists from version ' + from, upgrade);
				}
				// Register main upgrade
				upgrades[from] = {
					to: to,
					from: from,
					pre: [],
					main: upgrade,
					post: []
				};
			} else if (!upgrades[from]) {
				// A 'main' upgrade has to be registered first
				throw errorAndBlame(errStart + ' No upgrade path exists', upgrade);
			} else {
				// Register pre/post upgrade
				upgrades[from][stage].push(upgrade);
			}
		}

		/**
   * Unregisters an upgrade from the manager
   *
   * @param {object} upgrade - upgrade definition
   */

	}, {
		key: '_unregisterUpgrade',
		value: function _unregisterUpgrade(upgrade) {
			var owner = upgrade.owner,
			    id = upgrade.id,
			    stage = upgrade.stage,
			    from = upgrade.from,
			    to = upgrade.to,
			    type = upgrade.type;

			if (!this.upgrades[type] || !this.upgrades[type][from]) {
				return;
			}
			var u = this.upgrades[type];
			if (stage === 'main') {
				delete u[from];
			} else {
				var upgrades = u[from][stage];
				if (!upgrades) {
					return;
				}
				var index = upgrades.findIndex(function (x) {
					return x.from === from && x.to === to && x.id === id && x.owner === owner && x.stage === stage;
				});
				if (index < 0) {
					return;
				}
				upgrades.splice(index, 1);
			}
		}

		/**
   * Runs a single version upgrade for a certain type on some data.
   *
   * @param {string} type - the type of data to upgrade
   * @param {any} data - the data to upgrade
   * @param {string} id - the ID of the data being upgraded
   * @returns {Promise} a promise which resolves with the upgraded data
   *                    or rejects if the upgrade or validation fails.
   */

	}, {
		key: '_upgradeVersion',
		value: function _upgradeVersion(type, data, id) {
			var _this2 = this;

			if (!type || !this.types[type]) {
				return Promise.reject(new Error('Upgrade type ' + type + ' is not registered'));
			}
			var version = this.types[type].accessors.getVersion(data);
			var update = this.upgrades[type][version];
			if (!update) {
				return Promise.reject(new Error('No upgrade registered from version ' + version));
			}
			this.logger.debug('Upgrading ' + type + ' ' + id + ' from version ' + version + ' to version ' + update.to);
			// run all upgrades
			return promiseForEach([].concat(_toConsumableArray(update.pre), [update.main], _toConsumableArray(update.post)), function (upgrade, upgradedData) {
				return _this2._runUpgrade(upgradedData, upgrade);
			}, data);
		}

		/**
   * Runs a single upgrade stage for some data
   *
   * @param {any} data - the data to upgrade
   * @param {object} upgrade - the upgrade definition to run on the data.
   * @returns {Promise} a promise which resolves with the upgraded data
   *                    or rejects if the upgrade or validation fails.
   */

	}, {
		key: '_runUpgrade',
		value: function _runUpgrade(data, upgrade) {
			var type = upgrade.type,
			    stage = upgrade.stage,
			    from = upgrade.from,
			    to = upgrade.to,
			    owner = upgrade.owner,
			    id = upgrade.id;

			var validator = this.types[type].validator;
			this.logger.debug('Running ' + type + ' ' + stage + ' upgrade step from version ' + from + ' to version ' + to + ' ([' + owner + '] ' + id + ')');
			if (upgrade.stage === 'main') {
				// set the version to the new version
				this.types[type].accessors.setVersion(data, to);
			}
			var getRejectionPromise = function getRejectionPromise(err) {
				return Promise.reject(errorAndBlame(type + ' upgrade failed', upgrade, err));
			};

			var promise = void 0;
			try {
				// catch anything thrown syncronously
				promise = upgrade.fn(data);
			} catch (err) {
				return getRejectionPromise(err);
			}

			return promise.catch(getRejectionPromise).then(function (upgradedData) {
				if (!validator) {
					return Promise.resolve(upgradedData);
				}
				return validator(upgradedData).catch(function (validationError) {
					return Promise.reject(errorAndBlame(type + ' validation failed after upgrade step', upgrade, validationError));
				}).then(function () {
					return Promise.resolve(upgradedData);
				});
			});
		}
	}]);

	return UpgradeManager;
}();

exports = module.exports = UpgradeManager;