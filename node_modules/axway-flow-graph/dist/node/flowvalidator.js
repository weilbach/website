'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _require = require('./jsonpath'),
    validateJsonPathSelectors = _require.validateJsonPathSelectors,
    validateJsonPathSelector = _require.validateJsonPathSelector;

/**
 * @module axway-flow-graph
 * @typicalname axway-flow-graph
 */

/**
 * Helper for validating flows. The validation checks for:
 * - no cyclical loops
 * - no undefined nodes in the routing
 *
 * @public
 * @class
 */


var FlowValidator = function () {
	/**
 * Create a flow validator.
 * @param {object} flowGraph - a FlowGraph instance
 * @constructor
 */
	function FlowValidator(flowGraph) {
		_classCallCheck(this, FlowValidator);

		this.flowGraph = flowGraph;
		this.index = 0;
	}

	/**
  * Using 'Tarjan's strongly connected components algorithm' to group strongly
  * conencted nodes (loops).
  *
  * @protected
  * @param {object} vertex - The node/vertex to process.
  * @param {array} stack - The stack for vertex processing.
  * @param {array} stronglyConnectedGroups - The resulting list of strongly connected groups.
  */


	_createClass(FlowValidator, [{
		key: '_strongconnect',
		value: function _strongconnect(vertex, stack, stronglyConnectedGroups) {
			var _this = this;

			vertex.info.index = this.index;
			vertex.info.lowlink = this.index;
			this.index += 1;
			stack.push(vertex);
			vertex.info.onStack = true;
			this.flowGraph.getChildren(vertex.id, true).forEach(function (childId) {
				var child = _this.flowGraph.getVertex(childId);
				if (child.info.index === undefined) {
					_this._strongconnect(child, stack, stronglyConnectedGroups);
					vertex.info.lowlink = Math.min(vertex.info.lowlink, child.info.lowlink);
				} else if (child.info.onStack) {
					vertex.info.lowlink = Math.min(vertex.info.lowlink, child.info.lowlink);
				}
			});
			if (vertex.info.lowlink === vertex.info.index) {
				var stronglyConnectedVerts = [];
				if (stack.length > 0) {
					var w = null;
					do {
						w = stack.pop();
						w.info.onStack = false;
						stronglyConnectedVerts.push(w);
					} while (w !== vertex);

					stronglyConnectedGroups.push(stronglyConnectedVerts);
				}
			}
		}

		/**
   * Parses a parameter to a given type.
   *
   * @param {object} param flow node param object
   * @param {string} param.type type of data to parse. Defaults to jsonpaht
   * @param {string} param.value stringified data to be parsed
   * @returns {object} containing error code in 'error' or parsed value in 'data'.
   */

	}, {
		key: '_parseParamValue',
		value: function _parseParamValue(param) {
			// Check the node parameter values match there defined types.
			if (!param.type || param.type === 'jsonpath') {
				if (param.value === undefined) {
					return { error: 'MISSING_VALUE' };
				} else {
					var failures = validateJsonPathSelector(param.value);
					if (failures) {
						return { error: 'INVALID_JSONPATH' };
					}
					return { data: param.value };
				}
			} else {
				var val = void 0;

				try {
					val = JSON.parse(param.value);
				} catch (e) {
					val = undefined;
				}

				var res = void 0;
				if (param.type === 'string' && (val === undefined || typeof val !== 'string')) {
					res = { error: 'INVALID_STRING' };
				} else if (param.type === 'boolean' && (val === undefined || typeof val !== 'boolean')) {
					res = { error: 'INVALID_BOOLEAN' };
				} else if (param.type === 'number' && (val === undefined || typeof val !== 'number')) {
					res = { error: 'INVALID_NUMBER' };
				} else if (param.type === 'array' && (val === undefined || !Array.isArray(val))) {
					res = { error: 'INVALID_ARRAY' };
				} else if (param.type === 'null' && (val === undefined || val !== null)) {
					res = { error: 'INVALID_NULL' };
				} else if (param.type === 'object' && (val === undefined || (typeof val === 'undefined' ? 'undefined' : _typeof(val)) !== 'object' || Array.isArray(val) || val === null)) {
					res = { error: 'INVALID_OBJECT' };
				} else if (val === undefined) {
					res = { error: 'INVALID_TYPE' };
				} else {
					res = { data: val };
				}
				return res;
			}
		}

		/**
   * Adds a validation error to validationData
   * @param {object} validationData - Object containing the validation warnings and errors
   * @param {object} error            - Object containg an error
   */

	}, {
		key: '_addValidationError',
		value: function _addValidationError(validationData, error) {
			validationData.valid = false;
			validationData.errors = validationData.errors || [];
			validationData.errors.push(error);
		}

		/**
   * Adds a validation warning to validationData
   * @param {object} validationData - Object containing the validation warnings and errors
   * @param {object} warning            - Object containg an warning
   */

	}, {
		key: '_addValidationWarning',
		value: function _addValidationWarning(validationData, warning) {
			validationData.warnings = validationData.warnings || [];
			validationData.warnings.push(warning);
		}

		/**
   * Check for any closed loops in the graph.
   * If there are loops loop chains are stored in validationData.errors.flowErrors.loops.
   *
   * @public
   * @param {object} validationData - The object to add the validation errors to.
   * @returns {boolean} true if there are loops detected.
   */

	}, {
		key: 'checkForLoops',
		value: function checkForLoops(validationData) {
			var _this2 = this;

			var invalid = false;
			var stack = [];
			var stronglyConnected = [];
			this.flowGraph.getVertices().forEach(function (vertex) {
				if (vertex.info.index === undefined) {
					_this2._strongconnect(vertex, stack, stronglyConnected);
				}
			});

			var loops = stronglyConnected.filter(function (g) {
				var firstChildId = _this2.flowGraph.getChildren(g[0].id, true)[0];
				var firstChild = firstChildId && _this2.flowGraph.getVertex(firstChildId);
				return g.length > 1 || g.length === 1 && firstChild === g[0];
			});
			this.flowGraph.getVertices().forEach(function (vertex) {
				delete vertex.info.index;
				delete vertex.info.lowlink;
				delete vertex.info.onStack;
			});
			if (loops.length > 0) {
				invalid = true;
				loops.forEach(function (g, i) {
					g.forEach(function (node) {
						_this2._addValidationError(validationData, {
							type: 'loop',
							code: 'INVALID_NODE',
							detail: {
								node: node.id,
								nodes: g.map(function (n) {
									return n.id;
								}),
								loopIndex: i
							}
						});
					});
				});
			}

			return invalid;
		}

		/**
   * Check nodes that have connections to non-existent targets.
  	 * If there are undefined connections the details are are stored in
   * validationData.errors.nodeErrors[nodeId].missingRoutes.
  	 *
  	 * @public
  	 * @param {object} validationData - The object to add the validation errors to.
  	 * @returns {boolean} true if there are missing routes detected.
  	 */

	}, {
		key: 'checkForMissingRoutes',
		value: function checkForMissingRoutes(validationData) {
			var _this3 = this;

			var invalid = false;
			this.flowGraph.getNodes(true).forEach(function (nodeId) {
				var outputs = _this3.flowGraph._getOutputRoutes(nodeId);
				Object.keys(outputs).forEach(function (output) {
					var routes = outputs[output];
					routes.forEach(function (routeId) {
						if (!_this3.flowGraph.getNode(routeId)) {
							invalid = true;
							_this3._addValidationError(validationData, {
								type: 'invalidNodeRoute',
								code: 'INVALID_NODE',
								detail: {
									node: nodeId,
									output: output,
									route: routeId
								}
							});
						}
					});
				});
			});
			return invalid;
		}

		/**
   * Check start to see if it is an invalid type or pointing to a non-existant node.
   * If start is invalid the details are are stored in
   * validationData.errors.flowErrors.invalidStart.
  	 *
  	 * @public
  	 * @param {object} validationData - The object to add the validation errors to.
  	 * @returns {boolean} true if start is invalid.
  	 */

	}, {
		key: 'checkForInvalidStart',
		value: function checkForInvalidStart(validationData) {
			var startNodeId = this.flowGraph.flow.start;
			if (!startNodeId || typeof startNodeId !== 'string' || !this.flowGraph.getNode(startNodeId)) {
				this._addValidationError(validationData, {
					type: 'invalidStart',
					code: 'INVALID_NODE'
				});
				return true;
			}
			return false;
		}

		/**
   * Check that the flow node output contexts are valid JSONPath selectors.
  	 * If output contexts are invalid, the details are are stored in
   * validationData.errors.nodeErrors[nodeId].invalidOuputContext.
  	 *
  	 * @public
  	 * @param {object} validationData - The object to add the validation errors to.
  	 * @returns {boolean} true if there are invalid ouput contexts detected.
  	 */

	}, {
		key: 'checkNodeOutputContext',
		value: function checkNodeOutputContext(validationData) {
			var _this4 = this;

			var invalid = false;
			this.flowGraph.getNodes(true).forEach(function (nodeId) {
				var node = _this4.flowGraph.getNode(nodeId);
				// Node output context targets must be valid selectors
				Object.keys(node.outputs).forEach(function (output) {
					var outputContext = node.outputs[output].context;
					if (outputContext) {
						var err = validateJsonPathSelector(outputContext);
						if (err) {
							invalid = true;
							_this4._addValidationError(validationData, {
								type: 'invalidNodeOutput',
								code: 'INVALID_JSONPATH',
								detail: {
									error: err.error,
									node: nodeId,
									output: output
								}
							});
						}
					}
				});
			});

			return invalid;
		}

		/**
   * Check that `returns` has valid JSONPath selectors.
   * If there are undefined connections the details are are stored in
   * validationData.errors.flowErrors.invalidReturns.
   *
   * @public
   * @param {object} validationData - The object to add the validation errors to.
   * @returns {boolean} true if there are invalid nodes detected.
   */

	}, {
		key: 'checkReturns',
		value: function checkReturns(validationData) {
			var _this5 = this;

			var returns = this.flowGraph.flow.returns;
			if (returns === undefined || returns === null) {
				return false;
			}

			var errs = validateJsonPathSelectors(returns);
			if (errs) {
				errs.forEach(function (err) {
					_this5._addValidationError(validationData, {
						type: 'invalidReturns',
						code: 'INVALID_JSONPATH',
						detail: {
							error: err.error
						}
					});
				});
				return true;
			}
			return false;
		}

		/**
   * Run checks on the flow and report validation errors as they are found.
   * @public
   * @returns {object} the validation report
  	 */

	}, {
		key: 'validate',
		value: function validate() {
			var validationData = { valid: true };
			this.checkForInvalidStart(validationData);
			this.checkForMissingRoutes(validationData);
			this.checkForLoops(validationData);
			this.checkNodeOutputContext(validationData);
			this.checkReturns(validationData);
			return validationData;
		}
	}]);

	return FlowValidator;
}();

exports = module.exports = FlowValidator;