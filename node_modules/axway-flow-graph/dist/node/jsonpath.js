'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var Parser = require('jsonpath/lib/parser');

var parser = new Parser();

/**
 * @module axway-flow-graph
 * @typicalname axway-flow-graph
 */

/**
 * Validates a JSONPath selector
 * @param {string} path - JSONPath selector to validate
 * @returns {object} - Validation error only if the selector is not valid
 */
var validateJsonPathSelector = function validateJsonPathSelector(path) {
	if (path === null || path === undefined || path === '$') {
		return null;
	}

	if (typeof path !== 'string') {
		return {
			jsonpath: path,
			error: 'Provided JSONPath is not a string'
		};
	}

	// Parser will say that 'foo'is a valid jsonpath. it is valid in this library.
	// '$foo' is invalid for some reason, so we can't test for '$.'.
	// test the beginning of the string first.
	if (!path.startsWith('$')) {
		return {
			jsonpath: path,
			error: 'Provided JSONPath does not start with \'$\''
		};
	}

	try {
		parser.parse(path);
	} catch (ex) {
		return {
			jsonpath: path,
			error: ex.message || ex.toString()
		};
	}
	return null;
};

/**
 * Validate all selectors contained in the value.
 * @param {string|object} val - a JSONPath selector - or -
 *                              an object containing JSONPath selectors as values
 * @param {array} pos - array containing a breakdown of the path followed in validation
 *                       to help locate invalid selectors.
 * @returns {array} any errors which were found when validating the selectors
 */
var validateJsonPathSelectors = function validateJsonPathSelectors(val) {
	var pos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

	var errors = null;
	if (typeof val === 'string' && val.startsWith('$')) {
		var curErr = validateJsonPathSelector(val);
		if (curErr) {
			errors = errors ? [curErr].concat(_toConsumableArray(errors)) : [curErr];
		}
	} else if (val && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object') {
		Object.keys(val).forEach(function (key) {
			var curErrs = validateJsonPathSelectors(val[key], [].concat(_toConsumableArray(pos), [key]));
			if (curErrs) {
				errors = errors ? [].concat(_toConsumableArray(curErrs), _toConsumableArray(errors)) : curErrs;
			}
		});
	}
	return errors;
};

exports = module.exports = {
	validateJsonPathSelectors: validateJsonPathSelectors,
	validateJsonPathSelector: validateJsonPathSelector
};