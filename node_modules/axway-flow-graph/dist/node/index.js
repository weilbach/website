'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var FlowValidator = require('./flowvalidator');

/**
 * @module axway-flow-graph
 * @typicalname axway-flow-graph
 */

/**
 * Converts an object into an array of keys or values
 *
 * @param {object} object - the object to convert into an array
 * @param {function|bool} map - if true, return all the keys of the object
 *                              if false, return all the values of the object
 *                              if function, map object keys to array values.
 * @returns {string[]|array} an array of values based on the map.
 */
var objectToArray = function objectToArray(object, map) {
	var keys = Object.keys(object);
	return map === true ? keys : keys.map(map || function (key) {
		return object[key];
	});
};

/**
 * FlowGraph object
 *
 * @class FlowGraph
 */

var FlowGraph = function () {
	/**
  * Creates an instance of FlowGraph.
  * @constructor
  * @param {string} flowId - The id of this flow.
  * @param {object} flowdef - The flow definition.
  */
	function FlowGraph(flowId, flowdef) {
		_classCallCheck(this, FlowGraph);

		this.id = flowId;
		if (typeof flowdef === 'string') {
			this.flow = JSON.parse(flowdef);
		} else {
			this.flow = JSON.parse(JSON.stringify(flowdef));
		}
		this.flow.name = this.flow.name || this.id;
		this.registerValidator(FlowValidator);
		this._buildGraph();
		this._onChange();
	}

	/**
  * Ensures that a vertex will exist
  *
  * @param {string} vertexId - the ID of the vertex
  * @param {object} info - info to be set on the vertex. If vertex already exists, the info will
                     be merged with the existing info.
  * @returns {object} the vertex which matched or was created.
  * @protected
  */


	_createClass(FlowGraph, [{
		key: '_ensureVertex',
		value: function _ensureVertex(vertexId, info) {
			var vertices = this.graph.vertices;
			var vertex = vertices[vertexId];
			if (!vertex) {
				vertices[vertexId] = {
					id: vertexId,
					children: Object.create(null),
					parents: Object.create(null),
					info: _extends({
						terminal: false
					}, info || Object.create(null))
				};
			} else if (info) {
				// if node already exists we still want to update the info
				vertex.info = _extends({}, vertex.info, info || Object.create(null));
			}
			return vertices[vertexId];
		}

		/**
   * Deletes a vertex from the graph
   *
   * @param {string} vertexId - the id of the vertex to delete
   * @protected
   */

	}, {
		key: '_deleteVertex',
		value: function _deleteVertex(vertexId) {
			delete this.graph.vertices[vertexId];
		}

		/**
   * Gets the children of a vertex in the flow
   *
   * @param {string} vertexId - the Id of the vertex to get children for.
   * @param {string} output - the vetex output to get the children for.
   * @param {bool} [idsOnly] - if the vertex idsOnly should be returned rather than the vertices
   * @returns {string[]|object[]} the child vertices of a vertex in the flow
   */

	}, {
		key: '_getVertexChildren',
		value: function _getVertexChildren(vertexId, output, idsOnly) {
			var _this = this;

			return objectToArray(this.graph.vertices[vertexId].children[output], idsOnly || function (childId) {
				return _this.getVertex(childId);
			});
		}

		/**
   * Gets the parents of a vertex in the flow
   *
   * @param {string} vertexId - the Id of the vertex to get parents for.
   * @param {bool} [idsOnly] - if the vertex ids should be returned rather than the vertices
   * @returns {string[]|object[]} the parent nodes of a vertex in the flow
   */

	}, {
		key: '_getVertexParents',
		value: function _getVertexParents(vertexId, idsOnly) {
			var _this2 = this;

			return objectToArray(this.graph.vertices[vertexId].parents, idsOnly || function (parentId) {
				return _this2.getVertex(parentId);
			});
		}

		/**
   * Ensures that an edge will exist between any two vertices. If any of the vertices do not exist,
   * they will be created.
   *
   * @param {string} output - the vertex output group the edge belongs to.
   * @param {string} fromId - the ID of the vertex where the edge starts
   * @param {string} toId - this ID of the vertex where the edge ends
   * @returns {object} the edge which matched or was created.
   * @protected
   */

	}, {
		key: '_ensureEdge',
		value: function _ensureEdge(output, fromId, toId) {
			var edge = this.getEdge(output, fromId, toId);
			if (edge) {
				return edge;
			}
			edge = {
				output: output,
				to: toId,
				from: fromId
			};
			var vFrom = this._ensureVertex(fromId);
			var vTo = this._ensureVertex(toId);
			this.graph.edges.push(edge);
			vFrom.children[output] = vFrom.children[output] || Object.create(null);
			vFrom.children[output][toId] = true;
			vTo.parents[fromId] = true;
			return edge;
		}

		/**
   * Deletes an edge from one node to another.
   * Removes the parent/child where necesarry from each vertex.
   *
   * @param {string} fromId - the vertex where the edge starts
   * @param {string} output - the vertex output group the edge belongs to.
   * @param {string} toId - the vertex where the edge ends
   * @protected
   */

	}, {
		key: '_deleteEdge',
		value: function _deleteEdge(fromId, output, toId) {
			this.graph.edges = this.graph.edges.filter(function (edge) {
				return !(edge.output === output && edge.to === toId && edge.from === fromId);
			});
			// delete parent
			var toVertex = this.getVertex(toId);
			if (toVertex) {
				delete toVertex.parents[fromId];
			}
			// delete child
			var fromVertex = this.getVertex(fromId);
			if (fromVertex) {
				delete fromVertex.children[output][toId];
			}
			// check the children and see if it is empty, if so, delete the output, e.g.
			// "success" of: {"success": {}}
			if (!Object.keys(fromVertex.children[output]).length) {
				delete fromVertex.children[output];
			}
			// check children and if empty, the node is terminal
			if (!Object.keys(fromVertex.children).length) {
				fromVertex.info.terminal = true;
			}
		}

		/**
   * Deletes the edges from one node to another (across all outputs).
   * Removes the parent/child where necesarry from each vertex.
   *
   * @param {string} fromId - the vertex where the edge starts
   * @param {string} toId - the vertex where the edge ends
   * @protected
   */

	}, {
		key: '_deleteEdges',
		value: function _deleteEdges(fromId, toId) {
			this.graph.edges = this.graph.edges.filter(function (edge) {
				return !(edge.to === toId && edge.from === fromId);
			});

			// Remove this node as parent of it's children
			var toVertex = this.getVertex(toId);
			if (toVertex) {
				delete toVertex.parents[fromId];
			}

			// Remove this node as child of it's parents
			var fromVertex = this.getVertex(fromId);
			if (fromVertex) {
				Object.keys(fromVertex.children).forEach(function (output) {
					delete fromVertex.children[output][toId];
				});
			}
		}
	}, {
		key: '_deleteOutput',
		value: function _deleteOutput(nodeId, output) {
			var _this3 = this;

			var node = this.getNode(nodeId);
			if (!node) {
				throw new Error('Node ' + nodeId + ' does not exist');
			}
			var nodeOutput = node.outputs[output];
			if (!nodeOutput) {
				throw new Error('Output ' + output + ' does not exist on node ' + nodeId);
			}

			// unroute
			var outputRoutes = nodeOutput.routes;
			if (outputRoutes) {
				outputRoutes.forEach(function (route) {
					_this3.deleteRoute(output, nodeId, route);
				});
			}
			delete node.outputs[output];
		}

		/**
   * Sets the validation state on the flow definition
   *
   * @param {object} validation - the validation state
   * @protected
   */

	}, {
		key: '_setValidation',
		value: function _setValidation(validation) {
			this.flow['x-validation'] = validation;
		}

		/**
   * Gets a list of all nodes which a node may route to grouped by output.
   *
   * @param {string} nodeId - the ID of a node to get routes for
   * @returns {object} A map of IDs for routes from the node specified grouped by output.
   * @protected
   */

	}, {
		key: '_getOutputRoutes',
		value: function _getOutputRoutes(nodeId) {
			var node = this.flow.nodes[nodeId];
			if (!node) {
				return null;
			}

			var outputRoutes = Object.keys(node.outputs).reduce(function (col, cur) {
				var output = node.outputs[cur];
				if (output.routes && output.routes.length > 0) {
					col[cur] = output.routes;
				} else {
					col[cur] = [];
				}
				return col;
			}, Object.create(null));

			return outputRoutes;
		}

		/**
   * Generates a unique symbol of the flow. Should be called whenever the flow changes.
   */

	}, {
		key: '_onChange',
		value: function _onChange() {
			this.symbol = Symbol(this.id);
		}

		/**
   * Build a graph from the flow definition.
   *
   * @protected
   */

	}, {
		key: '_buildGraph',
		value: function _buildGraph() {
			var _this4 = this;

			// Process the nodes in the graph to determine parential dependencies and
			// nodes that terminate the flow.
			this.graph = {
				vertices: Object.create(null),
				edges: []
			};
			Object.keys(this.flow.nodes).forEach(function (nodeId) {
				_this4._buildVertex(nodeId);
			});
		}

		/**
   * Builds a vertex for a nodeId
   * @param {string} nodeId - The nodeId from which to build a vertex.
   */

	}, {
		key: '_buildVertex',
		value: function _buildVertex(nodeId) {
			var _this5 = this;

			if (!this.flow.nodes[nodeId].name) {
				this.flow.nodes[nodeId].name = nodeId;
			}
			var outputRoutes = this._getOutputRoutes(nodeId);
			// This vertex is terminal if there are no outputs or if any of the
			// outputs have no routes.
			if (outputRoutes === null || !Object.keys(outputRoutes).length) {
				this._ensureVertex(nodeId, {
					terminal: true
				});
			} else {
				Object.keys(outputRoutes).forEach(function (outputName) {
					var routes = outputRoutes[outputName];
					if (!routes || !routes.length) {
						_this5._ensureVertex(nodeId, {
							terminal: true
						});
					} else {
						routes.forEach(function (route) {
							_this5._ensureEdge(outputName, nodeId, route);
						});
					}
				});
			}
		}

		/**
   * Sets the name of a node
   * @param  {string} nodeId - Node ID
   * @param  {string} name   - New node name
   */

	}, {
		key: 'changeNodeName',
		value: function changeNodeName(nodeId, name) {
			var source = this.getNodeUnsafe(nodeId);
			source.name = name;
		}

		/**
   * Modifies the method of a node to match a new spec
   * @param {string} nodeId - The id of the node to update.
   * @param {string} method - the method to use
   * @param {object} nodehandler - the node handler in use
   */

	}, {
		key: 'changeMethod',
		value: function changeMethod(nodeId, method, nodehandler) {
			var _this6 = this;

			var source = this.getNodeUnsafe(nodeId);
			// remove all parameters from the node
			for (var i = source.parameters.length - 1; i >= 0; i--) {
				this._removeParameter(nodeId, i);
			}

			var spec = nodehandler && nodehandler.methods[method];
			if (!spec) {
				throw new Error('method ' + method + ' does not exist in provided flow-node');
			}

			// Build new outputs
			var specOutputs = spec.outputs || {};

			// loop over the existing outputs
			Object.keys(source.outputs).forEach(function (outputName) {
				if (!specOutputs[outputName]) {
					// delete the output (and all it's routes / edges) if it doesn't exit in the new spec
					_this6._deleteOutput(nodeId, outputName);
				}
			});

			// add/update the outputs
			Object.keys(specOutputs).forEach(function (outputName) {
				var specOutput = specOutputs[outputName];
				var newOutput = _extends({
					routes: []
				}, source.outputs[outputName] || {});
				// Port over context from the spec if it's different to anything that exists
				if (specOutput.context && specOutput.context !== newOutput.context) {
					newOutput.context = specOutput.context;
				}
				source.outputs[outputName] = newOutput;
			});

			// Change node name
			// Only if the current name is the node ID or is the default node name (i.e. method name),
			var nodeMethodName = source.method && nodehandler && nodehandler.methods[source.method] && nodehandler.methods[source.method].name || source.method;
			if (source.name === nodeId || source.name === nodeMethodName) {
				source.name = spec.name || method;
			}

			// set the new method
			source.method = method;
			this._onChange();
		}

		/**
   * Inserts a node into the flow graph.
   * @param {object} node - The node to insert.
   * @param {string} nodeId - The id of the node to insert.
   *  If supplied, it must be unique.
   *  If not supplied, the node id will be generated.
   * @returns {string} - the inserted nodeId
   */

	}, {
		key: 'insertNode',
		value: function insertNode(node, nodeId) {
			if (nodeId) {
				var exists = this.getNode(nodeId);
				if (exists) {
					// Internally, something bad happened
					throw new Error('a node with that id already exists: ' + nodeId);
				}
			} else {
				// generate a nodeId from the type.
				var type = node.type.substr(node.type.lastIndexOf('/') + 1);
				var _exists = void 0;
				var i = 1;
				do {
					nodeId = type + '.' + i;
					_exists = this.getNode(nodeId);
					i += 1;
				} while (_exists);
			}

			if (this.isEmpty()) {
				// if the flow is empty, automatically set the start
				this.flow.start = nodeId;
			}
			this.flow.nodes[nodeId] = node;

			this._buildVertex(nodeId);

			this._onChange();

			return nodeId;
		}

		/**
   * Delete a specific node from the flow.
   *
   * @param {string} nodeId - the id of the node to delete
   */

	}, {
		key: 'deleteNode',
		value: function deleteNode(nodeId) {
			var _this7 = this;

			var node = this.getNode(nodeId);
			if (!node) {
				return;
			}

			// Get the default output of the node. It's children become the children of the parent.
			var parents = this.getParents(nodeId, true);
			var children = this.getChildren(nodeId, true);

			parents.forEach(function (parentId) {
				_this7.deleteRoutes(parentId, nodeId);
			});
			children.forEach(function (childId) {
				_this7.deleteRoutes(nodeId, childId);
			});

			if (this.flow.start === nodeId) {
				this.flow.start = null;
			}

			this._deleteVertex(nodeId);
			delete this.flow.nodes[nodeId];

			this._onChange();
		}

		/**
   * Delete the output route from one node to another.
   *
   * @param {string} output - the output to delete the route for.
   * @param {string} fromId - the node id the routes are being deleted from.
   * @param {string} toId - the node id being removed from the routes.
   */

	}, {
		key: 'deleteRoute',
		value: function deleteRoute(output, fromId, toId) {
			// Delete the edges
			this._deleteEdge(fromId, output, toId);

			// Update the flow
			var node = this.getNode(fromId);
			if (!node) {
				return;
			}

			if (node.outputs && node.outputs[output]) {
				if (node.outputs[output].routes && node.outputs[output].routes.length) {
					node.outputs[output].routes = node.outputs[output].routes.filter(function (route) {
						return route !== toId;
					});
				}
			}
		}

		/**
   * Delete all the output routes from one node to another.
   *
   * @param {string} fromId - the node id the routes are being deleted from.
   * @param {string} toId - the node id being removed from the routes.
   */

	}, {
		key: 'deleteRoutes',
		value: function deleteRoutes(fromId, toId) {
			// Delete the edges
			this._deleteEdges(fromId, toId);

			// Update the flow
			var node = this.getNode(fromId);
			if (!node) {
				return;
			}

			if (node.outputs && Object.keys(node.outputs).length > 0) {
				Object.keys(node.outputs).forEach(function (output) {
					if (node.outputs[output].routes && node.outputs[output].routes.length) {
						node.outputs[output].routes = node.outputs[output].routes.filter(function (route) {
							return route !== toId;
						});
					}
				});
			}
		}

		/**
   * Sets a node as the start node for the flow.
   * @param {string} nodeId - The start node for the flow.
   */

	}, {
		key: 'setStart',
		value: function setStart(nodeId) {
			var source = this.getNode(nodeId);
			if (!source) {
				throw new Error('start node not found: ' + nodeId);
			}

			if (this.flow.start !== nodeId) {
				this.flow.start = nodeId;
				this._onChange();
			}
		}

		/**
   * Clears the start node for the flow.  This action will make the flow invalid.
   */

	}, {
		key: 'unsetStart',
		value: function unsetStart() {
			this.flow.start = null;
			this._onChange();
		}

		/**
   * Adds a parameter to a node in the flow
   * @param {string} nodeId - the node id
   * @param {string} name - the name of the parameter
   * @param {string} value - the value of the parameter
   * @param {string} [type=jsonpath] - the type of the parameter.
   */

	}, {
		key: 'addParameter',
		value: function addParameter(nodeId, name, value) {
			var type = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'jsonpath';

			var source = this.getNodeUnsafe(nodeId);
			if (!name) {
				throw new Error('parameter name required');
			}
			if (this._getParameterIndex(nodeId, name) !== -1) {
				throw new Error('parameter already exists');
			}
			if (typeof value !== 'string' && value !== undefined) {
				throw new Error('value is not a string');
			}
			if (!['jsonpath', 'array', 'null', 'object', 'string', 'number', 'boolean'].includes(type)) {
				throw new Error('invalid type');
			}
			source.parameters.push({
				name: name,
				type: type,
				value: value
			});
			this._onChange();
		}

		/**
   * Updates a parameter from a node in the flow
   * @param {string} nodeId - the node id
   * @param {string} name - the current name of the parameter
   * @param {string|object} prop - the field to update (name|type|value) if string,
   *                               or the new value of the parameter
   * @param {string} newValue - the new value of the prop specified if it is a string
   */

	}, {
		key: 'updateParameter',
		value: function updateParameter(nodeId, name, prop, newValue) {
			var index = this._getParameterIndex(nodeId, name);
			var oldParam = void 0;
			if (index !== -1) {
				oldParam = this._removeParameter(nodeId, index);
			} else {
				oldParam = { name: name };
			}

			var newParameter = void 0;
			if (typeof prop === 'string') {
				if (!['type', 'name', 'value'].includes(prop)) {
					throw new Error('prop must be one of type, name, or value');
				}
				newParameter = _extends({}, oldParam, _defineProperty({}, prop, newValue));
			} else if (!prop || prop.constructor !== Object) {
				throw new Error('prop must be a string or an object');
			} else {
				newParameter = prop;
			}
			this.addParameter(nodeId, newParameter.name, newParameter.value, newParameter.type);
		}
	}, {
		key: '_getParameter',
		value: function _getParameter(nodeId, name) {
			var index = this._getParameterIndex(nodeId, name);
			if (index === -1) {
				throw new Error('parameter ' + name + ' does not exist in node ' + nodeId);
			}
			return this.getNode(nodeId).parameters[index];
		}
	}, {
		key: '_getParameterIndex',
		value: function _getParameterIndex(nodeId, name) {
			var node = this.getNodeUnsafe(nodeId);
			return node.parameters.findIndex(function (param) {
				return param.name === name;
			});
		}

		/**
   * Removes a parameter by index from a node in the flow
   * @param {string} nodeId - the node id
   * @param {number} index - the index of the parameter
   * @returns {object} the parameter that was removed
   */

	}, {
		key: '_removeParameter',
		value: function _removeParameter(nodeId, index) {
			var source = this.getNodeUnsafe(nodeId);
			if (typeof index !== 'number') {
				throw new Error('parameter index must be a number');
			}

			if (index >= source.parameters.length || index < 0) {
				throw new Error('parameter with index ' + index + ' does not exist in node ' + nodeId);
			}

			var removed = source.parameters.splice(index, 1);
			return removed[0];
		}

		/**
   * Removes a parameter by name from a node in the flow
   * @param {string} nodeId - the node id
   * @param {string} name - the name of the parameter
   * @returns {object} the parameter that was removed
   */

	}, {
		key: 'removeParameter',
		value: function removeParameter(nodeId, name) {
			if (!name) {
				throw new Error('parameter name required');
			}
			var index = this._getParameterIndex(nodeId, name);
			if (index === -1) {
				throw new Error('parameter ' + name + ' does not exist in node ' + nodeId);
			}
			var param = this._removeParameter(nodeId, index);
			this._onChange();
			return param;
		}

		/**
   * Modifies the JSONPath context of an output
   * @param {string} nodeId - the node id
   * @param {string} name - the name of the output
   * @param {string} value - the new JSONPath context
   */

	}, {
		key: 'updateOutputContext',
		value: function updateOutputContext(nodeId, name, value) {
			var source = this.getNodeUnsafe(nodeId);
			if (!name) {
				throw new Error('output name required');
			}
			var output = source.outputs[name];
			if (!output) {
				throw new Error('output ' + name + ' does not exist');
			}
			output.context = value;
			this._onChange();
		}

		/**
   * Connects a node output to the specified target.
   * @param {string} sourceId - The source node for the connection.
   * @param {string} sourceOutput - The output in the source node for the connection.
   * @param {string} targetId - The id of the target node to connect to.
   */

	}, {
		key: 'connectNode',
		value: function connectNode(sourceId, sourceOutput, targetId) {
			var source = this.getNode(sourceId);
			if (!source) {
				throw new Error('source node not found: ' + sourceId);
			} else if (!source.outputs[sourceOutput]) {
				throw new Error('source output not found: ' + sourceOutput);
			}

			var target = this.getNode(targetId);
			if (!target) {
				throw new Error('target node not found: ' + targetId);
			}

			if (this.flow.nodes[sourceId].outputs[sourceOutput].routes && this.flow.nodes[sourceId].outputs[sourceOutput].routes.indexOf(targetId) !== -1) {
				throw new Error('route already exists: ' + sourceId + ':' + sourceOutput + ' to ' + targetId);
			}

			// Update the flow def
			this.flow.nodes[sourceId].outputs[sourceOutput] = _extends({}, this.flow.nodes[sourceId].outputs[sourceOutput], {
				routes: [].concat(_toConsumableArray(this.flow.nodes[sourceId].outputs[sourceOutput].routes || []), [targetId])
			});

			this._ensureEdge(sourceOutput, sourceId, targetId);
			this._onChange();
		}

		/**
   * Disconnects a target node from a parent node's source and output.
   * @param {string} sourceId - The source node for the connection.
   * @param {string} sourceOutput - The output in the source node for the connection.
   * @param {string} targetId - The id of the target node to connect to.
   */

	}, {
		key: 'disconnectNode',
		value: function disconnectNode(sourceId, sourceOutput, targetId) {
			this.deleteRoute(sourceOutput, sourceId, targetId);
			this._onChange();
		}

		/**
   * Indicates if the flow is empty, with no nodes.
   * @returns {boolean} `true` if the flow is empty.
   */

	}, {
		key: 'isEmpty',
		value: function isEmpty() {
			return !Object.keys(this.flow.nodes).length;
		}

		/**
   * Get the unique symbol of the flow
   *
   * @returns {symbol} the flow symbol
   */

	}, {
		key: 'getSymbol',
		value: function getSymbol() {
			return this.symbol;
		}

		/**
   * Gets the definition of the flow
   * @returns {object} the flow definition
   */

	}, {
		key: 'getDefinition',
		value: function getDefinition() {
			return this.flow;
		}

		/**
   * Gets the graph representation of the flow
   * @returns {object} the flow graph representation
   */

	}, {
		key: 'getGraph',
		value: function getGraph() {
			return this.graph;
		}

		/**
   * Gets the Id of the flow
   * @returns {string} the flow id
   */

	}, {
		key: 'getId',
		value: function getId() {
			return this.id;
		}

		/**
   * Gets the edges of the flow graph
   * @returns {object[]} the edges of the graph
   */

	}, {
		key: 'getEdges',
		value: function getEdges() {
			return this.graph.edges;
		}

		/**
   * Get the edge between two nodes.
   *
   * @param {string} output - the node output the edges belong to.
   * @param {string} fromId - the ID of the vertex where the edge starts
   * @param {string} toId - this ID of the vertex where the edge ends
   * @returns {object|null} the edge between two nodes. Null if no edge exists.
   */

	}, {
		key: 'getEdge',
		value: function getEdge(output, fromId, toId) {
			if (this.graph.vertices[fromId] && this.graph.vertices[fromId].children[output] && this.graph.vertices[fromId].children[output][toId]) {
				return {
					output: output,
					to: toId,
					from: fromId
				};
			}
			return null;
		}

		/**
   * Gets the vertices of the graph
   *
   * @param {bool} [idsOnly] - if the vertex ids should be returned rather than the vertices
   * @returns {string[]|object[]} the vertices of the graph
   */

	}, {
		key: 'getVertices',
		value: function getVertices(idsOnly) {
			return objectToArray(this.graph.vertices, idsOnly);
		}

		/**
   * Gets the nodes of the flow
   *
   * @param {bool} [idsOnly] - if the node ids should be returned rather than the nodes
   * @returns {string[]|object[]} the nodes of the flow
   */

	}, {
		key: 'getNodes',
		value: function getNodes(idsOnly) {
			var _this8 = this;

			return objectToArray(this.flow.nodes, idsOnly || function (nodeId) {
				return _this8.getNode(nodeId);
			});
		}

		/**
   * Gets the children of a node in the flow
   *
   * @param {string} nodeId - the Id of the node to get children for.
   * @param {string} output - the node output to get the children for.
   *                          If omitted then all children are returned.
   * @param {bool} [idsOnly] - if the node idsOnly should be returned rather than the nodes
   * @returns {string[]|object[]} the child nodes of a node in the flow
   */

	}, {
		key: 'getChildren',
		value: function getChildren(nodeId, output, idsOnly) {
			var _this9 = this;

			var verts = void 0;
			if (arguments.length <= 2 && typeof output !== 'string') {
				idsOnly = output || false;
				verts = Object.keys(this.graph.vertices[nodeId].children).reduce(function (col, cur) {
					var outputChildren = _this9.graph.vertices[nodeId].children[cur];
					col = Object.assign(col, outputChildren);
					return col;
				}, {});
			} else {
				verts = this.graph.vertices[nodeId].children[output];
			}

			return objectToArray(verts, idsOnly || function (childId) {
				return _this9.getNode(childId);
			});
		}

		/**
   * Gets the parents of a node in the flow
   *
   * @param {string} nodeId - the Id of the node to get parents for.
   * @param {bool} [idsOnly] - if the node ids should be returned rather than the nodes
   * @returns {string[]|object[]} the parent nodes of a node in the flow
   */

	}, {
		key: 'getParents',
		value: function getParents(nodeId, idsOnly) {
			var _this10 = this;

			return objectToArray(this.graph.vertices[nodeId].parents, idsOnly || function (parentId) {
				return _this10.getNode(parentId);
			});
		}

		/**
   * Gets the terminal nodes of the flow
   *
   * @param {bool} [idsOnly] - if the node ids should be returned rather than the nodes
   * @returns {string[]|object[]} the terminal nodes of the flow
   */

	}, {
		key: 'getTerminalNodes',
		value: function getTerminalNodes(idsOnly) {
			var _this11 = this;

			return this.getVertices().filter(function (vertex) {
				return vertex && vertex.info.terminal;
			}).map(function (vertex) {
				return idsOnly ? vertex.id : _this11.getNode(vertex.id);
			});
		}

		/**
   * Get the vertex which matches the ID specified
   *
   * @param {string} vertexId - the ID of the vertex to return
   * @returns {object} a vertex in the graph
   */

	}, {
		key: 'getVertex',
		value: function getVertex(vertexId) {
			return this.graph.vertices[vertexId] || null;
		}

		/**
   * Get the node which matches the ID specified
   *
   * @param {string} nodeId - the ID of the node to return
   * @returns {object|null} a node in the flow, or null
   */

	}, {
		key: 'getNode',
		value: function getNode(nodeId) {
			return this.flow.nodes[nodeId] || null;
		}

		/**
   * Get the node which matches the ID specified and will throw an error if node was not found.
   * Call this if you expect the node to exist
   *
   * @param {string} nodeId - the ID of the node to return
   * @returns {object} a node in the flow
   */

	}, {
		key: 'getNodeUnsafe',
		value: function getNodeUnsafe(nodeId) {
			var node = this.flow.nodes[nodeId];
			if (!node) {
				throw new Error('node not found: ' + nodeId);
			}
			return node;
		}

		/**
   * Get the validation state of the flow
   *
   * @returns {object} the validation state of the flow
   */

	}, {
		key: 'getValidation',
		value: function getValidation() {
			return this.flow['x-validation'] || Object.create(null);
		}

		/**
   * Registers a FlowValidator type class to the flow. When validation is run, this class will
   * be used to validate the flow.
   *
   * @param {FlowValidator} validator - A class which is a FlowValidator
   */

	}, {
		key: 'registerValidator',
		value: function registerValidator(validator) {
			this.FlowValidator = validator;
		}

		/**
   * Validate the flow - check all the nodes, no cycles, syntax, etc.
   * Update the definition to make validation report available to clients
   * @returns {object} the validation state
   */

	}, {
		key: 'validate',
		value: function validate() {
			var validation = new this.FlowValidator(this).validate();
			this._setValidation(validation);
			return validation;
		}
	}]);

	return FlowGraph;
}();

FlowGraph.Validator = FlowValidator;

exports = module.exports = FlowGraph;