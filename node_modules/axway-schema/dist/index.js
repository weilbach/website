'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @module axway-schema
 * @typicalname axway-schema
 * @exports axway-schema
 *
 * @example <caption>Quick start</caption>
 * ```javascript
 *  const schemas = require('axway-schema');
 *  schemas.add('./schemas/foo.json')
 *	  .add('./schemas/bar.json', 'schema://myproject/bar')
 *	  .add('./schemas/swagger-v2.0.json')
 *	  .loadSync();
 *  schemas.get('schema:///foo');
 *  schemas.validate('schema:///foo', foo);
 *  schemas.get('schema:///foo/myproject/bar');
 *  schemas.validate('schema:///foo/myproject/bar', bar);
 *  schemas.get('http://swagger.io/v2/schema.json#');
 *  schemas.validate('http://swagger.io/v2/schema.json#', swagger);
 *  schemas.dereference(swagger);
 *  schemas.dereference(swagger, { target: '#/definitions' });
 *  schemas.dereference(swagger, { target: '#/definitions', rename: (id) => { return 'foo'; } });
 * ```
 */
var fs = require('fs');
var path = require('path');
var Ajv = require('ajv');
var jsonpointer = require('json-pointer');
var jsonrefs = require('json-refs');
var URI = require('uri-js');
var draft04schema = require('ajv/lib/refs/json-schema-draft-04.json');

var MAX_RECURSION_DEPTH = 10;

/**
 * @private
 */

var Singleton = function () {
	function Singleton() {
		_classCallCheck(this, Singleton);
	}

	_createClass(Singleton, null, [{
		key: 'declare',
		value: function declare(key, Clazz) {
			var globalSymbols = Object.getOwnPropertySymbols(global);
			var symbol = Symbol.for(key);
			var exists = globalSymbols.indexOf(symbol) > -1;
			// no dupes
			if (!exists) {
				global[symbol] = new Clazz();
			}
			Object.defineProperty(Clazz, 'instance', {
				get: function get() {
					return global[symbol];
				}
			});
			Object.freeze(Clazz);
		}
	}, {
		key: 'get',
		value: function get(key) {
			var globalSymbols = Object.getOwnPropertySymbols(global);
			var symbol = Symbol.for(key);
			var exists = globalSymbols.indexOf(symbol) > -1;
			// no dupes
			if (!exists) {
				throw new Error('failed to find singleton: ' + key);
			}
			return global[symbol];
		}
	}]);

	return Singleton;
}();

/**
 * A schema manager.
 * @public
 * @class
 */


var AxwaySchema = function () {
	/**
  * Constructs a schema manager.  The instance is a singleton.
  * @public
  */
	function AxwaySchema() {
		_classCallCheck(this, AxwaySchema);

		this.scheme = 'schema://';
		this.global = [];
		this.clear();
	}

	/**
  * Sets the Logger
  * @param {Logger} logger - A logger.
  * @public
  */


	_createClass(AxwaySchema, [{
		key: 'setLogger',
		value: function setLogger(logger) {
			this.logger = logger;
		}

		/**
   * Adds an item to be loaded later by calling
   * [loadSync]{@link #module_axway-schema..AxwaySchema+loadSync}.
   * The `item` can be a `string`, in which case it is a schema file, and an optional `defaultId`
   * will be used for the `id` if the file does not have an `id`.  If the file does not have an
   * `id` and no `defaultId` is supplied, the function will throw.
   *
   * If the `item` is an object, it is a valid schema that has an `id` defined so that
   * it can be referenced later.  In this case, `defaultId` is ignored.
   *
   * @example <caption>Add a schema</caption>
   * ```javascript
   *  const schemas = new AxwaySchema();
   *  schemas.add('./schema1.json');
   *  schemas.add('./schema2.json', 'schema://project/myapp/schema2.json');
   *  schemas.add({id: 'http://axway.com/schemas/user.json'});
   * ```
   *
   * @param {string|object} item - The item to add (a filename or schema).
   * @param {string} [defaultId] - The item id if one not supplied.
   * @return {AxwaySchema} The {@link AxwaySchema} object.
   * @public
   */

	}, {
		key: 'add',
		value: function add(item, defaultId) {
			var type = typeof item === 'undefined' ? 'undefined' : _typeof(item);
			// object schema
			if (type === 'object') {
				if (!item.id || item.id === 'schema:///') {
					throw new Error('schema that are added directly require an id so that it can be referenced later');
				} else if (item.id.startsWith('schema://') && !item.id.startsWith('schema:///')) {
					throw new Error('schema that are added directly require an id that has no host: ' + item.id);
				}
				this.items.push({ schema: item });
				return this;
			} else if (type !== 'string') {
				throw new TypeError('item must be a string or object');
			}
			// string (file)
			var stats = fs.statSync(item);
			if (stats.isFile()) {
				this.items.push({
					defaultId: defaultId,
					path: item
				});
			} else {
				throw new Error('not a file: ' + item);
			}
			return this;
		}

		/**
   * Registers a global schema that will persist across calls to
   * [clear]{@link #module_axway-schema..AxwaySchema+clear} operations.  Schemas registered with
   * the same `id` will generate a warning but will be ignored.
   *
   * @param {object} schema - The schema.
   * @return {AxwaySchema} The {@link AxwaySchema} object.
   */

	}, {
		key: 'register',
		value: function register(schema) {
			if ((typeof schema === 'undefined' ? 'undefined' : _typeof(schema)) !== 'object') {
				throw TypeError('invalid parameter: schema');
			}
			var exists = this.global.find(function (a) {
				return a.id === schema.id;
			});
			if (exists) {
				this.logger && this.logger.warn('a schema already exists with this id: ' + schema.id);
				return this;
			}
			this.global.push(schema);
			return this;
		}

		/**
   * Loads all schemas previously added with calls to
   * [add]{@link #module_axway-schema..AxwaySchema+add}.
   *
   * @example <caption>Load schemas</caption>
   * ```javascript
   *  const schemas = new AxwaySchema();
   *  schemas
   *	  .add('./schema1.json');
   *	  .add('./schema2.json', 'project');
   *	  .loadSync());
   * ```
   *
   * @return {AxwaySchema} The {@link AxwaySchema} object.
   * @public
   */

	}, {
		key: 'loadSync',
		value: function loadSync() {
			var _this = this;

			// reload global schemas if not already loaded
			var schemas = [];
			if (this.global.length) {
				schemas = schemas.concat(
				// ajv will store the id as lower-case
				this.global.filter(function (a) {
					return !_this.ids.hasOwnProperty(a.id);
				}));
			}

			this.items.forEach(function (item) {
				var schema = void 0;
				if (item.schema) {
					schema = JSON.parse(JSON.stringify(item.schema));
				} else {
					schema = _this._loadSchemaFile(item.path, item.defaultId);
				}
				schemas.push(schema);
			});

			if (schemas.length) {
				this.logger && this.logger.debug('loading ' + schemas.length + ' schema');
				// every schema will have an `id` when adding, otherwise there is no point in
				// it - it will be inaccessible.
				this.ajv.addSchema(schemas);
				// record all ids
				schemas.forEach(function (schema) {
					_this.logger && _this.logger.debug('loaded: ' + schema.id);
					_this.ids[schema.id] = true;
				});
			} else {
				this.logger && this.logger.trace('no schemas to load');
			}
			// reset items to be loaded (this is faster than: `items = []`)
			// https://jsperf.com/array-destroy
			this.items.length = 0;
			return this;
		}

		/**
   * Clears all schemas and resets state.  All registered schema will be automatically re-added
   * on next load.
   *
   * @public
   * @return {AxwaySchema} The {@link AxwaySchema} object.
   */

	}, {
		key: 'clear',
		value: function clear() {
			this.ajv = new Ajv({ unknownFormats: 'ignore' });
			this.ajv.addFormat('multiline', function () {
				return true;
			});
			this.ajv.addMetaSchema(draft04schema);
			this.items = [];
			this.ids = {};
			return this;
		}

		/**
   * Tests whether or not a schema is loaded, identified by `id`.
   *
   * @param {string} id - The schema identifier to test.
   * @return {boolean} True if the schema exists.
   * @public
   */

	}, {
		key: 'exists',
		value: function exists(id) {
			var schema = this.get(id);
			return !!schema;
		}

		/**
   * Gets a schema by `id`.  If `id` is not supplied, all schemas are returned.
   *
   * @param {string} [id] - The schema identifier.
   * @return {object} Returns a schema identified by `id`.
   * @public
   */

	}, {
		key: 'get',
		value: function get(id) {
			var _this2 = this;

			this._ensureLoaded();
			// the object returned by `getSchema` is a function but it also has a `schema`
			// property.  to avoid confusion, just return the schema.
			if (id) {
				var schema = this.ajv.getSchema(id);
				return schema && schema.schema;
			}
			return Object.keys(this.ids).map(function (sid) {
				return _this2.ajv.getSchema(sid).schema;
			});
		}

		/**
   * Validates an object `obj` against a schema identified by `id`.
   *
   * @param {string} id - The schema identifier.
   * @param {object} obj - The object to validate.
   * @return {string} Returns an error string when not valid, undefined otherwise.
   * @public
   */

	}, {
		key: 'validate',
		value: function validate(id, obj) {
			this._ensureLoaded();
			if (typeof id !== 'string') {
				throw TypeError('invalid parameter: id');
			}
			if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object') {
				throw TypeError('invalid parameter: obj');
			}
			var validate = this.ajv.getSchema(id);
			if (!validate) {
				throw Error('schema not loaded: ' + id);
			}
			var valid = validate(obj);
			if (!valid) {
				var name = path.basename(id);
				return this.getErrorString(validate.errors, name);
			}
		}
	}, {
		key: '_doderef',
		value: function _doderef(opts) {
			var _this3 = this;

			var target = opts.target,
			    rename = opts.rename,
			    ref = opts.ref,
			    refpath = opts.refpath,
			    derefed = opts.derefed;

			if (!ref || !ref.uri) {
				throw new Error('schema uri does not exist: ' + refpath);
			}
			// It is possible for schema A to reference B, and for B to reference A.  In this
			// case, when A is dereferenced, it will write a new $ref to B, which is normal,
			// except that B references A, which can cause an infinite loop.  To avoid that,
			// check to see that when we process B, see if A has already been dereferenced and
			// if so, update B to use the existing, expanded reference.
			if (derefed.hasOwnProperty(ref.uri)) {
				if (target) {
					jsonpointer.set(opts.newdoc, refpath.substring(1), { $ref: derefed[ref.uri] });
					return;
				} else {
					// If not expanding into a target location, then it is impossible to expand
					// this schema inline, bail.
					throw new Error('infinite loop detected: ' + refpath);
				}
			}
			this.logger && this.logger.trace('dereferencing ref ' + ref.uri + ' for ' + refpath);

			if (opts.depth > MAX_RECURSION_DEPTH) {
				throw new Error('Exceeded maximum recursion depth of ' + MAX_RECURSION_DEPTH);
			}

			// Check the reference.  If it is a reference to an item in the same document, then
			// fetch the schema from Ajv, combining the local fragment with the main URI of the
			// parent document.
			var schema = void 0;
			if (ref.type === 'local') {
				// fetch from parent schema with local fragment
				var uri = URI.serialize(Object.assign({}, opts.parentUri, { fragment: ref.uriDetails.fragment }));
				schema = this.get(uri);
				if (!schema) {
					throw new Error('sub-schema does not exist: ' + uri);
				}
			} else {
				schema = this.get(ref.uri);
				if (!schema) {
					throw new Error('schema does not exist: ' + ref.uri);
				}
			}

			// Swagger does not like `id` and `$schema`, so remove them.
			var cloned = JSON.parse(JSON.stringify(schema));
			delete cloned.id;
			delete cloned.$schema;
			if (!target) {
				// Inline dereference
				var reftarget = refpath.substring(1);
				if (!reftarget) {
					// if the refpath is `#` then this should become root /,
					// which is just replacing the whole object.
					this.logger && this.logger.warn('inline deref at root /');
					opts.newdoc = cloned;
				} else {
					this.logger && this.logger.warn('inline deref at ' + reftarget + ' when dereferencing ' + ref.uri);
					jsonpointer.set(opts.newdoc, reftarget, cloned);
				}
				derefed[ref.uri] = true;
			} else {
				// Expand at target location (e.g. `#/definitions`) and update `$ref`.
				var name = rename ? rename(ref.uri) : path.basename(ref.uri, '.json');
				var targetpath = target.substring(1) + '/' + name;
				// escaping slashes and tilde for jsonpointer (https://tools.ietf.org/html/rfc6901)
				var escTargetref = target + '/' + name.replace(/~/, '~0').replace(/\//, '~1');
				var escTargetpath = target.substring(1) + '/' + name.replace(/~/, '~0').replace(/\//, '~1');

				if (jsonpointer.has(opts.newdoc, escTargetpath)) {
					this.logger && this.logger.warn('updated existing data at ' + targetpath + ' when dereferencing ' + ref.uri);
				}
				jsonpointer.set(opts.newdoc, escTargetpath, cloned);

				// If the reference type is not local, then change the reference (e.g. "remote")
				// to a local reference.  Else, find the "local" references in the target document
				// and rewrite the $ref to the new target location.
				if (opts.ref.type !== 'local') {
					jsonpointer.set(opts.newdoc, refpath.substring(1), { $ref: escTargetref });
				} else {
					var existingRefs = jsonrefs.findRefs(opts.newdoc, {
						filter: function filter(eref) {
							return eref.uri === ref.def.$ref;
						}
					});
					Object.keys(existingRefs).forEach(function (eref) {
						existingRefs[eref].def.$ref = escTargetref;
					});
				}
				// Store deref to not hit infinite loop
				derefed[ref.uri] = '#' + escTargetpath;
			}

			// Some schema have local definitions.  E.g. our flow-schema references #/definitions/node
			// of the same schema.  Those local definitions also need to be recursively expanded into
			// the target document.
			var subrefs = jsonrefs.findRefs(schema, { filter: ['local'] });
			Object.keys(subrefs).forEach(function (subrefpath) {
				return _this3._doderef({
					newdoc: opts.newdoc,
					target: target,
					rename: rename,
					ref: subrefs[subrefpath],
					refpath: subrefpath,
					parentUri: opts.parentUri || ref.uriDetails,
					derefed: derefed,
					depth: opts.depth + 1
				});
			});
		}

		/**
   * Callback function to rename a target when used as a
   * [dereference]{@link #module_axway-schema..AxwaySchema+dereference} target.
   * For example, if your id is "schema://svc.foo/bar", then `bar` will be written
   * to the dereference target as `bar`.  If you want to rename `bar`, then use
   * this function.
   * @public
   * @callback targetRenameCallback
   * @param {id} id - The schema id.
   * @return {string} Return the renamed target.
   */

		/**
   * Dereferences non-local references in the supplied document.  The supplied
   * document is not modified.  All non-local references (e.g `schema://`) will
   * be replaced with the corresponding loaded schema.  If schema are not found,
   * an error will be thrown.
   *
   * If `options.target` is not supplied, then references are expanded inline.  If
   * `options.target` is supplied, then references are expanded in the location specified
   * by `options.target` and any existing reference updated to point to the new target.
   * For example, if the `options.target` is `#/definitions`, then the schema will be
   * expanded to `$.definitions` with the name of the schema the trailing component
   * (basename) of its `id`, or if `options.rename` is supplied, the name
   * returned by that.
   *
   * @param {object} doc - A document
   * @param {object} [options] - Options
   * @param {string} [options.target] - A target
   * @param {targetRenameCallback} [options.rename] - A callback to rename schema
   * @return {object} Returns a document with `schema://` references expanded.
   * @public
   */

	}, {
		key: 'dereference',
		value: function dereference(doc, options) {
			var _this4 = this;

			this._ensureLoaded();
			if (!doc || (typeof doc === 'undefined' ? 'undefined' : _typeof(doc)) !== 'object') {
				throw TypeError('invalid parameter: doc');
			}
			if (options && (typeof options === 'undefined' ? 'undefined' : _typeof(options)) !== 'object') {
				throw TypeError('invalid parameter: options');
			}
			var newdoc = JSON.parse(JSON.stringify(doc)); // deep copy
			var complete = false;
			var derefed = {};
			// for every $ref identified, get the schema for it and replace it in `newdoc`, either by
			// replacing it inline, or if `target` is supplied, expanding it into the target location
			// and updating the $ref to point to the new target location.

			var _loop = function _loop() {
				// filter all refs that are not doc anchors
				var refs = jsonrefs.findRefs(newdoc, { filter: ['remote'] });
				var paths = Object.keys(refs);
				var target = options && options.target;
				var rename = options && options.rename;
				complete = !paths.length;
				paths.forEach(function (refpath) {
					return _this4._doderef({
						newdoc: newdoc,
						target: target,
						rename: rename,
						ref: refs[refpath],
						refpath: refpath,
						derefed: derefed,
						depth: 0
					});
				});
			};

			do {
				_loop();
			} while (!complete);
			return newdoc;
		}

		/**
   * The ajv.errorsText is actually not very good.
   *
   * @param {array} errors - ajv errors object
   * @param {string} objectType - The name of the object type that was validated
   * @return {string} A formatted error string.
   * @public
   */

	}, {
		key: 'getErrorString',
		value: function getErrorString(errors, objectType) {
			return errors.map(function (err) {
				var dataPath = err.dataPath ? '$' + err.dataPath : objectType + ' root';
				return 'at schema ' + err.schemaPath + ', ' + dataPath + ' ' + err.message + ' (' + JSON.stringify(err.params) + ')';
			}).join('. ');
		}

		/**
   * Ensures [loadSync]{@link #module_axway-schema..AxwaySchema+loadSync} was called after
   * [add]{@link #module_axway-schema..AxwaySchema+add} - throws if not loaded.
   *
   * @private
   */

	}, {
		key: '_ensureLoaded',
		value: function _ensureLoaded() {
			if (this.items.length) {
				throw new Error('call `loadSync` to finish adding items.');
			}
		}

		/**
   * Loads a schema from file.
   * @param {string} fpath - The file path to load.
   * @param {string} [defaultId] - An optional default id the schema.
   * @return {object} A parsed JSON schema file.
   * @private
   */

	}, {
		key: '_loadSchemaFile',
		value: function _loadSchemaFile(fpath, defaultId) {
			var contents = fs.readFileSync(fpath, 'utf8');
			var parsed = JSON.parse(contents);
			if (!parsed.id) {
				parsed.id = defaultId;
				if (!defaultId) {
					throw new Error('schema id must be defined: ' + fpath);
				}
			}
			this.logger && this.logger.trace('loaded schema file: ' + fpath + ' with id ' + parsed.id);
			return parsed;
		}
	}]);

	return AxwaySchema;
}();

Singleton.declare('axway-schema-singleton', AxwaySchema);

exports = module.exports = Singleton.get('axway-schema-singleton');