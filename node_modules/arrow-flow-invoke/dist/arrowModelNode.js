'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _require = require('axway-flow'),
    FlowManager = _require.FlowManager;

var ArrowNode = require('./arrowNode');
var ArrowQueryOptions = require('./arrowqueryoptions');

/**
 * Get the APIs that are supported by the model/connector.
 * @param {Arrow} arrow - the arrow instance
 * @param {object} model - the model to generate a spec for
 * @returns {array} array of APIs supported by the model
 */
function _getSupportedAPIs(arrow, model) {
	var apis = [];
	var connector = model.connector && typeof model.connector === 'string' ? arrow.getConnector(model.connector) : model.connector;

	if (!connector) {
		return apis;
	}

	for (var key in model) {
		// Arrow expects the model to advertise it's supported APIs by providing methods that have an
		// API suffix. Here we're using the same logic - any method on Model with an API suffix is a
		// potential API - with some caveats.
		//
		// Models may have custom APIs beyond what is described in Arrow ORM - these are not supported
		// by this node handler and will be ignored. Also the connector must also support all the method
		// dependencies for that API.
		//
		// e.g. Model.findAndModifyAPI advertises the 'findAndModify' from the Model API but as there is
		// a dependsOnAll: ['query', 'create', 'save'] in the API descriptor, the API is only supported
		// if the connector supports 'query, 'create' and 'save' methods.
		//
		if (model[key] && key.slice(-3) === 'API') {
			var name = key.slice(0, -3);
			if (model[name] && Object.getPrototypeOf(model).hasOwnProperty(name)) {
				// Check to see if the underlying connector has the necessary methods to support this API.
				var apiDef = model[key]();
				var reqConnectorMethods = apiDef.dependsOnAny || apiDef.dependsOnAll || [name];
				var connectorMethods = reqConnectorMethods.filter(function (method) {
					if (method === 'findByID') {
						// Some connectors use old mappings, to maintain support remap to the standard action.
						return !!connector[method] || !!connector['findById'] || !!connector['findOne'];
					}
					return !!connector[method];
				});

				if (connectorMethods.length >= (apiDef.dependsOnAll ? reqConnectorMethods.length : 1)) {
					apis.push(name);
				} else {
					arrow.logger && arrow.logger.trace && arrow.logger.trace('  unsupported API on Connector: ' + name);
				}
			} else {
				arrow.logger && arrow.logger.trace && arrow.logger.trace('  unsupported API on Model: ' + name);
			}
		}
	}

	return apis;
}

/**
 * Get the spec for the model method.
 * @param {Arrow} arrow - the arrow instance
 * @param {object} model - the model to generate a spec for
 * @param {string} methodName - the name of the method to get a spec for
 * @returns {object} generated node handler spec
 */
function _getMethodSpec(arrow, model, methodName) {
	var spec = void 0;
	switch (methodName) {
		case 'count':
			spec = {
				description: 'Gets a count of records.',
				parameter: {
					type: 'object',
					properties: _extends({}, ArrowQueryOptions),
					additionalProperties: false
				},
				outputs: {
					next: {
						description: 'Successfully counted records of ' + model.name + '.',
						context: '$.count',
						schema: {
							type: 'number'
						}
					}
				}
			};
			break;
		case 'create':
			spec = {
				description: 'Creates a new model object.',
				parameter: {
					type: 'object',
					properties: {
						data: {
							$ref: arrow.getModelSchemaId(model)
						}
					},
					additionalProperties: false,
					required: ['data']
				},
				outputs: {
					next: {
						description: 'Successfully created a ' + model.name + '.',
						context: '$.created',
						schema: {
							$ref: arrow.getModelSchemaId(model)
						}
					}
				}
			};
			break;
		case 'delete':
			spec = {
				description: 'Deletes the model object.',
				parameter: {
					type: 'object',
					properties: {
						id: {
							// Models and connectors don't expose type information for
							// primary key field.
						}
					},
					required: ['id'],
					additionalProperties: false
				},
				outputs: {
					next: {
						description: 'Successfully deleted the ' + model.name + '.',
						context: '$.deleted',
						schema: {
							$ref: arrow.getModelSchemaId(model)
						}
					},
					notfound: {
						description: 'No model instance found.'
					}
				}
			};
			break;
		case 'deleteAll':
			spec = {
				description: 'Deletes all the model objects.',
				parameter: {
					properties: {},
					additionalProperties: false
				},
				outputs: {
					next: {
						description: 'Successfully deleted all the ' + model.name + '.',
						context: '$.deletedAll',
						schema: {
							type: 'array',
							items: {
								$ref: arrow.getModelSchemaId(model)
							}
						}
					}
				}
			};
			break;
		case 'distinct':
			spec = {
				description: 'Finds unique values using the provided field.',
				parameter: {
					type: 'object',
					properties: _extends({}, ArrowQueryOptions, {
						field: {
							type: 'string',
							description: 'The field that must be distinct.',
							enum: Object.keys(model.fields)
						}
					}),
					required: ['field'],
					additionalProperties: false
				},
				outputs: {
					next: {
						description: 'Successfully found all unique values of ' + model.name + '.',
						context: '$.distinct',
						schema: {
							type: 'array',
							items: {
								$ref: arrow.getModelSchemaId(model)
							}
						}
					}
				}
			};
			break;
		case 'findAll':
			spec = {
				description: 'Finds all model instances.',
				parameter: {
					properties: {},
					additionalProperties: false
				},
				outputs: {
					next: {
						description: 'Successfully found all ' + model.name + '.',
						context: '$.foundAll',
						schema: {
							type: 'array',
							items: {
								$ref: arrow.getModelSchemaId(model)
							}
						}
					}
				}
			};
			break;
		case 'findAndModify':
			spec = {
				description: 'Finds one model instance and modifies it.',
				parameter: {
					type: 'object',
					properties: _extends({}, ArrowQueryOptions, {
						args: {
							type: 'object',
							description: 'Optional parameters.',
							properties: {
								new: {
									type: 'boolean',
									description: 'Set to true to return the new model instead of the original model.'
								},
								upsert: {
									type: 'boolean',
									description: 'Set to true to allow the method to create a new model.'
								}
							}
						},
						data: {
							$ref: arrow.getModelSchemaId(model)
						}
					}),
					required: ['data'],
					additionalProperties: false
				},
				outputs: {
					next: {
						description: 'Successfully found and modified ' + model.name + '.',
						context: '$.foundAndModified',
						schema: {
							$ref: arrow.getModelSchemaId(model)
						}
					},
					notfound: {
						description: 'No matching model found.'
					}

				}
			};
			break;
		case 'findByID':
			spec = {
				description: 'Finds model instance by ID.',
				parameter: {
					type: 'object',
					properties: {
						id: {
							// Models and connectors don't expose type information for
							// primary key field.
						}
					},
					required: ['id'],
					additionalProperties: false
				},
				outputs: {
					next: {
						description: 'Successfully found instance of ' + model.name + ' by ID.',
						context: '$.foundByID',
						schema: {
							$ref: arrow.getModelSchemaId(model)
						}
					},
					notfound: {
						description: 'No model instance found.'
					}
				}
			};
			break;
		case 'query':
			spec = {
				description: 'Queries for particular model records.',
				parameter: {
					type: 'object',
					properties: _extends({}, ArrowQueryOptions),
					additionalProperties: false
				},
				outputs: {
					next: {
						description: 'Successfully queried the ' + model.name + '.',
						context: '$.queried',
						schema: {
							type: 'array',
							items: {
								$ref: arrow.getModelSchemaId(model)
							}
						}
					}
				}
			};
			break;
		case 'update':
			spec = {
				description: 'Updates a model instance.',
				parameter: {
					type: 'object',
					properties: {
						id: {
							// Models and connectors don't expose type information for
							// primary key field.
						},
						data: {
							$ref: arrow.getModelSchemaId(model)
						}
					},
					required: ['id', 'data'],
					additionalProperties: false
				},
				outputs: {
					next: {
						description: 'Successfully updated the ' + model.name + '.',
						context: '$.updated',
						schema: {
							$ref: arrow.getModelSchemaId(model)
						}
					},
					notfound: {
						description: 'No model instance found.'
					}
				}
			};
			break;
		case 'upsert':
			spec = {
				description: 'Creates a model record if not found, or updates the model record if found.',
				parameter: {
					type: 'object',
					properties: {
						data: {
							$ref: arrow.getModelSchemaId(model)
						}
					},
					required: ['data'],
					additionalProperties: false
				},
				outputs: {
					update: {
						description: 'Successfully updated the model.',
						context: '$.model',
						schema: {
							$ref: arrow.getModelSchemaId(model)
						}
					},
					insert: {
						description: 'Successfully inserted the model.',
						context: '$.model',
						schema: {
							$ref: arrow.getModelSchemaId(model)
						}
					}
				}
			};
			break;
		default:
			spec = null;
	}
	return spec;
}

/**
 * Returns the schema function for the model specific node handler.
 * @param {Arrow} arrow - the arrow instance
 * @param {object} model - the model to generate a spec for
 * @returns {object} generated node handler spec
 */
var getSpec = function getSpec(arrow, model) {
	arrow.logger && arrow.logger.trace && arrow.logger.trace('Generating Model spec for ' + model.name);
	// Remove the connector prefix from the name.
	var name = void 0;
	var connector = model.connector;
	var connectorName = connector && (typeof connector === 'undefined' ? 'undefined' : _typeof(connector)) === 'object' ? connector.name : connector;
	if (model.name.startsWith(connectorName)) {
		name = model.name.substring(connectorName.length + 1);
	} else {
		name = model.name;
	}

	var handlerSpec = {
		schemaVersion: '1',
		type: FlowManager.formatNodeHandlerUri('arrow-flow-invoke', 'model/' + model.name),
		name: name,
		icon: 'icon-GG-cube',
		category: 'Model',
		methods: {}
	};

	var supportedAPIs = _getSupportedAPIs(arrow, model);
	supportedAPIs.forEach(function (methodName) {
		var spec = _getMethodSpec(arrow, model, methodName);
		if (!spec) {
			arrow.logger && arrow.logger.trace && arrow.logger.trace('  unsupported Model method: ' + methodName);
		} else {
			arrow.logger && arrow.logger.trace && arrow.logger.trace('  adding Model method to spec: ' + methodName);
			handlerSpec.methods[methodName] = spec;
		}
	});
	return handlerSpec;
};

var ArrowModelNode = function (_ArrowNode) {
	_inherits(ArrowModelNode, _ArrowNode);

	function ArrowModelNode(arrow, model, name, node, spec, flow) {
		_classCallCheck(this, ArrowModelNode);

		var _this = _possibleConstructorReturn(this, (ArrowModelNode.__proto__ || Object.getPrototypeOf(ArrowModelNode)).call(this, arrow, name, node, spec, flow));

		_this.model = model;
		_this.primaryKey = model ? model.getPrimaryKeyName() : null;
		return _this;
	}

	_createClass(ArrowModelNode, [{
		key: 'count',
		value: function count(req, cb) {
			this.model.count(req.params, cb.next);
		}
	}, {
		key: 'create',
		value: function create(req, cb) {
			var obj = Object.assign({}, req.params.data);
			delete obj.id;
			this.model.create(obj, cb.next);
		}
	}, {
		key: 'delete',
		value: function _delete(req, cb) {
			this.model.delete(req.params.id, function (err, result) {
				// Not great but ORM layer doesn't just return null when not found
				if (err && err.match && err.match(/^trying to remove, couldn't find record with primary key:/)) {
					cb.notfound();
				} else {
					cb.next(err, result);
				}
			});
		}
	}, {
		key: 'deleteAll',
		value: function deleteAll(req, cb) {
			this.model.deleteAll(cb.next);
		}
	}, {
		key: 'distinct',
		value: function distinct(req, cb) {
			var field = req.params.field;
			delete req.params.field;
			this.model.distinct(field, req.params, cb.next);
		}
	}, {
		key: 'findAll',
		value: function findAll(req, cb) {
			this.model.findAll(cb.next);
		}
	}, {
		key: 'findAndModify',
		value: function findAndModify(req, cb) {
			var args = req.params.args || {};
			var model = req.params.data;
			delete req.params.args;
			delete req.params.data;
			this.model.findAndModify(req.params, model, args, function (err, modified) {
				if (modified) {
					cb.next(err, modified);
				} else {
					cb.notfound(err);
				}
			});
		}
	}, {
		key: 'findByID',
		value: function findByID(req, cb) {
			this.model.findByID(req.params.id, function (err, result) {
				if (result) {
					cb.next(err, result);
				} else {
					cb.notfound(err, result);
				}
			});
		}
	}, {
		key: 'query',
		value: function query(req, cb) {
			this.model.query(req.params, function (err, result) {
				cb.next(err, result || []);
			});
		}
	}, {
		key: 'update',
		value: function update(req, cb) {
			var data = Object.assign({}, req.params.data, { id: req.params.id });
			this.model.update(data, function (err, result) {
				// Not great but ORM layer doesn't just return null when not found
				if (err && err.match && err.match(/^trying to update, couldn't find record with primary key:/)) {
					cb.notfound();
				} else {
					cb.next(err, result);
				}
			});
		}
	}, {
		key: 'upsert',
		value: function upsert(req, cb) {
			var _this2 = this;

			if (!req.params.data || !req.params.data.hasOwnProperty(this.primaryKey)) {
				cb({ error: 'missing required parameter: ' + this.primaryKey });
				return;
			}

			var modelData = req.params.data;
			var id = modelData[this.primaryKey];

			// Upsert is expected to differentiate between new and update
			// the model upsert doesn't so do it manually.
			this.model.findByID(id, function (err, result) {
				if (err) {
					cb(err);
					return;
				}

				var update = !!result;

				_this2.model.upsert(id, modelData, function (upsertErr, model) {
					if (update) {
						cb.update(upsertErr, model);
					} else {
						cb.insert(upsertErr, model);
					}
				});
			});
		}
	}]);

	return ArrowModelNode;
}(ArrowNode);

exports = module.exports = {
	handler: ArrowModelNode,
	spec: getSpec
};