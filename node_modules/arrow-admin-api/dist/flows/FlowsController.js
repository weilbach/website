'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var path = require('path');
var fs = require('fs');
var async = require('async');
var BadRequestError = require('../errors/BadRequestError');
var NotFoundError = require('../errors/NotFoundError');
var InternalServerError = require('../errors/InternalServerError');

var _require = require('../util'),
    mkdirIfNotExists = _require.mkdirIfNotExists,
    isSafeFilename = _require.isSafeFilename;

/**
 * The controller implementing the actions for interacting with Flows.
 * @public
 */


var FlowsController = function () {
	/**
  * Create a ProjectController.
  * @param {object} ctx - The context for this controller.
  * @param {express} ctx.app - The express application.
  * @param {string} ctx.prefix - The prefix bound to.
  * @param {Arrow} ctx.arrow - The Arrow server.
  * @param {boolean} ctx.devmode - Flag indicating if this is a devmode server.
  * @param {Swagger} ctx.swagger - openapi-doc instance.
  */
	function FlowsController(ctx) {
		_classCallCheck(this, FlowsController);

		this.ctx = ctx;
		this.flowsDir = path.resolve(path.join(this.ctx.arrow.config.dir || process.cwd(), 'flows'));
		this.logger = this.ctx.arrow.logger;
		this.flowManager = this.ctx.arrow.flowManager;
	}

	/**
  * Get a flow
  * @param {string} flowId - The name of the Flow to get
  * @returns {Promise} - Resolves to a flow on success.
  */


	_createClass(FlowsController, [{
		key: 'getFlow',
		value: function getFlow(flowId) {
			var _this = this;

			this.logger && this.logger.trace('Getting flow: ' + flowId);
			return new Promise(function (resolve, reject) {
				if (!flowId) {
					return reject(new BadRequestError());
				}
				var flow = _this.ctx.arrow.getFlow(flowId);
				if (!flow) {
					return reject(new NotFoundError());
				}
				return resolve(flow);
			});
		}

		/**
   * Checks to see if `flowId` already exists.
   * @param {string} flowId - The flow to check.
   * @returns {Promise<boolean>} True if the flow exists.
   */

	}, {
		key: 'exists',
		value: function exists(flowId) {
			var _this2 = this;

			this.logger && this.logger.trace('Getting flow: ' + flowId);
			return new Promise(function (resolve, reject) {
				if (!flowId) {
					return reject(new BadRequestError());
				}
				return resolve(!!_this2.ctx.arrow.getFlow(flowId));
			});
		}

		/**
   * Delete a flow by name.
   * @param  {string} flowId - name of the flowfile (x-flow)
   * @returns {Promise}
   */

	}, {
		key: 'deleteFlow',
		value: function deleteFlow(flowId) {
			var _this3 = this;

			this.logger && this.logger.trace('Deleting flow: ' + flowId);
			return new Promise(function (resolve, reject) {
				if (!flowId) {
					return reject(new BadRequestError('Missing parameter: flowId'));
				}
				if (!isSafeFilename(flowId)) {
					// Reject the request if the flowId is not a valid (safe) id.
					return reject(new BadRequestError('Invalid parameter: flowId'));
				}

				var flowFilePath = path.join(_this3.flowsDir, flowId + '.json');
				return async.series([function (next) {
					return fs.stat(flowFilePath, next);
				}, function (next) {
					return fs.unlink(flowFilePath, next);
				}], function (err) {
					if (err) {
						_this3.logger && _this3.logger.error(err);
						// security - do not reject with err.message
						return reject(new BadRequestError());
					}
					return resolve();
				});
			});
		}

		/**
   * Validates a flow.
   * @param {object} flow - The flow to validate
   * @returns {Promise} - Resolves a validation response.
   */

	}, {
		key: 'validateFlow',
		value: function validateFlow(flow) {
			var _this4 = this;

			this.logger && this.logger.trace('Validating flow');
			return new Promise(function (resolve, reject) {
				if (!flow) {
					return reject(new BadRequestError('Missing parameter: flow'));
				}
				_this4.flowManager.validate(flow, { graph: true, schema: true }).catch(function (error) {
					if (error instanceof Error) {
						// json-schema validation can reject with a string
						return resolve({
							valid: false,
							errors: [{
								type: 'invalidFlow',
								code: 'INVALID_FLOW',
								location: '/',
								detail: {
									error: error.message
								}
							}]
						});
					} else {
						// a graph validation error
						return resolve(error);
					}
				}).then(function () {
					resolve({ valid: true });
				});
			});
		}

		/**
   * Saves a flow
   * @param  {string} flowId - name of the flowfile (x-flow)
   * @param {object} flow - The flow to save
   * @returns {Promise} - Resolves on success.
   */

	}, {
		key: 'saveFlow',
		value: function saveFlow(flowId, flow) {
			var _this5 = this;

			this.logger && this.logger.trace('Saving flow: ' + flowId);
			return new Promise(function (resolve, reject) {
				if (!flowId) {
					return reject(new BadRequestError('Missing parameter: flowId'));
				}
				if (!flow) {
					return reject(new BadRequestError('Missing parameter: flow'));
				}
				if (!isSafeFilename(flowId)) {
					// Reject the request if the flowId is not a valid (safe) id.
					return reject(new BadRequestError('Invalid parameter: flowId'));
				}
				async.series([function (next) {
					_this5.validateFlow(flow).then(function (validation) {
						if (!validation.valid) {
							_this5.logger && _this5.logger.error('invalid flow: ' + flowId, JSON.stringify(validation.errors));
							_this5.logger && _this5.logger.error('data:', JSON.stringify(flow));
							return next(new BadRequestError('Invalid parameter: flow'));
						}
						next();
					}, next);
				}, function (next) {
					return mkdirIfNotExists(_this5.flowsDir, next);
				}, function (next) {
					var flowFilePath = path.join(_this5.flowsDir, flowId + '.json');
					var data = JSON.stringify(flow, null, '\t');
					fs.writeFile(flowFilePath, data, 'utf8', function (err) {
						next(err);
					});
				}], function (error) {
					if (error) {
						_this5.logger && _this5.logger.error(error);
						if (error instanceof BadRequestError) {
							reject(error);
						} else {
							reject(new InternalServerError());
						}
					} else {
						resolve();
					}
				});
			});
		}
	}]);

	return FlowsController;
}();

exports = module.exports = FlowsController;