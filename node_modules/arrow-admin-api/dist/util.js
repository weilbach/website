'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * This code is closed source and Confidential and Proprietary to
 * Appcelerator, Inc. All Rights Reserved.  This code MUST not be
 * modified, copied or otherwise redistributed without express
 * written permission of Appcelerator. This file is licensed as
 * part of the Appcelerator Platform and governed under the terms
 * of the Appcelerator license agreement.
 */
var fs = require('fs'),
    path = require('path'),
    http = require('http'),
    readline = require('readline'),
    Logger = require('appc-logger'),
    devnull = require('dev-null');

function logFileExists(logdir, reqId) {
	var filename = path.join(logdir, 'request-' + reqId + '.log.metadata');
	return fs.existsSync(filename);
}

function quietClose(s) {
	try {
		s.close();
	} catch (err) {
		// ignore
	}
}

function readLogFile(reqlog, lineCallback, doneCallback) {
	if (!fs.existsSync(reqlog)) {
		doneCallback();
		return;
	}
	var instream = fs.createReadStream(reqlog);
	var rl = readline.createInterface({ input: instream, output: devnull() });
	rl.setPrompt('');
	rl.on('line', function (line) {
		try {
			if (lineCallback(JSON.parse(line))) {
				instream.pause();
				quietClose(instream);
				rl.close();
			}
		} catch (err) {
			instream.pause();
			quietClose(instream);
			this.emit('error', err);
		}
	});
	rl.on('error', doneCallback);
	rl.on('close', doneCallback);
}

function statusMessage(code) {
	return http.STATUS_CODES[String(code)];
}

function formatLogLevel(level) {
	switch (level) {
		case Logger.TRACE:
			return 'TRACE';
		case Logger.DEBUG:
			return 'DEBUG';
		case Logger.INFO:
			return 'INFO';
		case Logger.WARN:
			return 'WARN';
		case Logger.ERROR:
			return 'ERROR';
		case Logger.FATAL:
			return 'FATAL';
		default:
			return 'INFO';
	}
}

function getSafeReqId(req) {
	var id = req;
	if (typeof id !== 'string') {
		id = req.params && req.params.id || req._params && req._params.id;
	}
	return (id || '').replace(/[/\\.]/g, '');
}

function getRequestLogPathFromId(dir, reqId) {
	var safeId = getSafeReqId(reqId);
	return path.join(dir, 'request-' + safeId + '.log');
}

function getRequestLogPath(dir, req) {
	return getRequestLogPathFromId(dir, req);
}

function isLoggedIn(req, expectedSecret) {
	if (!req || !req.cookies) {
		return false;
	}
	var actualSecret = req.cookies.sessionsecret;
	return !!actualSecret && actualSecret === expectedSecret;
}

function getObjValue(obj, key) {
	return key.split('.').reduce(function (o, x) {
		return typeof o === 'undefined' || o === null ? o : o[x];
	}, obj);
}

function mkdirIfNotExists(dir, next) {
	fs.stat(dir, function (err, stats) {
		if (err) {
			if (err.code === 'ENOENT') {
				fs.mkdir(dir, 448, next);
			} else {
				next(err);
			}
		} else if (!stats.isDirectory()) {
			next(new Error(dir + ' is not a directory.'));
		} else {
			next();
		}
	});
}

/**
 * Makes a safe filename from `name`.
 * @param {string} name - the name of the file
 * @returns {string} the path to the file with a safe filename
 */
function safeFilename(name) {
	var camelCaseName = name.toLowerCase().replace(/(?:\s)[a-z]/g, function (match) {
		return match.toUpperCase().trim();
	});
	var traversal = path.relative(path.sep, path.join(path.sep, camelCaseName));
	var safe = traversal.replace(/[/,?,<,>,\\,:,*,|,",',., ]/g, '');
	return path.relative(path.sep, path.join(path.sep, safe));
}

/**
 * Checks that `name` is a safe filename.  A safe filename is alpha-numeric.  This function
 * has no relationship with `safeFilename`.
 * @param {string} name - the name of the file
 * @returns {boolean} if the name is a safe file name
 */
function isSafeFilename(name) {
	return name.match(/^[a-zA-Z0-9-_]{1,}$/) !== null;
}

/**
 * Writes an object to a file at a given path
 *
 * @param {string} fn - file path
 * @param {object} data - object to stringify and write to file
 * @param {function} cb - callback
 */
function writeJSONFile(fn, data, cb) {
	if (!data || (typeof data === 'undefined' ? 'undefined' : _typeof(data)) !== 'object') {
		throw new TypeError('Invalid parameter "data"');
	}
	var opts = {
		flag: 'w',
		encoding: 'utf-8',
		mode: 420
	};

	fs.writeFile(fn, JSON.stringify(data, null, 2), opts, cb);
}

/**
 * Writes a file to disk. If a file already exists at the specified location,
 * the file will be written with .1 .2 etc.. appended to the name.
 *
 * @param {string} dir - directory to write to
 * @param {string} name - filename
 * @param {object} data - data to write to file
 * @param {function} cb - callback
 */
function writeUniqueJSONFile(dir, name, data, cb) {
	var originalName = name;
	var count = 0;
	var _writeUniqueFileRec = function _writeUniqueFileRec(filename, cb2) {
		var fn = path.join(dir, filename + '.json');
		fs.stat(fn, function (err) {
			if (err) {
				if (err.code === 'ENOENT') {
					// file does not exist
					return writeJSONFile(fn, data, function (e) {
						cb2(e, fn);
					});
				}
				// other error
				return cb2(err);
			}
			// already exists. try with a different name
			count++;
			return _writeUniqueFileRec(originalName + '.' + count, cb2);
		});
	};
	_writeUniqueFileRec(originalName, function (err, fn) {
		if (err) {
			return cb(err);
		}
		return cb(null, fn);
	});
}

var arrowQueryOptions = [{
	in: 'query',
	name: 'limit',
	description: 'The number of records to fetch. The value must be greater than 0, and no greater than 1000.',
	required: false,
	type: 'number',
	default: 10
}, {
	in: 'query',
	name: 'skip',
	description: 'The number of records to skip. The value must not be less than 0.',
	required: false,
	type: 'number',
	default: 0
}, {
	in: 'query',
	name: 'where',
	description: 'Constrains values for fields. The value should be encoded JSON.',
	required: false,
	type: 'string',
	format: 'json'
}, {
	in: 'query',
	name: 'order',
	description: 'A dictionary of one or more fields specifying sorting of results. In general, you can sort based on any predefined field that you can query using the where operator, as well as on custom fields. The value should be encoded JSON.',
	required: false,
	type: 'string',
	format: 'json'
}, {
	in: 'query',
	name: 'sel',
	description: 'Selects which fields to return from the query. Others are excluded. The value should be encoded JSON.',
	required: false,
	type: 'string',
	format: 'json'
}, {
	in: 'query',
	name: 'unsel',
	description: 'Selects which fields to not return from the query. Others are included. The value should be encoded JSON.',
	required: false,
	type: 'string',
	format: 'json'
}, {
	in: 'query',
	name: 'page',
	description: 'Request page number starting from 1.',
	required: false,
	type: 'number',
	default: 1
}, {
	in: 'query',
	name: 'per_page',
	description: 'Number of results per page.',
	required: false,
	type: 'number',
	default: 10
}];

exports = module.exports = {
	readLogFile: readLogFile,
	statusMessage: statusMessage,
	getSafeReqId: getSafeReqId,
	getRequestLogPath: getRequestLogPath,
	getRequestLogPathFromId: getRequestLogPathFromId,
	isLoggedIn: isLoggedIn,
	logFileExists: logFileExists,
	getObjValue: getObjValue,
	formatLogLevel: formatLogLevel,
	mkdirIfNotExists: mkdirIfNotExists,
	safeFilename: safeFilename,
	isSafeFilename: isSafeFilename,
	arrowQueryOptions: arrowQueryOptions,
	writeJSONFile: writeJSONFile,
	writeUniqueJSONFile: writeUniqueJSONFile
};