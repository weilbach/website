'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var APIProvider = require('../APIProvider');

var VALID_FIELDS = ['statusCode', 'method', 'url', 'time'];
var VALID_SORT = ['asc', 'desc'];
var VALID_LOGICAL_OP = ['and', 'or'];

var LogsAPI = function (_APIProvider) {
	_inherits(LogsAPI, _APIProvider);

	function LogsAPI() {
		_classCallCheck(this, LogsAPI);

		return _possibleConstructorReturn(this, (LogsAPI.__proto__ || Object.getPrototypeOf(LogsAPI)).apply(this, arguments));
	}

	_createClass(LogsAPI, null, [{
		key: 'bind',
		value: function bind(controller) {
			var swagger = controller.ctx.swagger;

			swagger.schema('LogEntry', {
				type: 'array',
				items: {
					type: 'string'
				}
			});

			swagger.get('/logs').operationId('getLogs').tag('logging').summary('Gets an array of LogEntry.  If no records exist, then an empty array is returned.').description('\
The list can be filtered using the expression: field=__field__&op=__op__&value=__value__. Optionally, you can add a logical operation for all expressions, using the form: &lop=AND|OR. By default, the logical operation is AND. Multiple expression filters can be used, specifying field, op, and value for each filter. The field is one of:\
||value||description||\
|eq|Equal|\
|ne|Not equal|\
|gt|Greater than|\
|lt|Less than|\
|ge|Greater than or equal|\
|le|Less than or equal|\
|co|Contains|\
').parameter({ in: 'query', name: 'q', type: 'string', description: 'Search string to filter results.  Matched against all fields.' }).parameter({ in: 'query', name: 'limit', type: 'integer', description: 'The maximum number of records to return.  Defaults to all.' }).parameter({ in: 'query', name: 'offset', type: 'integer', description: 'The record offset' }).parameter({ in: 'query', name: 'order', type: 'string', description: 'Order by field.  One of: statusCode, method, url, time (default), or duration.', enum: ['statusCode', 'method', 'url', 'time'] }).parameter({ in: 'query', name: 'sort', type: 'string', description: 'Sort direction ascending/descending.  One of: asc, desc (default).', enum: ['asc', 'desc'] }).parameter({ in: 'query', name: 'field', type: 'string', description: 'The name of the field on which to filter.  One of: statusCode, method, url, time, or duration.' }).parameter({ in: 'query', name: 'op', type: 'string', description: 'The operation on which to apply to the filter.  See description.' }).parameter({ in: 'query', name: 'value', type: 'string', description: 'The value of the field on which to filter.' }).parameter({ in: 'query', name: 'lop', type: 'string', description: 'The logical operator that applies to all filters.  one of: or, and (default).' }).response(200, 'OK', 'LogEntry', true).response(500).action(function (req, res) {
				var offset = parseInt(req.query.offset, 10) || 0;
				var limit = parseInt(req.query.limit, 10) || -1;

				var orderby = VALID_FIELDS.indexOf(req.query.order || 'time');
				if (orderby < 0) {
					res.status(400).send('invalid field: order');
					return;
				}
				orderby = VALID_FIELDS[orderby];

				var sort = VALID_SORT.indexOf(req.query.sort || 'desc');
				if (sort < 0) {
					res.status(400).send('invalid field: sort');
					return;
				}
				sort = VALID_SORT[sort];

				var lop = VALID_LOGICAL_OP.indexOf(req.query.lop || 'and');
				if (lop < 0) {
					res.status(400).send('invalid field: lop');
					return;
				}
				lop = VALID_SORT[lop];

				var fields = [];
				if (req.query.field) {
					if (Array.isArray(req.query.field)) {
						fields = fields.concat(req.query.field);
					} else {
						fields.push(req.query.field);
					}
				}

				var ops = [];
				if (req.query.op) {
					if (Array.isArray(req.query.op)) {
						ops = ops.concat(req.query.op);
					} else {
						ops.push(req.query.op);
					}
				}

				var values = [];
				if (req.query.value) {
					if (Array.isArray(req.query.value)) {
						values = values.concat(req.query.value);
					} else {
						values.push(req.query.value);
					}
				}

				// make unique set of the filter lengths.  if they differ, there is
				// a missing value.
				if (Array.from(new Set([fields.length, ops.length, values.length])).length !== 1) {
					res.status(400).send('missing filter: field, op, or value');
					return;
				}

				var options = {
					q: req.query.q,
					offset: offset,
					limit: limit,
					orderby: orderby,
					sort: sort,
					field: fields,
					op: ops,
					value: values
				};

				controller.getLogs(options).then(function (data) {
					res.set('x-offset', offset).set('x-count', data.total).status(200).send(data.lines);
				}).catch(function (ex) {
					// async block - errors have to be handled here
					APIProvider.handleError(ex, res, 400, 500);
				});
			});

			swagger.delete('/logs').operationId('deleteLogs').tag('logging').summary('Deletes all log entries.').response(204, 'Successfully deleted logs').response(500).action(function (req, res) {
				controller.deleteLogs(req.body).then(function (data) {
					res.status(204).send(data);
				}).catch(function (ex) {
					// async block - errors have to be handled here
					APIProvider.handleError(ex, res, 400, 500);
				});
			});
		}
	}]);

	return LogsAPI;
}(APIProvider);

exports = module.exports = LogsAPI;