'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var fs = require('fs'),
    path = require('path'),
    moment = require('moment'),
    numeral = require('numeral'),
    async = require('async'),
    Logger = require('appc-logger'),
    util = require('../util');

var ORDERBY = {
	statusCode: 1,
	method: 2,
	url: 3,
	time: 4,
	duration: 6
};

var LogsController = function () {
	function LogsController(ctx) {
		_classCallCheck(this, LogsController);

		this.ctx = ctx;
		this.logdir = Logger.arrowCloudLogDir || path.join(this.ctx.arrow.config.dir || process.cwd(), 'logs');
		this.util = util;
	}

	_createClass(LogsController, [{
		key: 'setUtil',
		value: function setUtil(utilOverride) {
			this.util = utilOverride;
		}
	}, {
		key: 'getLogs',
		value: function getLogs(options) {
			var _this = this;

			return new Promise(function (resolve, reject) {
				var orderby = ORDERBY[options.order || 'time'];
				var lop = options.lop || 'and';
				if (orderby === undefined) {
					reject('invalid field: order');
					return;
				}

				var lines = [];
				var done = function done(err) {
					if (err) {
						reject(err);
						return;
					}
					// first filter out all the non-user api calls
					lines = lines.filter(function (item) {
						return item[ORDERBY.url].startsWith((_this.ctx.arrow.config.apiPrefix || '') + '/' || '/');
					});
					lines.sort(function (a, b) {
						if (options.sort === 'desc') {
							return a[orderby] > b[orderby] ? -1 : 1;
						} else {
							return a[orderby] > b[orderby] ? 1 : -1;
						}
					});
					if (options.field) {
						// filter
						lines = lines.filter(function (item) {
							var lopmatch = true;
							for (var i = 0; i < options.field.length; ++i) {
								var val = item[ORDERBY[options.field[i]]];
								var match = true;
								if (options.op[i] === 'eq') {
									// equals
									// console.log('compare', val, '==', options.value[i]);
									match &= val === options.value[i];
								} else if (options.op[i] === 'ne') {
									// not-equals
									match &= val !== options.value[i];
								} else if (options.op[i] === 'gt') {
									// greater than
									match &= val > options.value[i];
								} else if (options.op[i] === 'lt') {
									// less than
									match &= val < options.value[i];
								} else if (options.op[i] === 'ge') {
									// greater than or equals
									match &= val >= options.value[i];
								} else if (options.op[i] === 'le') {
									// less than or equals
									match &= val <= options.value[i];
								} else if (options.op[i] === 'co') {
									// contains
									match &= val.indexOf(options.value[i]) >= 0;
								} else {
									reject('invalid field: op');
									return null;
								}
								if (lop === 'and') {
									lopmatch &= match;
								} else {
									lopmatch |= match;
								}
							}
							if (lopmatch && options.q) {
								// the line passed all filters, now use query - this will
								// only filter on the visable (filterable) fields
								var _match = false;

								for (var key in ORDERBY) {
									if (!ORDERBY.hasOwnProperty(key)) {
										continue;
									}

									_match = ('' + item[ORDERBY[key]]).indexOf(options.q) >= 0;
									if (_match) {
										break;
									}
								}
								lopmatch = _match;
							}
							return lopmatch;
						});
					}

					var total = lines.length;
					_this.ctx.arrow.logger.debug('offset:', options.offset, 'lines', lines.length);
					if (options.limit >= 0) {
						lines = lines.splice(options.offset, options.limit);
					} else {
						// all
						lines = lines.splice(options.offset);
					}
					_this.ctx.arrow.logger.debug('returning', lines.length);
					resolve({ lines: lines, total: total });
				},
				    readLog = function readLog(reqlog, next) {
					_this.util.readLogFile(reqlog, function (obj) {
						if (!_this.util.logFileExists(_this.logdir, obj.req_id)) {
							return;
						}
						lines.unshift([obj.req_id, obj.res.statusCode, obj.req.method, obj.req.url, obj.time, moment(obj.time).format('MMM D, YYYY h:mm A'), numeral(obj.duration || obj.response_time).format('0.0')]);
					}, next);
				};

				if (_this.ctx.arrow.config.logging && _this.ctx.arrow.config.logging.requestsLogFilename) {
					async.each(fs.readdirSync(_this.logdir), function (log, cb) {
						if (log.indexOf('request-cluster-') === 0) {
							readLog(path.join(_this.logdir, log), done);
						}
						cb();
					}, function (err) {
						!err && lines.sort(function (a, b) {
							return a.time > b.time;
						});
						done(err);
					});
				} else {
					var log = path.join(_this.logdir, 'requests.log');
					readLog(log, done);
				}
			});
		}
	}, {
		key: 'deleteLogs',
		value: function deleteLogs() {
			var _this2 = this;

			this.ctx.arrow.logger.debug('deleting logs');
			return new Promise(function (resolve, reject) {
				fs.readdir(_this2.logdir, function (err, logs) {
					if (err) {
						reject(err);
						return;
					}
					_this2.ctx.arrow.logger.debug('deleting', logs.length, 'log files');
					async.eachLimit(logs, 100, function (log, callback) {
						_this2.ctx.arrow.logger.debug('deleted log', log);
						if (log === 'requests.log') {
							// if requests.log, write 0 bytes to the file
							fs.writeFile(path.join(_this2.logdir, log), '', callback);
						} else if (log.indexOf('request-') === 0) {
							// unlink the log file
							fs.unlink(path.join(_this2.logdir, log), callback);
						} else {
							// Skip
							callback();
						}
					}, function (fserr) {
						_this2.ctx.arrow.logger.debug('done deleting logs');
						if (fserr) {
							reject(fserr);
						} else {
							resolve({ count: logs.length });
						}
					});
				});
			});
		}
	}]);

	return LogsController;
}();

exports = module.exports = LogsController;