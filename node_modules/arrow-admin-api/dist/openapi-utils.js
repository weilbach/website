'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var schemas = require('axway-schema');
var capitalize = require('capitalize');

// http://json-schema.org/draft-04/schema properties
var draft04 = schemas.get('http://json-schema.org/draft-06/schema');
var draft04properties = Object.keys(draft04.properties);

function _pick(obj) {
	for (var _len = arguments.length, props = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
		props[_key - 1] = arguments[_key];
	}

	return Object.assign.apply(Object, [{}].concat(_toConsumableArray(props.map(function (prop) {
		if (obj[prop] !== undefined) {
			return _defineProperty({}, prop, obj[prop]);
		}
		return undefined;
	}))));
}

function _pickSchemaRelevant(obj, additionalProperties) {
	return _pick.apply(undefined, [obj].concat(_toConsumableArray(draft04properties), _toConsumableArray(additionalProperties)));
}

// I could find no restrictions on parameter names in Swagger, so I will assume they are
// all valid, and that ':' denotes a regex, e.g. {banana:[a-z]}.  The regex below will
// match any set of characters within brackets {}, but has an optional, non-capturing
// group that starts with ':'.
var reSwaggerParam = new RegExp(/{(.+?)(?::.*?)?}/g);
var reParamName = new RegExp(/[^a-zA-Z0-9]/g);

// https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-7.3
var allowedFormats = ['date-time', 'email', 'hostname', 'ipv4', 'ipv6', 'uri'];

// Remove any formats that aren't json-schema compliant. Could update ajv with unknownFormats
var _removeFormats = function _removeFormats(prop) {
	if (prop.format && allowedFormats.indexOf(prop.format) < 0) {
		delete prop.format;
	}
};

var MAX_DEPTH = 5;

// This is a candiate (precursor) for its own repo.  These functions have related counterparts
// in nodehandler-utils, and have already diverged a little, but this should be regarded as the
// reference implementation.

/**
 * OpenAPI utility functions.
 */

var OpenAPIUtils = function () {
	function OpenAPIUtils() {
		_classCallCheck(this, OpenAPIUtils);
	}

	_createClass(OpenAPIUtils, null, [{
		key: 'cleanSchema',

		/**
   * Cleans an openapi schema to be JSON schema draft-04 compliant by recursively removing
   * unsupported formats.
   *
   * NOTE: If/when this makes it into a new module, this code should be changed to remove the
   * kill-switch on depth.  Instead, the schema passed in should be guaranteed/made to be
   * non-circular (e.g. with a separate `decircularize` method).
   *
   * @param {object} schema - The openapi schema to transform.
   * @param {number} [level] - The current recursion level for safety.
   * @returns {object} cleaned schema
   */
		value: function cleanSchema(schema) {
			var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

			var cloned = Object.assign({}, schema);
			if (schema.properties) {
				// If the property is of type `object` then we can expect either `properties` or
				// `additionalProperties` to be present.  If present, then those properties also
				// need to be sanitized.
				cloned.properties = {};
				Object.keys(schema.properties).forEach(function (propertyName) {
					cloned.properties[propertyName] = {};
					if (level + 1 < MAX_DEPTH) {
						cloned.properties[propertyName] = OpenAPIUtils.cleanSchema(schema.properties[propertyName], level + 1);
					}
				});
			}
			if (_typeof(schema.additionalProperties) === 'object') {
				if (schema.additionalProperties instanceof Array) {
					cloned.additionalProperties = [];
				} else {
					cloned.additionalProperties = {};
				}
				if (level + 1 < MAX_DEPTH) {
					cloned.additionalProperties = OpenAPIUtils.cleanSchema(schema.additionalProperties, level + 1);
				}
			}
			['allOf', 'anyOf', 'oneOf'].forEach(function (arrayOf) {
				if (!schema[arrayOf]) {
					return;
				}
				cloned[arrayOf] = [];
				schema[arrayOf].forEach(function (item) {
					if (level + 1 < MAX_DEPTH) {
						cloned[arrayOf].push(OpenAPIUtils.cleanSchema(item, level + 1));
					}
				});
			});
			if (schema.not) {
				if (schema.not instanceof Array) {
					cloned.not = [];
				} else {
					cloned.not = {};
				}
				if (level + 1 < MAX_DEPTH) {
					cloned.not = OpenAPIUtils.cleanSchema(schema.not, level + 1);
				}
			}
			if (schema.type === 'array' && schema.items) {
				cloned.items = {};
				if (level + 1 < MAX_DEPTH) {
					// If type is array, then sanitize array items
					cloned.items = OpenAPIUtils.cleanSchema(schema.items, level + 1);
				}
			}
			_removeFormats(cloned);
			cloned = _pickSchemaRelevant(cloned, ['schema', 'id', '$ref']);
			return cloned;
		}

		/**
   * Cleans all x- extensions from a supplied swagger document.  Does not modify the
   * original document.  Note that this can cause an issue if a $ref is referencing
   * any x- extension (e.g. evil.json /thingyref).  The swagger document should be
   * dereferenced prior to cleaning.
   * @param {string} swagger - The swagger document to clean.
   * @returns {object} - The cleaned swagger document.
   */

	}, {
		key: 'cleanExtensions',
		value: function cleanExtensions(swagger) {
			var type = typeof swagger === 'undefined' ? 'undefined' : _typeof(swagger);
			if (type !== 'object' || swagger === null) {
				return swagger;
			}
			var cloned = void 0;
			if (type === 'object' && swagger instanceof Array) {
				cloned = swagger.slice(0);
			} else {
				cloned = Object.assign({}, swagger);
			}
			Object.keys(cloned).forEach(function (key) {
				var item = cloned[key];
				if (key.startsWith('x-')) {
					delete cloned[key];
				} else if ((typeof item === 'undefined' ? 'undefined' : _typeof(item)) === 'object') {
					cloned[key] = OpenAPIUtils.cleanExtensions(item);
				}
			});
			return cloned;
		}

		/**
   * Method to create custom operationID-like operation id.
   * @param  {string} path   - The swagger path (eg. /thing)
   * @param  {string} method - The swagger method/verb (eg. "GET")
   * @return {string} The custom operationID
   */

	}, {
		key: 'generateFunctionName',
		value: function generateFunctionName(path, method) {
			var parts = path.split(/\//g);
			if (parts.length && parts[0] === '') {
				parts.shift();
			}
			var parsed = parts.reduce(function (acc, cur) {
				if (cur.startsWith('{')) {
					reSwaggerParam.lastIndex = 0;
					var match = reSwaggerParam.exec(cur);
					reParamName.lastIndex = 0;
					match[1].split(reParamName).forEach(function (a) {
						acc.params.push(capitalize(a));
					});
				} else {
					reParamName.lastIndex = 0;
					cur.split(reParamName).forEach(function (a) {
						acc.slugs.push(capitalize(a));
					});
				}
				return acc;
			}, {
				slugs: [],
				params: []
			});
			if (!parsed.params.length) {
				return method.toLowerCase() + parsed.slugs.join('');
			} else {
				return '' + method.toLowerCase() + parsed.slugs.join('') + 'By' + parsed.params.join('');
			}
		}
	}]);

	return OpenAPIUtils;
}();

exports = module.exports = OpenAPIUtils;