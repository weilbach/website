'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Swagger = require('openapi-doc');
var NotFoundError = require('../errors/NotFoundError');
var safeFilename = require('../util').safeFilename;
var modelflows = require('./modelflows');
var modelEndpoints = require('./modelendpoints');

var ACTION_MAP = {
	findById: 'findByIDAPI',
	findOne: 'findByIDAPI'
};

/**
 * Helper for generating standard Endpoints from a Model definition.
 * @public
 */

var ModelEndpointGenerator = function () {
	function ModelEndpointGenerator(arrow, modelName) {
		_classCallCheck(this, ModelEndpointGenerator);

		this.arrow = arrow;
		this.logger = arrow.logger;
		this.model = arrow.getModel(modelName);

		if (!this.model) {
			throw new NotFoundError('Model ' + modelName + ' not found.');
		}

		// Load the models referenced through composition.
		this.models = this.getReferencedModels(this.model, _defineProperty({}, modelName, this.model));
		this.supportedAPIs = this.getSupportedAPIDefs();
	}

	/**
  * Get the names of all the models referenced by this model.
  * @param {object} model - the model to check
  * @param {array} models -
  * @returns {object} models referenced by the original
  */


	_createClass(ModelEndpointGenerator, [{
		key: 'getReferencedModels',
		value: function getReferencedModels(model, models) {
			var _this = this;

			var referencedModelNames = new Set(Object.keys(model.fields).map(function (fieldName) {
				return model.fields[fieldName];
			}).filter(function (field) {
				return field.model && (field.type === 'array' || field.type === Array || field.type === 'object' || field.type === Object);
			}).map(function (field) {
				return field.model;
			}).filter(function (modelName) {
				return !models || !models.hasOwnProperty(modelName);
			}));

			var referencedModels = [].concat(_toConsumableArray(referencedModelNames)).map(function (refModelName) {
				var m = _this.arrow.getModel(refModelName);
				if (!m) {
					throw new NotFoundError('Model ' + refModelName + ' not found.');
				}
				return m;
			});

			// Add the referenced models
			models = models || {};
			referencedModels.forEach(function (m) {
				models[m.name] = m;
			});

			// Look for nested dependencies
			referencedModels.forEach(function (m) {
				_this.getReferencedModels(m, models);
			});

			return models;
		}

		/**
   * Get the APIs that are supported by the model.
   * @returns {object} sipported api definitions
   */

	}, {
		key: 'getSupportedAPIDefs',
		value: function getSupportedAPIDefs() {
			var _this2 = this;

			var defs = {};

			// Reusing the existing CRUD->API support here
			// to get the metadata for Endpoint creation.
			for (var key in this.model) {
				// Limiting to CRUD APIs defined in Model base and not extended
				// APIs added by custom models/connectors.
				if (key.slice(-3) === 'API') {
					// Some connectors use old mappings, to maintain support remap to the standard action.
					var name = key.slice(0, -3);
					if (this.model[name] && Object.getPrototypeOf(this.model).hasOwnProperty(name)) {
						// Check to see if the underlying connector has the necessary methods to support this API.
						var apiDef = this.model[key]();
						var reqConnectorMethods = apiDef.dependsOnAny || apiDef.dependsOnAll || [name];
						var connectorMethods = reqConnectorMethods.filter(function (method) {
							return !!_this2.model.getConnector()[method];
						});

						if (connectorMethods.length >= (apiDef.dependsOnAll ? reqConnectorMethods.length : 1)) {
							var action = ACTION_MAP[name] || key;
							defs[action] = apiDef;
						} else {
							this.logger.warn('API not supported on Connector: ' + name);
						}
					} else {
						this.logger.warn('API not supported on Model: ' + name);
					}
				}
			}
			return defs;
		}

		/**
   * Generate the standard endpoints for the model.
   * @param {string} name - The endpoint name.
   * @param {string} description - The endpoint description.
   * @return {object} - The swagger object for the model endpoints.
   */

	}, {
		key: 'generateEndpoint',
		value: function generateEndpoint(name, description) {
			var _this3 = this;

			// Create the Swagger for each API supported by the model
			var swagger = new Swagger();
			swagger.info(name || (this.model.singular || this.model.name) + ' API', '1.0.0', description);
			swagger.basePath('/endpoints');
			var schemaId = this.arrow.getModelSchemaId(this.model);
			Object.keys(this.supportedAPIs).forEach(function (apiName) {
				if (modelEndpoints[apiName]) {
					var opId = _this3.getOperationId(_this3.model, _this3.getAPIPath(apiName), _this3.supportedAPIs[apiName]);
					var flow = _this3.getFlowName(name, apiName);
					swagger.merge(modelEndpoints[apiName](flow, opId, schemaId, _this3.model));
					swagger.extension('x-flow', flow);
				}
			});

			return swagger.apidoc();
		}

		/**
   * Generate the standard flows for the model apis.
   * @param {string} endpointName - The name of the endpoint.
   * @return {object} - The map of flows to support the endpoint apis.
   */

	}, {
		key: 'generateFlows',
		value: function generateFlows(endpointName) {
			var _this4 = this;

			var flows = {};

			Object.keys(this.supportedAPIs).forEach(function (apiName) {
				var flowName = _this4.getFlowName(endpointName, apiName);

				if (modelflows.hasOwnProperty(apiName)) {
					flows[flowName] = modelflows[apiName](flowName, _this4.model);
				}
			});
			return flows;
		}

		/**
   * Get the appropriate name to use for the flow.
   * @param {string} endpointName - the name of the endpoint
   * @param {string} apiName - the name of the API
   * @returns {string} the safe name of the flow
   */

	}, {
		key: 'getFlowName',
		value: function getFlowName(endpointName, apiName) {
			return safeFilename(endpointName) + '-' + apiName.slice(0, -3);
		}

		/**
   * Get the path for the model api.
   * @param {string} apiName - The api to get the path for.
   * @return {string} - The api path.
   */

	}, {
		key: 'getAPIPath',
		value: function getAPIPath(apiName) {
			var apiDetail = this.supportedAPIs[apiName];
			var name = this.model.name.replace(/^.*?\//, '').toLowerCase();
			var apiPath = '/' + name;
			if (apiDetail.path) {
				if (apiDetail.path.startsWith('./')) {
					apiPath += apiDetail.path.substr(1);
				} else {
					apiPath += apiDetail.path;
				}
			}
			return apiPath;
		}

		/**
   * Get the operation id.
   * @param {Model} model - The model the endpoints are being generated for.
   * @param {string} apiPath - The path the endpoint is going to advertise.
   * @param {object} apiDetail - The API details for the model method.
   * @return {string} - The operation id.
   */

	}, {
		key: 'getOperationId',
		value: function getOperationId(model, apiPath, apiDetail) {
			return apiDetail.nickname ? apiDetail.nickname + ' ' + model.singular : apiDetail.method + ' ' + apiPath;
		}
	}]);

	return ModelEndpointGenerator;
}();

exports = module.exports = ModelEndpointGenerator;