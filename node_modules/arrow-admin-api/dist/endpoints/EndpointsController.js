'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var async = require('async');
var fs = require('fs');
var path = require('path');
var request = require('request');

var _require = require('../util'),
    mkdirIfNotExists = _require.mkdirIfNotExists,
    safeFilename = _require.safeFilename,
    writeJSONFile = _require.writeJSONFile,
    writeUniqueJSONFile = _require.writeUniqueJSONFile,
    isSafeFilename = _require.isSafeFilename;

var OpenAPIUtils = require('../openapi-utils');
var sampleFromSchema = require('./mockUtils');
var ModelEndpointGenerator = require('./ModelEndpointGenerator');

var _require2 = require('../errors'),
    BadRequestError = _require2.BadRequestError,
    NotFoundError = _require2.NotFoundError,
    ForbiddenError = _require2.ForbiddenError,
    PayloadTooLargeError = _require2.PayloadTooLargeError,
    InternalServerError = _require2.InternalServerError,
    ExtendableError = _require2.ExtendableError;

var makeParameter = function makeParameter(value, param) {
	var type = void 0;
	if (typeof value === 'string') {
		type = 'string';
		value = value || '';
	} else if (typeof value === 'number') {
		type = 'number';
		value = value || 0;
	} else if (typeof value === 'boolean') {
		type = 'boolean';
	} else if (value instanceof Array) {
		type = 'array';
		value = value || [];
	} else if (value === null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
		type = 'null';
		value = null;
	} else {
		type = 'object';
		value = value || {};
	}
	return _extends({}, param, {
		value: JSON.stringify(value, null, 4),
		type: type
	});
};

var mockResponse = function mockResponse(swagger, operationId, code, response) {
	var flow = {
		schemaVersion: '2',
		name: operationId,
		start: 'http.setresponse.1',
		nodes: {
			'http.setresponse.1': {
				type: 'nodehandler://axway-flow/http',
				method: 'setresponse',
				name: 'Set HTTP Response',
				parameters: [],
				outputs: {
					next: {
						context: '$.response'
					}
				}
			}
		}
	};
	var parameters = flow.nodes['http.setresponse.1'].parameters;

	parameters.push({
		name: 'status',
		value: code === 'default' ? '200' : code,
		type: 'number'
	});
	if (response.headers) {
		var headers = Object.keys(response.headers);
		var headerObj = headers.reduce(function (acc, cur) {
			var name = cur.toLowerCase();
			if (name === 'location') {
				acc[name] = '/example/location';
			} else if (name === 'content-type') {
				acc[name] = 'application/json; charset=utf8';
			} else {
				acc[name] = sampleFromSchema(response.headers[cur], swagger);
			}
			return acc;
		}, {});
		parameters.push(makeParameter(headerObj, { name: 'headers' }));
	}
	if (response.schema) {
		var sample = sampleFromSchema(response.schema, swagger);
		parameters.push(makeParameter(sample, { name: 'body' }));
	}
	return flow;
};

function getEndpointFromSwagger(swaggerFile, eppath, method, cb) {
	fs.readFile(swaggerFile, 'utf8', function (err, content) {
		if (err) {
			return cb(err);
		}
		try {
			var endpoint = JSON.parse(content);
			var methodObj = endpoint.paths && endpoint.paths[eppath] && endpoint.paths[eppath][method];
			if (!methodObj) {
				return cb(new NotFoundError('Endpoint not found'));
			}
			cb(null, endpoint);
		} catch (ex) {
			return cb(ex);
		}
	});
}

/**
 * The controller implementing the actions for interacting with Endpoints.
 * @public
 */

var EndpointsController = function () {
	/**
     * Create a ProjectController.
     * @param {object} ctx - The context for this controller.
     * @param {express} ctx.app - The express application.
     * @param {string} ctx.prefix - The prefix bound to.
     * @param {Arrow} ctx.arrow - The Arrow server.
     * @param {boolean} ctx.devmode - Flag indicating if this is a devmode server.
     * @param {Swagger} ctx.swagger - openapi-doc instance.
     * @param {object} controllers - Additional controllers.
     */
	function EndpointsController(ctx, controllers) {
		_classCallCheck(this, EndpointsController);

		this.ctx = ctx;
		this.endpointsDir = path.resolve(path.join(this.ctx.arrow.config.dir || process.cwd(), 'endpoints'));
		this.flowsDir = path.resolve(path.join(this.ctx.arrow.config.dir || process.cwd(), 'flows'));
		this.logger = this.ctx.arrow.logger;
		this.controllers = controllers;
		// for tests :(
		this.writeUniqueJSONFile = writeUniqueJSONFile;
	}

	/**
  * Explict call to get the ModelGenerator to allow for easier testing.
  * @param {string} modelName - the model name
  * @returns {ModelEndpointGenerator}
  */


	_createClass(EndpointsController, [{
		key: '_createModelGenerator',
		value: function _createModelGenerator(modelName) {
			return new ModelEndpointGenerator(this.ctx.arrow, modelName);
		}

		/**
   * Remove the flow related extensions from the document.
   * @param {object} swagger - the swagger definition to clean
   * @returns {object} cleaned swagger doc
   */

	}, {
		key: '_cleanSwagger',
		value: function _cleanSwagger(swagger) {
			if (!swagger || (typeof swagger === 'undefined' ? 'undefined' : _typeof(swagger)) !== 'object') {
				throw new TypeError('Invalid parameter "swagger"');
			}
			return JSON.parse(JSON.stringify(swagger, function (key, value) {
				if (['x-flow', 'x-enabled'].indexOf(key) === -1) {
					return value;
				}
			}));
		}

		/**
   * Fetches data from a URL and makes sure that it doesn't exceed the set limit.
   *
   * @param {string} url - url to get data from
   * @param {number} [maxSize=10,000,000] - max download size in bytes
   * @returns {Promise}
   */

	}, {
		key: '_fetchURLData',
		value: function _fetchURLData(url) {
			var maxSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10 * 1000 * 1000;

			return new Promise(function (resolve, reject) {
				request.head(url, function (err, response) {
					if (err) {
						return resolve();
					}
					var size = response.headers['Content-Length'];
					if (size && size > maxSize) {
						return reject(new PayloadTooLargeError('File size too large: Size ' + size + 'B, Max size ' + maxSize + 'B'));
					}
					return resolve();
				});
			}).then(function () {
				return new Promise(function (resolve, reject) {
					var str = '';
					var size = 0;
					var req = request.get(url, {
						headers: {
							Accept: 'application/json'
						}
					});
					req.on('data', function (data) {
						size += data.length;
						if (size > maxSize) {
							req.abort();
							return reject(new PayloadTooLargeError('File size too large: Current stream ' + size + 'B, Max size ' + maxSize + 'B'));
						}
						str += data.toString();
					});
					req.on('error', function (err) {
						return reject(err);
					});
					req.on('end', function () {
						return resolve(str);
					});
				});
			});
		}

		/**
   * Validates a swagger document
   *
   * @param {string|object} data - swagger document
   * @returns {object} { valid: {boolean} swagger: {object} } - swagger is returned when valid
   */

	}, {
		key: '_validateSwagger',
		value: function _validateSwagger(data) {
			var _this = this;

			return new Promise(function (resolve) {
				var swagger = data;
				if (typeof data === 'string') {
					try {
						swagger = JSON.parse(data);
					} catch (ex) {
						resolve({ valid: false });
						return;
					}
				}
				_this.ctx.arrow.validateSwagger(swagger).then(function (api) {
					return resolve({
						valid: true,
						swagger: swagger,
						dereferencedSwagger: api
					});
				}, function (err) {
					_this.logger.info('Swagger validation failed: ' + err);
					return resolve({
						valid: false
					});
				});
			});
		}

		/*
   * Upload a swagger/endpoint definition or pull from a URL, validate it and return it.
   */

	}, {
		key: 'validateEndpoint',
		value: function validateEndpoint(fields, files) {
			var _this2 = this;

			return new Promise(function (resolve, reject) {
				if (files.file) {
					// get data from endpoint
					return fs.readFile(files.file.file, function (err, data) {
						if (err) {
							return reject(err);
						}
						return resolve(data.toString());
					});
				} else if (fields.url) {
					// get data from url
					var cfg = _this2.ctx.arrow.config;
					var limit = cfg && cfg.admin && cfg.admin.request && cfg.admin.request.limit;
					return _this2._fetchURLData(fields.url.value, limit).then(resolve, reject);
				}
				return reject(new BadRequestError('Missing parameter "file"'));
			}).then(function (data) {
				return _this2._validateSwagger(data);
			});
		}
	}, {
		key: 'createEndpoint',
		value: function createEndpoint(params) {
			var _this3 = this;

			if (!params.swagger) {
				return Promise.reject(new BadRequestError('Missing parameter "swagger"'));
			}
			return this._validateSwagger(params.swagger).then(function (res) {
				if (!res.valid) {
					throw new BadRequestError('Invalid parameter "swagger"');
				}
				return _this3._cleanSwagger(res.swagger);
			}).then(function (swagger) {
				return new Promise(function (resolve, reject) {
					var group = safeFilename(swagger.info.title);
					var alltasks = [function (next) {
						fs.stat(path.join(_this3.endpointsDir, group + '.json'), function (err) {
							if (!err) {
								// a file exists
								_this3.logger.error('Endpoint already exists: ' + group);
								return reject(new ForbiddenError('The endpoint already exists.'));
							}
							next();
						});
					}, function (next) {
						return mkdirIfNotExists(_this3.endpointsDir, next);
					}];
					var bindSwagger = _this3._cleanSwagger(params.swagger);
					var mockflows = Promise.resolve();
					if (params.mock) {
						mockflows = _this3.generateMockFlowsForEndpoint(group, swagger, bindSwagger).then(function (tasks) {
							// mush all the tasks together
							tasks.forEach(function (a) {
								alltasks = alltasks.concat(a.pre);
							});
							tasks.forEach(function (a) {
								alltasks = alltasks.concat(a.update);
							});
							tasks.forEach(function (a) {
								alltasks = alltasks.concat(a.post);
							});
						}).catch(reject);
					}
					mockflows.then(function () {
						alltasks.push(function (next) {
							return _this3.writeUniqueJSONFile(_this3.endpointsDir, group,
							// save the *original* swagger, cleaned and bound
							bindSwagger, next);
						});
						// Write the files
						async.series(alltasks, function (err, results) {
							if (err) {
								if (err instanceof ExtendableError) {
									return reject(err);
								} else {
									return reject(new InternalServerError(err));
								}
							}
							// get ID from the last results to resolve (endpoint fn)
							var id = path.basename(results.pop(), '.json');
							return resolve(id);
						});
					}).catch(reject);
				});
			});
		}

		/**
   * Generate the endpoint.
   * @param {object} params - params for endpoint
   * @returns {Promise}
   */

	}, {
		key: 'generateEndpoints',
		value: function generateEndpoints(params) {
			var _this4 = this;

			return new Promise(function (resolve, reject) {
				if (params && params.name && params.model) {
					try {
						var safeName = safeFilename(params.name) + '.json';
						var endpointFilePath = path.join(_this4.endpointsDir, safeName);

						var generator = _this4._createModelGenerator(params.model);
						var endpointSwagger = generator.generateEndpoint(params.name, params.description);
						var flowDefinitions = generator.generateFlows(params.name);

						var fileData = [{ path: endpointFilePath, content: endpointSwagger }];
						Object.keys(flowDefinitions).forEach(function (name) {
							fileData.push({
								path: path.join(_this4.flowsDir, name + '.json'),
								content: flowDefinitions[name]
							});
						});

						// Write the files
						var writeTasks = [function (next) {
							return mkdirIfNotExists(_this4.endpointsDir, next);
						}, function (next) {
							return mkdirIfNotExists(_this4.flowsDir, next);
						}];
						fileData.forEach(function (file) {
							writeTasks.push(function (next) {
								writeJSONFile(file.path, file.content, next);
							});
						});

						async.series(writeTasks, function (err) {
							if (err) {
								reject(err);
							} else {
								resolve(path.basename(endpointFilePath, path.extname(endpointFilePath)));
							}
						});
					} catch (err) {
						reject(err);
					}
				} else {
					reject(new BadRequestError());
				}
			});
		}

		/**
   * Produces mock flows for a swagger definition
   * @param {object} swagger - swagger document
   * @returns {Promise}
   */

	}, {
		key: 'mockEndpoints',
		value: function mockEndpoints(swagger) {
			var _this5 = this;

			return new Promise(function (resolve, reject) {
				if (!swagger || (typeof swagger === 'undefined' ? 'undefined' : _typeof(swagger)) !== 'object') {
					return reject(new BadRequestError('Missing parameter'));
				}
				var data = [];
				Object.keys(swagger.paths).forEach(function (spath) {
					if (spath.startsWith('x-')) {
						return;
					}
					Object.keys(swagger.paths[spath]).forEach(function (verb) {
						if (verb.startsWith('x-') || verb === 'parameters') {
							return;
						}
						var operationId = swagger.paths[spath][verb].operationId;
						if (!operationId || !isSafeFilename(operationId)) {
							operationId = OpenAPIUtils.generateFunctionName(spath, verb);
						}
						_this5.logger.trace('mocking endpoint ' + verb + ' ' + spath + ' as "' + operationId + '"');

						var codes = Object.keys(swagger.paths[spath][verb].responses).sort(function (a, b) {
							if (b.startsWith('x-')) {
								return -1;
							}
							// there "should be one response code" and that should have
							// precedence over 'default'.
							if (a < b || b === 'default') {
								return -1;
							}
							return 0;
						});
						var code = codes.shift(); // pull first code
						var response = swagger.paths[spath][verb].responses[code];
						var mock = mockResponse(swagger, operationId, code, response);
						data.push({
							path: spath,
							method: verb,
							flow: mock
						});
					});
				});
				resolve(data);
			});
		}

		/**
   * Generate mock flows for an endpoint.
   * @param {string} group - The group name, i.e. safeFilename(swagger.info.title)
   * @param {object} swagger - The resolved swagger to mock.
   * @param {object} bindSwagger - The original swagger document to bind.
   * @return {Promise<array>} A promise to the array of tasks (pre, update, post).
   */

	}, {
		key: 'generateMockFlowsForEndpoint',
		value: function generateMockFlowsForEndpoint(group, swagger, bindSwagger) {
			var _this6 = this;

			return new Promise(function (resolve, reject) {
				// mock all the endpoints
				return _this6.mockEndpoints(swagger).then(function (data) {
					// for each endpoint mocked, bind to the flow which generates all of the
					// tasks to complete the operation.  the 'pre' tasks will check for files;
					// the 'update' tasks will write files; and the 'post' tasks will update
					// the endpoint.
					return Promise.all(data.map(function (item) {
						return _this6._bindFlowToEndpoint(bindSwagger, _extends({
							group: group
						}, item, {
							tasks: {
								pre: [],
								update: [],
								post: []
							}
						}));
					})).then(resolve, reject);
				});
			});
		}

		/*
   * Returns an array of summaries (group name, endpoint count)
   * for each API group
   */

	}, {
		key: 'getEndpointSummaries',
		value: function getEndpointSummaries() {
			var _this7 = this;

			return new Promise(function (resolve) {
				var endpoints = _this7.ctx.arrow.getEndpoints();
				var summaries = Object.keys(endpoints).map(function (apiName) {
					var endpoint = endpoints[apiName];
					return {
						id: apiName,
						name: endpoint.info.title,
						endpointCount: Object.keys(endpoint.paths).filter(function (part) {
							return !/^x-/.test(part);
						}).map(function (part) {
							return Object.keys(endpoint.paths[part]).length;
						}).reduce(function (pre, cur) {
							return pre + cur;
						}),
						description: endpoint.info.description,
						status: !endpoint.hasOwnProperty('x-enabled') ? {
							enabled: true
						} : _extends({}, endpoint['x-enabled'])
					};
				});
				resolve(summaries);
			});
		}

		/**
   * Get API endpoints
   * @param {string} groupName - The name of the API endpoint group
   * @returns {Promise}
   */

	}, {
		key: 'getEndpoints',
		value: function getEndpoints(groupName) {
			var _this8 = this;

			return new Promise(function (resolve, reject) {
				if (!groupName) {
					return reject(new BadRequestError());
				}
				var endpoints = _this8.ctx.arrow.getEndpoints();
				if (!endpoints.hasOwnProperty(groupName)) {
					return reject(new NotFoundError());
				}
				return resolve(endpoints[groupName]);
			});
		}

		/**
   * delete a method from and api group on some endpoint
   * @param  {object} params - contains api group, path within the group, and method
   * @returns {Promise}
   */

	}, {
		key: 'deleteEndpoint',
		value: function deleteEndpoint() {
			var _this9 = this;

			var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

			return new Promise(function (resolve, reject) {
				if (!params.group || !params.path || !params.method) {
					var paramError = new BadRequestError('Missing parameter');
					_this9.logger.error(paramError.message);
					return reject(paramError);
				}

				var tasks = [];
				var endpointPath = params.path;
				var method = params.method;
				var fileName = params.group + '.json';
				var endpointFilePath = path.join(_this9.endpointsDir, fileName);

				// Update the endpoint definition and write it to the fs
				var deleteEndpointMethod = function deleteEndpointMethod(endpointToDelete, next) {
					delete endpointToDelete.paths[endpointPath][method];
					fs.writeFile(endpointFilePath, JSON.stringify(endpointToDelete, null, 2), {
						flag: 'w',
						encoding: 'utf-8',
						mode: 384
					}, function (err) {
						if (err) {
							next(err);
						} else {
							next();
						}
					});
				};

				tasks.push(getEndpointFromSwagger.bind(null, endpointFilePath, endpointPath, method));
				tasks.push(deleteEndpointMethod);

				return async.waterfall(tasks, function (err) {
					if (err) {
						_this9.logger.error(err);
						if (err instanceof ExtendableError) {
							reject(err);
						} else {
							reject(new InternalServerError());
						}
					} else {
						resolve();
					}
				});
			});
		}

		/**
   * Binds a flow to an endpoint (swagger) definition, and resolves with the set of
   * tasks to complete that binding where pre-tasks check directories and existing
   * files, update-tasks write the files, and post-tasks complete the binding.
   *
   * @param {object} endpoint - the endpoint to bind flow to
   * @param {object} [params] - Bind parameters
   * @param {string} params.group - The endpoint group name
   * @param {string} params.path - The endpoint path to bind
   * @param {string} params.method - The endpoint method to bind (e.g. "post")
   * @param {object} params.tasks - An object of 3 arrays, `pre`, `update`, and `post`
   * @param {object} params.flow - The flow object to bind.
   * @return {Promise<object>} A promise to the tasks.
   */

	}, {
		key: '_bindFlowToEndpoint',
		value: function _bindFlowToEndpoint(endpoint) {
			var _this10 = this;

			var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

			return new Promise(function (resolve, reject) {
				var names = ['group', 'path', 'method', 'flow', 'tasks'];
				var name = names.find(function (a) {
					return !params[a];
				});
				if (name) {
					var paramError = new BadRequestError('Missing parameter: ' + name);
					_this10.logger.error(paramError.message);
					return reject(paramError);
				}

				var operation = endpoint.paths[params.path][params.method];

				var operationId = operation.operationId;
				if (!operationId || !isSafeFilename(operationId)) {
					operationId = OpenAPIUtils.generateFunctionName(params.path, params.method);
				}
				var flowId = params.group + '-' + operationId;

				// Check that a flow with that ID does not exist.
				params.tasks.pre.push(function (next) {
					_this10.controllers.flowsController.exists(flowId).then(function (exists) {
						if (exists) {
							_this10.logger.error('Flow already exists: ' + flowId);
							return next(new ForbiddenError('A flow already exists.'));
						} else if (operation['x-flow']) {
							_this10.logger.error('Endpoint already bound to a flow: ' + operation['x-flow']);
							return next(new ForbiddenError('Endpoint already bound to a flow.'));
						}
						if (!isSafeFilename(flowId)) {
							_this10.logger.error('Not a safe flow filename: ' + flowId);
							return next(new ForbiddenError('Flow filename can only contain alpha-numeric, underscores, and dashes.'));
						}
						next();
					}).catch(next);
				});

				// Write the new flow
				params.tasks.update.push(function (next) {
					// Update the endpoint flowId
					operation['x-flow'] = flowId;
					// save the flow
					_this10.controllers.flowsController.saveFlow(flowId, params.flow).then(next).catch(next);
				});

				resolve(params.tasks);
			});
		}

		/**
   * Binds a flow to an existing endpoint file (swagger) definition.
   *
   * @param {object} [params] - Bind parameters
   * @param {string} params.group - The endpoint group name
   * @param {string} params.path - The endpoint path to bind
   * @param {string} params.method - The endpoint method to bind (e.g. "post")
   * @param {object} params.flow - The flow object to bind.
   * @return {Promise<object>} A promise to the tasks.
   */

	}, {
		key: 'bindFlow',
		value: function bindFlow() {
			var _this11 = this;

			var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

			return new Promise(function (resolve, reject) {
				var names = ['group', 'path', 'method', 'flow'];
				var name = names.find(function (a) {
					return !params[a];
				});
				if (name) {
					var paramError = new BadRequestError('Missing parameter: ' + name);
					_this11.logger.error(paramError.message);
					return reject(paramError);
				}

				// const tasks = [];
				var endpointPath = params.path;
				var method = params.method;
				var safeName = params.group + '.json';
				var endpointFilePath = path.join(_this11.endpointsDir, safeName);

				getEndpointFromSwagger(endpointFilePath, endpointPath, method, function (cberr, endpointToBind) {
					if (cberr) {
						_this11.logger.error(cberr);
						if (cberr instanceof ExtendableError) {
							return reject(cberr);
						} else {
							return reject(new InternalServerError());
						}
					}

					_this11._bindFlowToEndpoint(endpointToBind, _extends({}, params, {
						tasks: {
							pre: [
							// pre-task to check directory
							function (next) {
								return mkdirIfNotExists(_this11.flowsDir, next);
							}],
							update: [],
							post: [
							// final write to endpoint (this is done knowing that
							// _bindFlowToEndpoint does not write any post events).
							function (next) {
								return writeJSONFile(endpointFilePath, endpointToBind, next);
							}]
						}
					})).then(function (tasks) {
						var alltasks = tasks.pre.concat(tasks.update).concat(tasks.post);
						return async.series(alltasks, function (err) {
							if (err) {
								_this11.logger.error(err);
								if (err instanceof ExtendableError) {
									reject(err);
								} else {
									reject(new InternalServerError());
								}
							} else {
								resolve();
							}
						});
					});
				});
			});
		}
	}]);

	return EndpointsController;
}();

exports = module.exports = EndpointsController;