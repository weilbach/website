'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var schemas = require('axway-schema');
var jsonpointer = require('json-pointer');
var jsonschemafaker = require('json-schema-faker');
var OpenAPIUtils = require('../openapi-utils');

// Note on upgrade to json-schema-faker 5.x this all needs to be reviewed. We should
// probably consolidate on json-schema-ref-parser for all our schema parsing.
function faker(schema) {
	try {
		return jsonschemafaker(schema);
	} catch (err) {
		return null;
	}
}

function normalizeArray(arr) {
	if (Array.isArray(arr)) {
		return arr;
	}
	return [arr];
}

function getRefSchema(swagger, parent) {
	if (!parent.$ref) {
		return;
	}
	var refSchema = schemas.get(parent.$ref);
	if (!refSchema && parent.$ref.startsWith('#/')) {
		refSchema = jsonpointer.get(swagger, parent.$ref.substring(1));
	}
	return refSchema;
}

function getAllOfValue(schema, swagger, config, path) {
	var combined = void 0;
	for (var i = 0; i < schema.allOf.length; ++i) {
		var sub = schema.allOf[i];
		var sample = sampleFromSchema(sub, swagger, config, path);

		if (combined === undefined) {
			combined = sample;
			if ((typeof combined === 'undefined' ? 'undefined' : _typeof(combined)) !== 'object') {
				break;
			}
		} else if (sample && (typeof sample === 'undefined' ? 'undefined' : _typeof(sample)) === 'object') {
			combined = _extends({}, combined, sample);
		}
	}
	return combined;
}

// Resolve objects that are just { $ref: /foo }
function resolveRefObj(schema, swagger, path) {
	var loop = [].concat(_toConsumableArray(path));

	while (schema && schema.$ref) {
		if (loop.includes(schema.$ref)) {
			schema = null;
			break;
		}
		path.push(schema.$ref);
		schema = getRefSchema(swagger, schema);
	}
	return schema;
}

function sampleFromSchema(schema, swagger) {
	var config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	var path = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];

	// If it's allOf the build all the samples
	if (schema && schema.allOf) {
		return getAllOfValue(schema, swagger, config, path);
	}

	// If it's just a ref then get the refed schema
	schema = resolveRefObj(schema, swagger, path);

	if (!schema) {
		return;
	}

	var _schema = schema,
	    type = _schema.type;
	var _schema2 = schema,
	    example = _schema2.example,
	    properties = _schema2.properties,
	    additionalProperties = _schema2.additionalProperties,
	    items = _schema2.items;
	var includeReadOnly = config.includeReadOnly,
	    includeWriteOnly = config.includeWriteOnly;


	if (example !== undefined) {
		return example;
	}

	if (!type) {
		if (properties) {
			type = 'object';
		} else if (items) {
			type = 'array';
		} else {
			return;
		}
	}

	if (type === 'object') {
		var props = properties;
		var obj = {};
		for (var name in props) {
			if (!props.hasOwnProperty(name)) {
				continue;
			}

			var prop = props[name];
			if (prop.$ref && path.includes(prop.$ref) || path.includes(prop)) {
				// No cycles.
				continue;
			}

			if (prop.readOnly && !includeReadOnly) {
				continue;
			}
			if (prop.writeOnly && !includeWriteOnly) {
				continue;
			}

			var childPath = [].concat(_toConsumableArray(path), [prop.$ref || prop]);
			var objSchema = prop.$ref ? getRefSchema(swagger, prop) : prop;
			if (objSchema) {
				obj[name] = sampleFromSchema(objSchema, swagger, config, childPath);
			}
		}

		if (additionalProperties === true) {
			obj.additionalProp1 = {};
		} else if (additionalProperties) {
			var addProps = additionalProperties;
			var cycle = addProps.$ref && path.includes(addProps.$ref) || path.includes(addProps);

			if (!cycle) {
				var _childPath = [].concat(_toConsumableArray(path), [addProps.$ref || addProps]);
				var addSchema = addProps.$ref ? getRefSchema(swagger, addProps) : addProps;
				var additionalPropVal = sampleFromSchema(addSchema, swagger, config, _childPath);

				for (var i = 1; i < 4; i++) {
					obj['additionalProp' + i] = additionalPropVal;
				}
			}
		}
		return obj;
	}

	if (type === 'array') {
		if (items.$ref && path.includes(items.$ref) || path.includes(items)) {
			// No cycles.
			return [];
		}

		var _childPath2 = [].concat(_toConsumableArray(path), [items.$ref || items]);
		var arraySchema = items.$ref ? getRefSchema(swagger, items) : items;
		if (arraySchema) {
			return [sampleFromSchema(arraySchema, swagger, config, _childPath2)];
		} else {
			return [];
		}
	}

	if (schema.enum) {
		if (schema.hasOwnProperty('default')) {
			return schema.default;
		}
		return normalizeArray(schema.enum)[0];
	}

	if (type === 'file') {
		return;
	}

	return faker(OpenAPIUtils.cleanSchema(schema));
}

exports = module.exports = sampleFromSchema;