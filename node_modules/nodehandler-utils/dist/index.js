'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/**
 * @module nodehandler-utils
 * @typicalname nodehandler-utils
 * @exports nodehandler-utils
 *
 * @example <caption>Quick start</caption>
 * ```javascript
 *  const { NodeHandlerUtils } = require('nodehandler-utils');
 *  const { FlowManager } = require('axway-flow');
 *  const uri = FlowManager.formatNodeHandlerUri('service-connector', 'thing');
 *  const swagger = require('./thing.json');
 *  const spec =  NodeHandlerUtils.registerSchemas(swagger, 'thing');
 *  const spec =  NodeHandlerUtils.swaggerToNodeHandlerSpec(swagger, 'thing', uri, 'thing-icon');
 * ```
 */
var jsonpointer = require('json-pointer');
var schemas = require('axway-schema');
var jsonrefs = require('json-refs');
var capitalize = require('capitalize');

// http://json-schema.org/draft-06/schema properties
var draft06 = schemas.get('http://json-schema.org/draft-06/schema');
var draft06properties = Object.keys(draft06.properties);

var SWAGGER_EXTENSION = /^x-/;

function _pick(obj) {
	for (var _len = arguments.length, props = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
		props[_key - 1] = arguments[_key];
	}

	return Object.assign.apply(Object, [{}].concat(_toConsumableArray(props.map(function (prop) {
		if (obj[prop] !== undefined) {
			return _defineProperty({}, prop, obj[prop]);
		}
		return undefined;
	}))));
}

function _pickSchemaRelevant(obj, additionalProperties) {
	return _pick.apply(undefined, [obj].concat(_toConsumableArray(draft06properties), _toConsumableArray(additionalProperties)));
}

function _sanitize(str) {
	return str.replace(/[^a-z0-9_-]+/ig, '');
}

// found inspiration on stackoverflow, but cannot find the source.  merges
// two arrays of parameters using spread.  if duplicate parameter is found,
// it will replace the existing with the merged.  in other words, the last
// duplicate merged will win.
function _mergeParameters() {
	var _ref2;

	return (_ref2 = []).concat.apply(_ref2, arguments).reduce(function (result, current) {
		if (current === undefined) {
			return result;
		}
		var index = result.findIndex(function (a) {
			return a.name === current.name && a.in === current.in;
		});
		if (index === -1) {
			return result.concat(current);
		}
		// option to do Object.assign(result[index], current), but the
		// spec is unclear.  the parameter is "overriden at the operation
		// level", so I assume it means that its attributes are replaced
		// and not combined.
		result[index] = current;
		return result;
	}, []);
}

// I could find no restrictions on parameter names in Swagger, so I will assume they are
// all valid, and that ':' denotes a regex, e.g. {banana:[a-z]}.  The regex below will
// match any set of characters within brackets {}, but has an optional, non-capturing
// group that starts with ':'.
var reSwaggerParam = new RegExp(/{(.+?)(?::.*?)?}/g);
var reParamName = new RegExp(/[^a-zA-Z0-9]/g);
/**
 * Method to create custom operationID-like operation id. Taken from connectors team
 * NOTE: duplicated from code from arrow-admin-api/src/util.js,
 * @param  {string} swpath   - The swagger path (eg. /thing)
 * @param  {string} method - The swagger method/verb (eg. "GET")
 * @return {string} The custom operationID
 */
function generateFunctionName(swpath, method) {
	var parts = swpath.split(/\//g);
	if (parts.length && parts[0] === '') {
		parts.shift();
	}
	var parsed = parts.reduce(function (acc, cur) {
		if (cur.startsWith('{')) {
			reSwaggerParam.lastIndex = 0;
			var match = reSwaggerParam.exec(cur);
			reParamName.lastIndex = 0;
			match[1].split(reParamName).forEach(function (a) {
				acc.params.push(capitalize(a));
			});
		} else {
			reParamName.lastIndex = 0;
			cur.split(reParamName).forEach(function (a) {
				acc.slugs.push(capitalize(a));
			});
		}
		return acc;
	}, {
		slugs: [],
		params: []
	});
	if (!parsed.params.length) {
		return method.toLowerCase() + parsed.slugs.join('');
	} else {
		return '' + method.toLowerCase() + parsed.slugs.join('') + 'By' + parsed.params.join('');
	}
}

/**
 * Node handler utils
 * @public
 */

var NodeHandlerUtils = function () {
	function NodeHandlerUtils() {
		_classCallCheck(this, NodeHandlerUtils);
	}

	_createClass(NodeHandlerUtils, null, [{
		key: '_formatSchemaRef',

		/**
   * Converts conventional #/definitions refs to axway-schema.
   * @param	{string} ref - local json-pointer
   * @param	{string} svcname - name of the service connector
   * @return {string} axway-schema style id/ref
   * @private
   */
		value: function _formatSchemaRef(ref, svcname) {
			// Replace slashes and tilda
			var sanitizedSvcname = _sanitize(svcname);
			var sanitizedRef = _sanitize(ref.replace('#/definitions/', ''));
			// Convert to schema service URI
			return 'schema:///svc.' + sanitizedSvcname + '/' + sanitizedRef;
		}

		/**
   * Recursively sanitizes json-schema by removing non-json-schema properties.
   * @param	{object} schema - JSON schema object
   * @return {object} Sanatized json-schema
   * @private
   */

	}, {
		key: '_sanatizeSchema',
		value: function _sanatizeSchema(schema) {
			if (schema.in) {
				throw new Error('Invalid JSON schema object (this looks like a Swagger parameter): ' + JSON.stringify(schema));
			}
			// http://json-schema.org/latest/json-schema-validation.html#rfc.section.8.3
			var allowedFormats = ['date-time', 'email', 'hostname', 'ipv4', 'ipv6', 'uri', 'uri-reference', 'uri-template', 'json-pointer'];

			// Migrate to draft 6
			// http://json-schema.org/draft-06/json-schema-migration-faq.html
			// r.e. exclusiveMinimum & exclusiveMaximum:
			// 'wherever one of these would be true before, change the value to
			// the corresponding "minimum" or "maximum" value and remove the
			// "minimum"/"maximum" keyword'
			if (schema.exclusiveMaximum) {
				schema.exclusiveMaximum = schema.maximum;
				delete schema.maximum;
			} else {
				delete schema.exclusiveMaximum;
			}

			if (schema.exclusiveMinimum) {
				schema.exclusiveMinimum = schema.minimum;
				delete schema.minimum;
			} else {
				delete schema.exclusiveMinimum;
			}

			// http://json-schema.org/latest/json-schema-validation.html#rfc.section.6.25
			var allowedTypes = draft06.definitions.simpleTypes.enum;

			// Remove any formats that aren't json-schema compliant. Could update ajv with unknownFormats
			var _removeFormats = function _removeFormats(prop) {
				if (allowedFormats.indexOf(prop.format) < 0) {
					delete prop.format;
				}
			};

			// Only use json-schema compliant types. eg. disallow "type": "file"
			// This is a switch in case we want to cast any types later on
			var _castTypes = function _castTypes(prop) {
				if (allowedTypes.indexOf(prop.type) < 0) {
					// we can handle special non json-schema types as needed
					switch (prop.type) {
						case undefined:
							break;
						case 'file':
							// swagger defined
							prop.type = 'object';
							break;
						default:
							prop.type = 'string';
					}
				}
			};

			if (schema.type === 'object') {
				// If the property is of type `object` then we can expect either `properties` or
				// `additionalProperties` to be present.  If present, then those properties also
				// need to be sanitized.
				if (schema.properties) {
					Object.keys(schema.properties).forEach(function (propertyName) {
						schema.properties[propertyName] = NodeHandlerUtils._sanatizeSchema(schema.properties[propertyName]);
					});
				}
				if (schema.additionalProperties) {
					schema.additionalProperties = NodeHandlerUtils._sanatizeSchema(schema.additionalProperties);
				}
			} else if (schema.type === 'array' && schema.items) {
				// If type is array, then sanitize array items
				schema.items = NodeHandlerUtils._sanatizeSchema(schema.items);
			}

			_removeFormats(schema);
			_castTypes(schema);
			schema = _pickSchemaRelevant(schema, ['schema', 'id']);
			return schema;
		}

		/**
   * Method to create custom operationID-like operation id. Taken from connectors team
   * @param  {string} path   - The swagger path (eg. /thing)
   * @param  {string} method - The swagger method/verb (eg. "GET")
   * @return {string} The custom operationID
   * @private
   */

	}, {
		key: '_generateFunctionName',
		value: function _generateFunctionName(path, method) {
			return generateFunctionName(path, method);
		}

		/**
   * Converts swagger responses to returns spec.
   * @param	{object} swagger - swagger doc
   * @param	{object} method - swagger method
   * @param	{string} operationId - swagger method operation id
   * @return {object|array} oneOf schema object or object schema
   * @private
   */

	}, {
		key: '_swaggerResponsesToOutputs',
		value: function _swaggerResponsesToOutputs(swagger, method, operationId) {
			var outputs = {};

			var _loop = function _loop(code) {
				if (SWAGGER_EXTENSION.test(code)) {
					return 'continue';
				}
				var response = method.responses[code];

				if (response.$ref) {
					// dereference global response
					response = jsonpointer.get(swagger, response.$ref.substring(1));
				}

				// The idea here is to wrap an output item, for example:
				// {
				//    statusCode: 200,
				//    headers: { foo: 'bar' },
				//    data: { name: 'foo' }
				// }
				var output = outputs[code] = {
					schema: {
						type: 'object',
						properties: {
							statusCode: {
								type: 'integer',
								const: parseInt(code, 10)
							}
						},
						required: ['statusCode']
					}
				};

				// The status code should not be a const if the method uses `default` as return.
				if (code === 'default') {
					delete output.schema.properties.statusCode.const;
				}

				// Apply description if one is given
				if (response.description) {
					output.description = response.description;
				}

				// Make a context update for the response, e.g. $.findPetsByStatus.200
				output.context = '$.' + _sanitize(swagger.info.title) + '.' + _sanitize(operationId) + '.' + code;

				// If response has headers, add this to the wrapped object
				if (response.headers) {
					var sanitizedHeaders = Object.keys(response.headers).reduce(function (headers, header) {
						headers[header] = NodeHandlerUtils._sanatizeSchema(response.headers[header]);
						return headers;
					}, {});
					output.schema.properties.headers = {
						type: 'object',
						properties: _extends({}, sanitizedHeaders)
					};
					output.schema.required.push('headers');
				}

				if (response.schema) {
					// If we have a reference, then it should have been registered into
					// axway-schema by now
					if (response.schema.$ref) {
						output.schema.properties.data = {
							$ref: response.schema.$ref
						};
					} else {
						// If there is no reference just sanatize the schema
						output.schema.properties.data = _extends({}, NodeHandlerUtils._sanatizeSchema(response.schema));
					}
					output.schema.required.push('data');
				}
			};

			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = Object.keys(method.responses)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var code = _step.value;

					var _ret = _loop(code);

					if (_ret === 'continue') continue;
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}

			return outputs;
		}

		/**
   * Converts the swagger parameters to json-schema properties.
   * @param	{object} swagger - swagger doc
   * @param 	{string} name - The name of the node handler
   * @param	{object} verb - the method verb
   * @param	{object} path - the method path under swagger.paths
   * @return {object}	schema property
   * @public
   */

	}, {
		key: 'getSwaggerMethodAsProperties',
		value: function getSwaggerMethodAsProperties(swagger, name, verb, path) {
			var cswagger = JSON.parse(JSON.stringify(swagger));
			var method = cswagger.paths[path][verb];
			var safename = _sanitize(name);
			NodeHandlerUtils._rewriteRegisteredSchemaDefinitions(cswagger, safename);
			NodeHandlerUtils._mergeMethodParameters(cswagger);
			return NodeHandlerUtils._getSwaggerMethodAsProperties(cswagger, method);
		}

		/**
   * Converts the swagger parameters to json-schema properties.
   * @param	{object} swagger - swagger doc
   * @param	{object} method	- swagger method object
   * @return {object}	schema property
   * @private
   */

	}, {
		key: '_getSwaggerMethodAsProperties',
		value: function _getSwaggerMethodAsProperties(swagger, method) {
			var properties = {};
			var required = [];
			if (method.parameters) {
				var _loop2 = function _loop2(_parameter) {
					// store these original values as the parameter can get reset if the parameter has
					// a schema (below).
					var orig = {
						required: _parameter.required,
						in: _parameter.in
					};

					// Delete the swagger required property
					delete _parameter.required;

					if (_parameter.schema) {
						// If the parameter has a schema, then it effectively ceases to be a swagger
						// parameter and becomes a schema, and should be treated as such.  e.g. a body
						// param that has `schema` does not have a type, the type is in `schema`,
						// however, the swagger parameter may have a name and description (if present,
						// description should be used in preference to the schema description).
						_parameter = Object.assign({
							name: _parameter.name,
							description: _parameter.description
						}, _parameter.schema);
					}

					// count duplicate parameters
					var count = method.parameters.filter(function (a) {
						return a.name === _parameter.name;
					}).length;

					// Swagger defines unique parameters as `in` and `name`, which causes conflict
					// when converting to properties.  Disambigulate the property name by prefixing `in.`.
					var propertyName = count === 1 ? _parameter.name : orig.in + '.' + _parameter.name;

					// Convert the parameter to a poperty by filtering out the non-schema related bits.
					var property = _pickSchemaRelevant(_parameter, ['schema', 'id']);

					// Sanitize the property as JSON schema
					properties[propertyName] = _extends({}, NodeHandlerUtils._sanatizeSchema(property));

					if (orig.required) {
						required.push(propertyName);
					}
					parameter = _parameter;
				};

				var _iteratorNormalCompletion2 = true;
				var _didIteratorError2 = false;
				var _iteratorError2 = undefined;

				try {
					for (var _iterator2 = method.parameters[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
						var parameter = _step2.value;

						_loop2(parameter);
					}
				} catch (err) {
					_didIteratorError2 = true;
					_iteratorError2 = err;
				} finally {
					try {
						if (!_iteratorNormalCompletion2 && _iterator2.return) {
							_iterator2.return();
						}
					} finally {
						if (_didIteratorError2) {
							throw _iteratorError2;
						}
					}
				}
			}
			return {
				type: 'object',
				additionalProperties: false,
				properties: properties,
				required: required
			};
		}

		/**
   * Generates a spec for every path/verb pair
   * @param  {object} swagger     - A swagger document
   * @param  {object} method      - The method object under verb
   * @param  {string} description - The description for the path/verb
   * @param  {string} operationId - The method operation name
   * @return {object}             The full spec for the path/verb
   * @private
   */

	}, {
		key: '_generateSpec',
		value: function _generateSpec(swagger, method, description, operationId) {
			return {
				description: description,
				parameter: NodeHandlerUtils._getSwaggerMethodAsProperties(swagger, method),
				outputs: NodeHandlerUtils._swaggerResponsesToOutputs(swagger, method, operationId)
			};
		}

		/**
   * Rewrites swagger to use axway-schema references.
   * @param {object} swagger - A swagger document
   * @param {string} name - The service name to use for rewriting
   * @private
   */

	}, {
		key: '_rewriteRegisteredSchemaDefinitions',
		value: function _rewriteRegisteredSchemaDefinitions(swagger, name) {
			var refs = jsonrefs.findRefs(swagger, {
				filter: function filter(ref) {
					return ref.uri.startsWith('#/definitions');
				}
			});
			var toremove = new Set();
			Object.keys(refs).forEach(function (refPath) {
				var ref = refs[refPath].uri;
				// ensure the ref exists (will throw)
				jsonpointer.get(swagger, ref.substring(1));
				toremove.add(ref.substring(1));
				refs[refPath].def.$ref = NodeHandlerUtils._formatSchemaRef(refs[refPath].uri, name);
			});
			// delete all of the "registered" definitions that have been rewritten
			toremove.forEach(function (a) {
				return jsonpointer.remove(swagger, a);
			});
		}

		/**
   * Merges method parameters from path item parameter list, and also dereferences any from the
   * global parameter list to produce a single parameter list that can be used as a source of
   * truth for the method.
   *
   * The path item parameters are defined:
   *     | A list of parameters that are applicable for all the operations described under
   *     | under this path. These parameters can be overridden at the operation
   *     | level, but cannot be removed there.
   * Source: https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#path-item-object
   *
   * @param {object} swagger - The swagger document to convert
   * @private
   */

	}, {
		key: '_mergeMethodParameters',
		value: function _mergeMethodParameters(swagger) {
			var _iteratorNormalCompletion3 = true;
			var _didIteratorError3 = false;
			var _iteratorError3 = undefined;

			try {
				for (var _iterator3 = Object.keys(swagger.paths)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
					var mpath = _step3.value;

					if (SWAGGER_EXTENSION.test(mpath)) {
						continue;
					}
					if (swagger.paths[mpath].$ref) {
						swagger.paths[mpath] = jsonpointer.get(swagger, swagger.paths[mpath].$ref.substring(1));
					}

					// A list of parameters that are applicable for all the operations described
					// under this path. These parameters can be overridden at the operation
					// level, but cannot be removed there.
					var pathItemParameters = swagger.paths[mpath].parameters && swagger.paths[mpath].parameters.map(function (a) {
						if (a.$ref) {
							// dereference global parameter
							return jsonpointer.get(swagger, a.$ref.substring(1));
						}
						return a;
					});

					var _iteratorNormalCompletion4 = true;
					var _didIteratorError4 = false;
					var _iteratorError4 = undefined;

					try {
						for (var _iterator4 = Object.keys(swagger.paths[mpath])[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
							var verb = _step4.value;

							if (verb === 'parameters' || SWAGGER_EXTENSION.test(verb)) {
								continue;
							}

							var method = swagger.paths[mpath][verb];

							// dereference any method parameters
							method.parameters = method.parameters && method.parameters.map(function (a) {
								if (!a.$ref) {
									return a;
								}
								return jsonpointer.get(swagger, a.$ref.substring(1));
							});

							if (pathItemParameters) {
								var pparams = pathItemParameters.map(function (a) {
									if (!a.$ref) {
										return Object.assign({}, a);
									}
									return jsonpointer.get(swagger, a.$ref.substring(1));
								});
								method.parameters = _mergeParameters(pparams, method.parameters);
							}
						}
					} catch (err) {
						_didIteratorError4 = true;
						_iteratorError4 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion4 && _iterator4.return) {
								_iterator4.return();
							}
						} finally {
							if (_didIteratorError4) {
								throw _iteratorError4;
							}
						}
					}
				}
			} catch (err) {
				_didIteratorError3 = true;
				_iteratorError3 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion3 && _iterator3.return) {
						_iterator3.return();
					}
				} finally {
					if (_didIteratorError3) {
						throw _iteratorError3;
					}
				}
			}
		}

		/**
   * Converts a swagger definition to a node handler spec.  The `uri` uniquely identifies
   * the node handler, e.g. nodehandler://service-connector/foo (see `FlowManager.formatNodeHandlerUri`).
   * @param {object} swagger - The swagger document to convert
   * @param {string} name - The name of the node handler
   * @param {string} uri - The unique uri of the node handler
   * @param {string} [icon] - The node handler's icon (defaults to `glyphicon-link`).
   * @returns {object} node handler spec
   * @public
   */

	}, {
		key: 'swaggerToNodeHandlerSpec',
		value: function swaggerToNodeHandlerSpec(swagger, name, uri, icon) {
			if (!swagger) {
				throw new Error('missing required parameter: swagger');
			}
			if (!name) {
				throw new Error('missing required parameter: name');
			}
			if (!uri) {
				throw new Error('missing required parameter: uri');
			}
			var copied = JSON.parse(JSON.stringify(swagger));
			var safename = _sanitize(name);

			NodeHandlerUtils._rewriteRegisteredSchemaDefinitions(copied, safename);
			NodeHandlerUtils._mergeMethodParameters(copied);

			var spec = {
				schemaVersion: '1',
				type: uri,
				name: name,
				icon: icon || 'glyphicon-link',
				category: 'connector',
				methods: {}
			};

			var _iteratorNormalCompletion5 = true;
			var _didIteratorError5 = false;
			var _iteratorError5 = undefined;

			try {
				for (var _iterator5 = Object.keys(copied.paths)[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
					var mpath = _step5.value;

					if (SWAGGER_EXTENSION.test(mpath)) {
						continue;
					}
					var _iteratorNormalCompletion6 = true;
					var _didIteratorError6 = false;
					var _iteratorError6 = undefined;

					try {
						for (var _iterator6 = Object.keys(copied.paths[mpath])[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
							var verb = _step6.value;

							if (verb === 'parameters' || SWAGGER_EXTENSION.test(mpath)) {
								continue;
							}
							var method = copied.paths[mpath][verb];
							var customOperationID = method.operationId || NodeHandlerUtils._generateFunctionName(mpath, verb);
							spec.methods[customOperationID] = NodeHandlerUtils._generateSpec(copied, method, method.description || customOperationID, customOperationID);
						}
					} catch (err) {
						_didIteratorError6 = true;
						_iteratorError6 = err;
					} finally {
						try {
							if (!_iteratorNormalCompletion6 && _iterator6.return) {
								_iterator6.return();
							}
						} finally {
							if (_didIteratorError6) {
								throw _iteratorError6;
							}
						}
					}
				}
			} catch (err) {
				_didIteratorError5 = true;
				_iteratorError5 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion5 && _iterator5.return) {
						_iterator5.return();
					}
				} finally {
					if (_didIteratorError5) {
						throw _iteratorError5;
					}
				}
			}

			return spec;
		}

		/**
   * Registers schema using the`#/definitions` of a swagger document.
   * @param {object} swagger - The swagger document to use to register schemas
   * @param {string} name - The name of the node handler
   * @public
   */

	}, {
		key: 'registerSchemas',
		value: function registerSchemas(swagger, name) {
			if (!swagger.definitions) {
				return;
			}
			var copied = JSON.parse(JSON.stringify(swagger));
			var safename = _sanitize(name);

			var refs = jsonrefs.findRefs(copied.definitions, {
				filter: function filter(ref) {
					return ref.uri.startsWith('#/definitions');
				}
			});

			// Find all of the $refs in the (copied) swagger definitions section and
			// rewrite them to be axway-schema refs.
			Object.keys(refs).forEach(function (refPath) {
				var ref = refs[refPath].uri;
				var refID = NodeHandlerUtils._formatSchemaRef(ref, safename);
				refs[refPath].def.$ref = refID;
			});
			// For each definition, assign an identifier to the definition and register schema
			Object.keys(copied.definitions).forEach(function (key) {
				var refID = NodeHandlerUtils._formatSchemaRef(key, safename);
				var def = NodeHandlerUtils._sanatizeSchema(copied.definitions[key]);
				def.id = refID;
				schemas.add(def);
			});

			schemas.loadSync();
		}
	}]);

	return NodeHandlerUtils;
}();

exports = module.exports = NodeHandlerUtils;