/**
 * This code is closed source and Confidential and Proprietary to
 * Appcelerator, Inc. All Rights Reserved.  This code MUST not be
 * modified, copied or otherwise redistributed without express
 * written permission of Appcelerator. This file is licensed as
 * part of the Appcelerator Platform and governed under the terms
 * of the Appcelerator license agreement.
 */
var chalk = require('chalk'),
	dns = require('dns'),
	adminapi = require('arrow-admin-api'),
	AdminUI = require('arrow-admin-ui'),
	async = require('async'),
	merge = require('lodash.merge'),
	express = require('express'),
	filterIP = require('./filter-ip'),
	isipaddress = require('isipaddress');

var DEFAULT_ALLOWED_HOSTS = [ '127.0.0.1', '::1' ];

function Admin() {}

Admin.prototype.resolveAllowedHosts = function resolveAllowedHosts(arrow, config, next) {
	if (config.allowedHosts) {
		config.allowedHosts = typeof config.allowedHosts === 'string' ? [ config.allowedHosts ] : config.allowedHosts;
		var allowedIps = [];
		var tasks = [];

		function lookup(hostname, cb) {
			dns.lookup(hostname, { all: true }, function (err, addresses) {
				if (err) {
					arrow.logger.error('Error resolving ' + hostname, err);
					return cb(err);
				}
				addresses.forEach(function (detail) {
					arrow.logger.trace('Resolved ' + hostname + ' to ' + detail.address);
					allowedIps.push(detail.address);
				});
				cb();
			});
		}

		config.allowedHosts.forEach(function (host) {
			if (isipaddress.test(host)) {
				allowedIps.push(host);
			} else {
				tasks.push(function (cb) {
					lookup(host, cb);
				});
			}
		});

		async.series(tasks, function (err) {
			next(err, allowedIps);
		});
	} else {
		next(null, DEFAULT_ALLOWED_HOSTS);
	}
};

Admin.prototype.getAccessControlMiddleware = function getAccessControlMiddleware(arrow, allowedIps) {
	return filterIP.getMiddleware({
		allowedIps,
		log: arrow.logger.warn.bind(arrow.logger)
	});
};

/**
 * start the admin
 */
Admin.prototype.start = function (arrow, callback) {
	var app = arrow.app,
		apiprefix = '/adminapi/v1',
		uiPrefix = '/console',
		apiDocPrefix = '/apidoc',
		env = arrow.config.env,
		devmode = env === 'development',
		config = merge({
			apikey: arrow.config.apikey,
			apikey_production: arrow.config.apikey_production,
			apikey_preproduction: arrow.config.apikey_preproduction,
			apikey_development: arrow.config.apikey_development,
			routes: {},
			apiprefix: apiprefix,
			uiPrefix: uiPrefix,
			apiDocPrefix: apiDocPrefix,
			env: env
		}, arrow.config.admin || {});
	var self = this;
	this.apiprefix = apiprefix;
	this.uiPrefix = uiPrefix;

	this.resolveAllowedHosts(arrow, config, function (err, result) {
		if (err) {
			callback(err);
		} else if (result && result.length > 0) {
			// Restrict access to the Admin to the specified IPs.
			arrow.logger.info('Access to API Builder Console restricted to: ' + chalk.yellow(result.join(', ')));
			var accessFilter = self.getAccessControlMiddleware(arrow, result);
			app.use(config.apiprefix, accessFilter);
			app.use(config.uiPrefix, accessFilter);
		} else {
			arrow.logger.warn('Unrestricted access to API Builder Console');
		}

		// Set up admin API
		adminapi.configure(app, apiprefix, arrow, devmode);
		// Set up admin UI
		new AdminUI(express, arrow, app, config);
		arrow.logger.info('Access API Builder Console at ' + chalk.yellow.underline(arrow.baseurl + uiPrefix) + '. ' + chalk.grey('This will only be available on your dev environment.'));
		callback();
	});
};

module.exports = Admin;
