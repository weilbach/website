/*
 * This code is closed source and Confidential and Proprietary to
 * Appcelerator, Inc. All Rights Reserved. This code MUST not be
 * modified, copied or otherwise redistributed without express
 * written permission of Appcelerator. This file is licensed as
 * part of the Appcelerator Platform and governed under the terms
 * of the Appcelerator license agreement.
 */

/* r.e. setImmediate:
	If anything inside a promise callback is thrown, the promise will automatically be rejected.
	We don't want it to happen in these cases - we want the uncaughtException handler to catch these.
	If we don't use setImmediate to take the callback out of the grasp of the promise, then we will en
	up with UnhandledPromiseRejectionWarnings.
	Don't mix and match promise/callback syntax, kids!
	see:
	https://github.com/nodejs/node/issues/9242
	https://github.com/stevemao/promise-to-callback/blob/master/index.js#L12
 */

/**
 * @class Arrow
 */
exports = module.exports = Arrow;
var consoleLog = console.error.bind(console);
var AppC = require('appc-platform-sdk');
var inProduction;
var pendingRequests = 0;
var lastGCCheck = Date.now();
var stopping = false;
var openSockets = {};

var SWAGGER_EXTENSION = /^x-/;

if (process.env.serverId && process.env.appid) {
	inProduction = true;
}

// set correct defaults for runtime in production
// must do this before loading the Loader below which loads config files
if (inProduction) {
	// if neither are set, use smart defaults
	if (!process.env.NODE_ENV && !process.env.APPC_ENV) {
		process.env.NODE_ENV = process.env.APPC_ENV = AppC.isProduction ? 'production' : 'preproduction';
	} /* APPC_ENV takes precendence*/ else if (process.env.APPC_ENV) {
		process.env.NODE_ENV = process.env.APPC_ENV;
	} else {
		process.env.APPC_ENV = process.env.NODE_ENV;
	}
}

// set the name of the node process
process.title = 'arrow' + (process.env.APPC_WORKER_PID ? (' (node worker #' + process.env.APPC_WORKER_ID + ')') : '');

var express = require('express'),
	_ = require('lodash'),
	merge = require('lodash.merge'),
	events = require('events'),
	fs = require('fs-extra'),
	path = require('path'),
	URL = require('url'),
	util = require('util'),
	async = require('async'),
	walkSync = require('walk-sync'),
	cluster = require('cluster'),
	debug = require('debug')('arrow'),
	pkg = require('../package.json'),
	Metadata = require('./metadata'),
	Logger = require('appc-logger'),
	memwatch,
	Loader = require('./loader'),
	RequestTx = require('./request_tx'),
	Middleware = require('./middleware'),
	Block = require('./block'),
	Router = require('./router'),
	AxwayFlow = require('axway-flow'),
	FlowManager = AxwayFlow.FlowManager,
	FlowNode = AxwayFlow.FlowNode,
	registerFlowCoreNodeHandlers = AxwayFlow.register,
	unregisterFlowCoreNodeHandlers = AxwayFlow.unregister,
	ArrowFlowInvoke = require('arrow-flow-invoke'),
	registerArrowNodeHandlers = ArrowFlowInvoke.register,
	unregisterArrowNodeHandlers = ArrowFlowInvoke.unregister,
	CodeblockMetadata = ArrowFlowInvoke.CodeblockMetadata,
	Endpoints = require('arrow-endpoint'),
	CLI = require('./cli'),
	API = require('./api'),
	orm = require('arrow-orm'),
	uuid = require('uuid-v4'),
	paths = require('./paths'),
	requireUncached = require('require-uncached'),
	pluralize = require('pluralize'),
	chalk = require('chalk'),
	Authentication = require('./authentication'),
	Swagger = require('./swagger'),
	Connector = orm.Connector,
	connectors = {},
	globalArrow,
	inGetConnector,
	pendingModels,
	loadedModelDirs = [],
	instantiations = [],
	servers = [],
	schemas = require('axway-schema');

try {
	memwatch = require('memwatch-next');
} catch (err) {
	// appc-memwatch isn't installed. Carry on anyway.
}

util.inherits(Arrow, events.EventEmitter);

// allow people to reference the built-in debug module
Arrow.debug = debug;

// merge in orm into our Arrow
for (var key in orm) {
	if (orm.hasOwnProperty(key)) {
		Arrow[key] = orm[key];
		orm[key].Arrow = Arrow;
	}
}

Arrow.API = API;
Arrow.Block = Block;
Arrow.CLI = CLI;
Arrow.Formation = require('./formatters');
Arrow.Loader = Loader;
Arrow.Logger = Logger;
Arrow.Metadata = Metadata;
Arrow.Middleware = Middleware;
Arrow.ORM = orm;
Arrow.Router = Router;
Arrow.Version = pkg.version;

function Arrow(config, loadOnly) {
	if (instantiations !== undefined) {
		instantiations.push(this);
	}
	this.config = new Loader(config && config.dir, null, config);
	this.port = process.env.PORT;
	if (!inProduction && this.port === undefined) {
		this.port = this.config.port;
		if (this.port === undefined) {
			this.port = 8080;
		}
	}
	if (!this.config.admin) {
		this.config.admin = {};
	}
	this.config.apiPrefix = this.config.apiPrefix || '/api';
	this.loadOnly = loadOnly;
	this.inProduction = !!inProduction;
	this.ignoreDuplicateModels = !!this.config.ignoreDuplicateModels;

	const publicDirectory = path.join(this.config.dir, 'web', 'public');

	if (!globalArrow) {
		globalArrow = this;
		// since the continuation listeners potentially has a ton of listeners on startup
		globalArrow.setMaxListeners(Number.MAX_VALUE);
	}

	if (process.env.APPC_LOG_LEVEL) {
		// change the internal config to use the environment
		this.config.logLevel = process.env.APPC_LOG_LEVEL;
	}
	if (config && config.overrideLevel) {
		this.config.logLevel = config.overrideLevel;
	}

	// configure the default apikey based on env
	if (!this.config.apikey_preproduction) {
		this.config.apikey_preproduction = this.config.apikey_production || this.config.apikey_development || this.config.apikey;
	}
	if (!this.config.apikey) {
		var key = 'apikey_' + this.config.env;
		this.config.apikey = this.config[key];
	} else {
		// set the api key to the same if we only use one
		this.config.apikey_production = this.config.apikey_preproduction = this.config.apikey_development = this.config.apikey;
	}
	// this is the default path (inside if). we use this
	// as a way to be able to load up API Builder Tools but without
	// creating the server infrastructure. this is useful for
	// being able to programatically load models, connectors, etc
	if (!loadOnly) {

		var self = this;
		this.express = express;
		var server = this.app = express();

		var healthCheckAPI = this.config.healthCheckAPI;
		var healthCheckError;
		if (healthCheckAPI) {
			try {
				healthCheckAPI = require(path.resolve(process.cwd(), healthCheckAPI));
			} catch (e) {
				healthCheckError = e;
			}
		}

		// handle any API Runtime Services health checks -- allow the user to specify their own
		// plugin or we'll provide a basic one that simply returns success if we are reachable
		// and not in shutdown phase
		server.get('/arrowPing.json', healthCheckAPI || function (req, resp) {
			return resp.json({ success: !self.shuttingdown });
		});

		// make sure that the loger is created after the healthcheck API is defined.
		this.logger = createServerLogger(this, server);

		if (healthCheckError) {
			this.logger.trace(healthCheckError.stack);
			this.logger.error('error loading health check plugin', healthCheckAPI, healthCheckError);
		}

		// add graceful shutdown middleware which will send 503 responses to
		// any incoming connection requests while we're in shutdown mode. any
		// front end load balancer (like API Runtime Services) should correctly
		server.use(function (req, resp, next) {
			if (self.shuttingdown) {
				resp.shouldKeepAlive = false;
				resp.set('Connection', 'close');
				resp.set('Cache-Control', 'no-cache, no-store, max-age=0');
				resp.set('Pragma', 'no-cache');
				resp.status(503);
				resp.end('Server is shutting down');
			} else {
				next();
			}
		});

		if (this.inProduction) {
			this.app.enable('trust proxy');
		}

		// add the request-id helper
		express.request.getId = function () {
			if (!this._reqid) {
				this._reqid = uuid();
			}
			return this._reqid;
		};

		var baseurl = this.config.baseurl || process.env.ARROWCLOUD_APP_URL || process.env.ARROW_PUBLIC_URL || process.env.NODE_ACS_URL;
		if (this.config.env === 'development' && !this.inProduction) {
			baseurl = 'http://localhost:' + this.port;

			process.removeListener('unhandledRejection', function () {
				process.on('unhandledRejection', function (reason, p) {
					this.logger.error('Unhandled rejection at: Promise', p, 'reason:', reason);
				}.bind(this));
			}.bind(this));
		}

		if (baseurl === undefined && this.config.env === 'production-eu') {
			baseurl = 'http://localhost:' + this.port;
		}

		addLocals(this, this.app, baseurl);

		// bind a logger to the server itself
		server.logger = this.logger;

		var appPkg = path.join(config && config.dir || process.cwd(), 'package.json');
		if (fs.existsSync(appPkg)) {
			appPkg = require(appPkg);
			this.logger.info(chalk.blue.bold('API Builder Tools/' + pkg.version) + ' ' + chalk.yellow(appPkg.name + '/' + appPkg.version));
		} else {
			appPkg = {};
			// fallback if we can't find package.json for app
			this.logger.info(chalk.blue.bold('API Builder Tools/' + pkg.version));
		}
		this.productionNodeVersion = appPkg.engines && appPkg.engines.node;
		this.projectName = appPkg.name ? path.basename(appPkg.name) : 'arrow-app';

		if (this.config.apikey) {
			this.logger.info('APIKey is:', chalk.gray(this.config.apikey));
		}

		var sessionConfig = this.config && this.config.session || {};

		server.use(function (req, resp, next) {
			req.pendingReqCount = ++pendingRequests;
			req.server = self;
			if (!self.config.disableServerBanner) {
				resp.set('Server', 'API Builder Tools/' + pkg.version);
			}
			resp.set('Request-Id', req.getId());
			resp.locals['request-id'] = req.getId();
			req.logger = resp.logger = req.log = req.log || self.logger;
			next();
		});

		// this should always be at the top before anything else but after setting up the logger
		server.use(createRequestTransaction(this.config));

		// // Add CORs headers for the Static Resources
		server.use((req, resp, next) => {
			// A list of the allowed methods for the static resources
			const ALLOWED_STATIC_METHODS = [ 'GET' ];
			const corsConfig = self.config.cors || {};

			if (isCORSReq(req, corsConfig)) {
				isStaticResource(publicDirectory, req.path)
					.then((isStatic) => {
						if (isStatic) {
							let corsConf = _.clone(corsConfig);

							// Add the allowed methods for the CORS config
							corsConf.defMethods = ALLOWED_STATIC_METHODS;
							addCORsHeaders(corsConf, req, resp);

							if (isPreflight(req)) {
								return resp.status(200).end();
							}
						}

						return next();
					})
					.catch(e => {
						return next(e);
					});
			} else {
				return next();
			}
		});

		// create the generic express middleware
		this.middleware = new Middleware(server, this.config.dir, sessionConfig, this.config);

		server.on('after', endRequestTransaction.bind(server));

		// add CORs headers
		server.use(function (req, resp, next) {
			if (isCORSReq(req, self.config.cors)) {
				var apis;
				if ((req.path === self.apidocPath) || (req.path === self.apidocPathLegacy)) {
					// Setup CORS on api doc urls.
					apis = [{
						method: 'GET'
					}];
				} else {
					// Setup CORS on api urls.
					apis = API.getAPIsForPath(req.path) || [];
				}

				if (apis.length) {
					var corsConf = _.clone(self.config.cors || {}),
						preflight = isPreflight(req),
						methods = {},
						headers = {};

					// extract related data from the api object (methods, headers etc)
					if (preflight) {
						// CORS should be enabled for our logs XHR
						apis.forEach(function (api) {
							methods[api.method.toUpperCase()] = undefined;
						});
					} else {
						apis.forEach(function (api) {
							// extract headers from the response definition
							api.responses && Object.keys(api.responses).forEach(function (response) {
								var hdrs = api.responses[response].headers;
								hdrs && Object.keys(hdrs).forEach(function (header) {
									// storing in an object to avoid dedupe cost
									headers[header] = undefined;
								});
							});
						});
					}

					// insert extracted data into the cors configs to be used by the addCORsHeaders
					corsConf.defMethods = Object.keys(methods);
					corsConf.defHeaders = Object.keys(headers);
					addCORsHeaders(corsConf, req, resp);
					if (preflight) {
						return resp.status(200).end();
					}
				}
			}
			next();
		});

		// load up admin if enabled
		if (this.config.env === 'development' && this.config.admin && this.config.admin.enabled) {
			// ideally admin could move somewhere else so it's not a published artifact
			this.admin = new (require('./admin'))(this);
		} else {
			// admin is completely disabled
			this.logger.info('API Builder Console is disabled');
		}

		// create the default authentication strategy
		try {
			this.authstrategy = new Authentication(this);
		} catch (e) {
			this.logger.fatal('Error attempting to configure API authentication. ' + e.message || e);
		}

		this.logger.trace('creating Arrow server instance on port %d', this.port);
	} else {
		this.logger = Logger.createLogger({ name: pkg.name, useConsole: true, level: this.config.logLevel });
		this.pkg = pkg;
	}

	if (process.env.APPC_DUMP_ENV) {
		this.logger.trace(process.env);
	}

	// pass the config to components but remove some parts
	this.objConfig = _.pick(this.config, 'name', 'port', 'admin', 'session', 'apikey', 'apikey_production', 'apikey_development');

	schemas.setLogger(this.logger);

	this.flowManager = new FlowManager(this.logger);
	this.models = {};
	this.apis = [];
	this.blocks = {};
	this.registeredNodes = [];
	this.routes = [];
	this.codeblocks = {};
	this.endpoints = {};
	this.endpointSwaggers = {};
	this.addCORsHeaders = addCORsHeaders;
	this.isPreflight = isPreflight;
	this.isCORSReq = isCORSReq;
	this.serviceconnectors = {};

	if (!loadOnly) {
		this.on('reload', this.reload);
	}

	// start loading our server
	process.nextTick(this.load.bind(this));
}

function addLocals(server, app, baseurl) {
	// record our base url for the platform and our external url
	app.locals.appc_platform_url = server.platformurl = AppC.baseurl;
	app.locals.appc_external_url = server.baseurl = baseurl;
	app.locals.appc_external_apidoc_path_legacy = server.apidocPathLegacy = (server.config.admin && server.config.admin.apiDocPrefix || '/apidoc') + '/docs.json';
	app.locals.appc_external_apidoc_path = server.apidocPath = (server.config.admin && server.config.admin.apiDocPrefix || '/apidoc') + '/swagger.json';
	app.locals.appc_external_apidoc_url = server.apidocurl = app.locals.appc_external_url + app.locals.appc_external_apidoc_path;
	app.locals.appc_env = process.env.APPC_ENV || process.env.NODE_ENV;
	app.locals.appc_registry_url = process.env.APPC_REGISTRY_SERVER || AppC.registryurl;
	server.logger.trace('setting app locals', app.locals);
}

function isCORSReq(req, corsConfig) {
	var origin = req.headers.origin || '',
		host = req.headers.host || '',
		originHost = URL.parse(origin, false).host,
		confOrigin = corsConfig && corsConfig['Access-Control-Allow-Origin'];

	// reset the lastIndex of the RegExp (else wont work for the next request)
	confOrigin && confOrigin.lastIndex && (confOrigin.lastIndex = 0);

	// first check if its a valid CORS request by checking if the origin contains the host.
	// Then check if the origin is allowed or not based on the configuration (The match covers
	// *, single or space separated values, array and regex)
	return origin && originHost !== host
		&& (confOrigin === '*'
			|| (typeof confOrigin === 'string' && confOrigin.split(/\s* /).indexOf(origin) !== -1)
			|| (confOrigin instanceof Array && confOrigin.indexOf(origin) !== -1)
			|| (confOrigin instanceof RegExp && confOrigin.test(origin)));
}

function isPreflight(req) {
	return req.method === 'OPTIONS' && !!req.headers['access-control-request-method'];
}

/* List of default headers the server accepts. Can be overridden in config using:
	cors: {
		'Access-Control-Allow-Headers': ['foo-header', 'bar-header']
	}
*/
var DEFAULT_SAFE_REQUEST_HEADERS = [
	'x-requested-with',
	'accept',
	'origin',
	'content-type',
	'authorization',
	'x-titanium-id',
	'x-native-id'
];

/* List of default headers the server whitelists that browsers are allowed to access.
	Can be overridden in config using:
	cors: {
		'Access-Control-Expose-Headers': ['foo-header', 'bar-header']
	}

	NOTE: The 6 headers are always exposed by default are:
	Cache-Control, Content-Language, Content-Type, Expires, Last-Modified, Pragma
*/
var DEFAULT_SAFE_EXPOSE_HEADERS = [
	'request-id',
	'response-time'
];

/**
 * Determines wheather or not the requested path is to one of the static resources.
 *
 * @param {string} publicDirectory - The path to the static resources in the application.
 * @param {string} resourcePath - The path to the requested resource.
 *
 * @returns {Promise} - Promise object representing the boolean equivelent to being a static resource or not.
 */
function isStaticResource(publicDirectory, resourcePath) {
	return new Promise((resolve) => {
		// Check if the file exists in the public directory.
		fs.access(path.join(publicDirectory, resourcePath), fs.constants.F_OK, (error) => {
			const isStatic = !error;

			resolve(isStatic);
		});
	});
}

/**
 * Adds required CORS headers to the response (assuming its a valid and allowed CORS request)
 * Implementation is based on https://www.w3.org/TR/2014/REC-cors-20140116/
 * @param {object} config - arrow configuration.cors (support 2 additional fields,
 *                          1) defMethods: array of methods found in the API definition
 *                          2) defHeaders: array of headers found in the API definition
 * @param {Object} req - Express' request object
 * @param {object} resp - Express' response object
 * @returns
 */
function addCORsHeaders(config, req, resp) {
	var corsConfig = config || {},
		confCredentials = corsConfig['Access-Control-Allow-Credentials'],
		origin = req.headers.origin;

	// convert single or comma seperated values to an array (lower case)
	function convertToArray(value) {
		if (Array.isArray(value)) {
			return value.map(function (val) {
				return val.toLowerCase();
			});
		} else if (typeof value === 'string' || value instanceof String) {
			return value.trim().split(/\s*,\s*/).map(function (val) {
				return val.toLowerCase();
			});
		} else {
			return [];
		}
	}

	resp.setHeader('Access-Control-Allow-Origin', origin);
	resp.setHeader('vary', 'Origin');

	if (isPreflight(req)) {
		var confMethods = convertToArray(corsConfig['Access-Control-Allow-Methods']),
			safeHeaders = corsConfig.safeHeaders || DEFAULT_SAFE_REQUEST_HEADERS,
			confHeaders = convertToArray(corsConfig['Access-Control-Allow-Headers']),
			allowHeaders = confHeaders.length ? confHeaders : safeHeaders,
			defMethods = corsConfig.defMethods || [],
			allowMethods = [];

		// calculate the allowed methods based on bound methods and the ones in the config
		confMethods = confMethods.map(function (val) {
			return val.toUpperCase();
		});
		allowMethods = confMethods.length ? _.intersection(defMethods, confMethods) : defMethods;
		// set allow-methods and allow-headers(all supported headers) value
		resp.setHeader('Access-Control-Allow-Methods', allowMethods.join(', '));
		resp.setHeader('Access-Control-Allow-Headers', allowHeaders.join(', '));
	} else {
		// if its an actual request
		// populate the value of expose-headers from configs, definitions and DEFAULT_SAFE_EXPOSE_HEADERS
		var confExpose = convertToArray(corsConfig['Access-Control-Expose-Headers']),
			defHeaders = convertToArray(corsConfig.defHeaders),
			exposeHeaders = _.uniq(confExpose.concat(DEFAULT_SAFE_EXPOSE_HEADERS, defHeaders));
		resp.setHeader('Access-Control-Expose-Headers', exposeHeaders.join(', '));
	}
	confCredentials && resp.setHeader('Access-Control-Allow-Credentials', confCredentials);
}

/**
 * Returns the middleware instance containing the Express app instance.
 * @returns {Arrow.Middleware}
 */
Arrow.prototype.getMiddleware = function () {
	return this.middleware;
};

/**
 * Tracks all instantiations.
 */
Arrow.trackInstantiations = function () {
	instantiations = [];
};

/*
 * used for testing only
 *
 * @private
 */
Arrow.resetGlobal = function resetGlobal () {
	if (instantiations !== undefined) {
		instantiations.forEach(function resetGlobalInstance (arrow) {
			if (arrow.logger && arrow.logger.requestLogger && arrow.logger.requestLogger.streams) {
				arrow.logger.requestLogger.streams.forEach(function resetLoggerInstance (f) {
					f.stream.end();
				});
			}
		});
		instantiations = [];
	}
	Arrow.ORM.MemoryConnector.resetPrimaryKeys();
	connectors = {};
	loadedModelDirs = [];
	globalArrow = null;
	pendingRequests = 0;
};

/**
 * Gets a reference to the first instantiated Arrow server.
 * @returns {Arrow}
 */
Arrow.getGlobal = function () {
	return globalArrow;
};

/*
 * create the logger
 */
function createServerLogger(arrow, server) {
	var logging = arrow.config.logging || {};
	var appPkg = path.join(arrow.config && arrow.config.dir || process.cwd(), 'package.json');
	var name = 'arrow-app'; // default name is arrow-app
	if (logging.adiLogging && fs.existsSync(appPkg)) {
		appPkg = require(appPkg);
		name = appPkg.name || name;
	}
	// use a restify logger if transaction logging is on. it contains a console logger
	// too...
	// API-689 -- disable in production for now
	if (arrow.inProduction) {
		logging.transactionLogEnabled = false;
	}
	if (cluster.isWorker) {
		// we set the request logger to be unique so that each cluster worker will
		// write to a different file
		logging.requestsLogFilename = 'request-cluster-' + cluster.worker.id + '.log';
		arrow.config.logging = logging;
	}
	// create the restify logger
	var logger = Logger.createRestifyLogger(server, {
		afterEvent: 'txdone',
		level: arrow.config.logLevel,
		logs: logging.directory,
		requestsLogFilename: logging.requestsLogFilename,
		logSingleRequest: logging.transactionLogEnabled || logging.transactionLogEnabled === undefined,
		adiLogging: logging.adiLogging,
		name: name,
		adiPathFilter: [ arrow.config.apiPrefix ]
	});

	return logger;
}

/*
 * start a connector and call next when completed
 */
function startConnector(instance, connector, next) {
	if (connector.connect && !instance.loadOnly && !connector.started) {
		// if the connector is disabled, don't start it
		if (connector.enabled === false || (connector.config && connector.config.enabled === false)) {
			if (!connector.enableWarning) {
				// only warn once
				instance.logger.info(chalk.green('connector/' + connector.name) + ' is disabled in config. will not start it and it won\'t be available');
			}
			connector.enabled = false;
			connector.enableWarning = true;
			return next();
		}
		instance.logger.info('Starting ' + chalk.green('connector/' + connector.name + (connector.version ? ('@' + connector.version) : '')));
		connector.connect(function (err) {
			if (err) {
				err = new Error('Error loading connector/' + connector.name + '. ' + (err.message || err));
				return next(err);
			}
			connector.started = true;
			connector.enabled = true;
			instance.logger.info('Started ' + chalk.green('connector/' + connector.name));
			next && next();
		});
	} else {
		next && next();
	}
}

/**
 * Returns the full path of the component directory.
 * @param {String} type Component type, that is, `api`, `block`, `model` or `route`.
 * @param {Boolean} nmd Set to `true` if using a node module.
 * @returns String
 */
Arrow.prototype.getComponentDir = function getComponentDir(type, nmd) {
	if (type === 'route') {
		// these live in a little bit of a different location
		return path.resolve(path.join(this.config.dir || process.cwd(), 'web', 'routes'));
	} else if (type === 'node') {
		return path.resolve(path.join(this.config.dir || process.cwd(), (nmd ? 'node_modules/' : 'nodes')));
	}
	return path.resolve(path.join(this.config.dir || process.cwd(), (nmd ? 'node_modules/' : '') + type + 's'));
};

/**
 * Loads an API from an API file. The file must exist and be a valid API. No error checking is performed.
 * @param {String} fn Filename of the API.
 * @param {Function} [cb] Callback passed an Error object (or null if successful), the API instance, and the API class.
 */
Arrow.prototype.loadApi = function loadAPI(fn, cb) {
	this.logger.debug('attempting to load API', fn);
	var APIClass = paths.requireComponent(fn, true);
	if (!APIClass) {
		this.logger.trace(APIClass);
		throw new Error('Error loading api at ' + fn);
	}
	if (!_.isFunction(APIClass)) {
		this.logger.trace(APIClass);
		throw new Error('Error loading api at ' + fn + '. this module did not export a Class');
	}
	var api = new APIClass(this.objConfig, this, fn);
	this.apis.push(api);
	this.triggerReloadedIfRequired(false, [{ fn: this.app }]);
	cb && cb(null, api, APIClass);
};

/**
 * Loads a Model from a Model file. The file must exist and be a valid Model. No error checking is performed.
 * @param {String} fn Filename of the Model.
 * @param {Function} [cb] Callback passed an Error object (or null if successful) and the Model class.
 */
Arrow.prototype.loadModel = function loadModel(fn, cb) {
	this.logger.debug('attempting to load model', fn);
	var Model = paths.requireComponent(fn, true);
	if (!Model) {
		this.logger.trace(Model);
		throw new Error('Error loading model at ' + fn);
	}
	if (!_.isObject(Model)) {
		this.logger.trace(Model);
		throw new Error('Error loading model at ' + fn + '. this module did not load properly');
	}
	if (!_.isFunction(Model.create) && !Model.loadingModels) {
		this.logger.trace(Model);
		throw new Error('Error loading model at ' + fn + '. this module did not export a Class');
	}
	if (!Model.loadingModels && (!_.isObject(Model.fields) || !Object.keys(Model.fields).length)) {
		this.logger.trace(Model);
		throw new Error('Error loading model at ' + fn + '. this model did not contain any fields');
	}
	// if we don't provide a connector, attempt to get the connector global default the config
	// this makes it nice since i can simply put my default in the config and i don't need to specify
	// on each and every model
	Model.connector = Model.connector || this.config.defaultConnector;
	Model.name && (this.models[Model.name] = Model);
	Model.filename = fn;
	if (!Model.generated) {
		Model.timestamp = fs.statSync(fn).mtime;
	}
	this.triggerReloadedIfRequired(false, [{ fn: Model }]);
	cb && cb(null, Model);
};

/**
 * Loads a Block from a Block file. The file must exist and be a valid Block. No error checking is performed.
 * @param {String} fn Filename of the Block.
 * @param {Function} [cb] Callback passed an Error object (or null if successful) and the Block class.
 */
Arrow.prototype.loadBlock = function loadBlock(fn, cb) {
	this.logger.debug('attempting to load block', fn);
	var Block = paths.requireComponent(fn, true);
	if (!Block) {
		this.logger.trace(Block);
		throw new Error('Error loading block at ' + fn);
	}
	if (!_.isFunction(Block)) {
		this.logger.trace(Block);
		throw new Error('Error loading block at ' + fn + '. this module did not export a Class');
	}
	var block = new Block(this.objConfig, this);
	this.blocks[block.name] = block;
	Block.filename = block.filename = fn;
	Block.timestamp = block.timetsamp = fs.statSync(fn).mtime;
	this.triggerReloadedIfRequired(false, [{ fn: block }]);
	cb && cb(null, Block);
};

/**
 * Loads a Flow from a flow file. The file must exist and be a valid Flow.
 * @param {String} fn Filename of the flow.
 * @param {Function} [cb] Callback passed an Error object (or null if successful) and the Flow class.
 */
Arrow.prototype.loadFlow = function loadFlow(fn, cb) {
	this.logger.debug('attempting to load flow', fn);
	return this.flowManager.load(fn).then(
		function (flow) {
			// See "r.e. setImmediate" comment above
			setImmediate(function () {
				cb && cb(null, flow);
			});
		},
		function (err) {
			this.logger.error(err);
			// See "r.e. setImmediate" comment above
			setImmediate(function () {
				cb && cb(new Error('Error loading flow at ' + fn));
			});
		}.bind(this));
};

/*
 * Parses and validates a swagger document
 * @param {string|object} swagger - swagger document
 * @returns {Promise<object>} valid swagger
 */
Arrow.prototype.validateSwagger = function (swagger) {
	return Endpoints.validateSwagger(swagger);
};

/**
 * Loads an endpoint from a file.
 * @param  {string} fn [path to file]
 * @param  {Function} cb [callback to for error handle]
 */
Arrow.prototype.loadEndpoint = function loadEndpoint(fn, cb) {
	this.logger.debug('attempting to load endpoint', fn);
	return Endpoints.load(fn, this.getFlows()).then(
		function (loaded) {
			var endpointName = path.basename(fn, '.json');
			this.endpoints[endpointName] = loaded.endpoint;
			this.endpointSwaggers[endpointName] = loaded.swagger;
			// See "r.e. setImmediate" comment above
			setImmediate(function () {
				cb && cb(null, loaded);
			});
		}.bind(this),
		function (err) {
			var error = 'Error loading endpoint at ' + fn;
			// err can contain .errors or is an exception
			var errors = [ error ];
			if (err.errors) {
				errors.push(' ');
				err.errors.forEach(function (e) {
					errors.push(JSON.stringify(e));
				});
			} else {
				errors.push((err + '').replace(/^Error:\s+/, '; '));
			}
			var msg = errors.join('').trim();
			this.logger.error(msg);
			// See "r.e. setImmediate" comment above
			setImmediate(function () {
				cb && cb(new Error(msg));
			});
		}.bind(this));
};

/**
 * Loads a Route from a Route file. The file must exist and be a valid Route. No error checking is performed.
 * @param {String} fn Filename of the Route.
 * @param {Function} [cb] Callback passed an Error object (or null if successful) and the Route class.
 */
Arrow.prototype.loadRoute = function loadRoute(fn, cb) {
	this.logger.debug('attempting to load route', fn);
	var Router = paths.requireComponent(fn, true);
	if (!Router) {
		this.logger.trace(Router);
		throw new Error('Error loading route at ' + fn);
	}
	if (!_.isFunction(Router)) {
		this.logger.trace(Router);
		throw new Error('Error loading route at ' + fn + '. this module did not export a Class');
	}
	var route = new Router(this.objConfig, this);
	this.routes.push(route);
	Router.filename = route.filename = fn;
	Router.timestamp = route.timestamp = fs.statSync(fn).mtime;
	this.triggerReloadedIfRequired(false, [{ fn: route }]);
	cb && cb(null, Router);
};

/**
 * Loads a Connector from a Connector file. The file must exist and be a valid Connector. No error checking is performed.
 * @param {String} fn Filename of the Connector.
 * @param {Function} [cb] Callback passed an Error object (or null if successful) and the Connector class.
 */
Arrow.prototype.loadConnector = function loadConnector(fn, cb) {
	this.logger.debug('attempting to load connector', fn);
	var Connector = paths.requireComponent(fn, true);
	if (!Connector) {
		this.logger.trace(Connector);
		throw new Error('Error loading connector at ' + fn);
	}
	if (!_.isObject(Connector)) {
		this.logger.trace(Connector);
		throw new Error('Error loading connector at ' + fn + '. this module did not export an object');
	}
	if (!_.isObject(Connector.create)) {
		this.logger.trace(Connector);
		throw new Error('Error loading connector at ' + fn + '. this module did not export a Class function');
	}
	var connector;
	if (!Connector.name && Connector.create) {
		if (Connector.filename) {
			connector = this.getConnector(Connector.filename.split(path.sep).pop());
		}
	} else {
		connector = this.getConnector(Connector.name);
	}
	if (connector) {
		connector.filename = Connector.filename = fn;
		startConnector(this, connector, cb);
		this.logger.debug('loaded connector', fn);
	} else {
		cb();
	}
};

/**
 * Loads a Codeblock from a Codeblock file. The file must exist and be a valid Codeblock. No error checking is performed.
 * @param {String} fn Filename of the Codeblock.
 * @param {Function} [cb] Callback passed an Error object (or null if successful) and the Codeblock class.
 */
Arrow.prototype.loadCodeblock = function loadCodeblock(fn, cb) {
	var msg;
	this.logger.debug('attempting to load codeblock', fn);

	CodeblockMetadata.load(fn, {
		logger: this.logger
	}).then(
		function (meta) {
			// all checks pass. Read the codeblock and save it in the instance
			// get codeblock function file
			var absPath = path.resolve(path.dirname(fn), meta.path);
			try {
				meta.action = requireUncached(absPath);
			} catch (ex) {
				msg = 'Error loading codeblock at ' + fn + '. ' + ex;
				this.logger.error(msg);
				// See "r.e. setImmediate" comment above
				setImmediate(function () {
					cb && cb(new Error(msg));
				});
				return;
			}
			if (typeof (meta.action) !== 'function') {
				msg = 'Error loading codeblock at ' + fn + '. module is not a function';
				this.logger.error(msg);
				// See "r.e. setImmediate" comment above
				setImmediate(function () {
					cb && cb(new Error(msg));
				});
				return;
			}

			this.codeblocks[meta.name] = meta;
			// See "r.e. setImmediate" comment above
			setImmediate(function () {
				cb && cb(null, meta);
			});
		}.bind(this),
		function (err) {
			this.logger.error(err);
			this.logger.error('Error loading codeblock at ' + fn);
			// See "r.e. setImmediate" comment above
			setImmediate(function () {
				cb && cb(err);
			});
		}.bind(this)
	);
};

Arrow.prototype.loadNode = function loadNode(fn, cb) {
	var instance = this;

	if (fn.match(/[/\\]package.json$/)) {
		// not a node_module - it is jut local ./nodes
		return instance.loadNode(path.dirname(fn), cb);
	}

	try {
		var module = require(fn);
		if (!module || !module.specs) {
			throw new Error('Not a flow-node component');
		}
		Object.keys(module.specs).forEach(function (name) {
			var uri = FlowManager.formatNodeHandlerUri(module.name, name);
			var spec = JSON.parse(JSON.stringify(module.specs[name]));
			spec.type = uri;

			class Node extends FlowNode { }
			Object.keys(module.specs[name].methods).forEach(function (mname) {
				Node.prototype[mname] = module.specs[name].methods[mname].action;
			});
			instance.registeredNodes.push(uri);
			instance.flowManager.registerNode(uri, Node, function () {
				return spec;
			});
		});
		cb();
	} catch (ex) {
		var msg = 'Error loading node module at ' + fn + '. ' + ex;
		cb && cb(msg);
	}
};

Arrow.prototype.loadServiceconnector = function loadServiceconnector(fn, cb) {
	try {
		var module = require(fn);
		this.serviceconnectors[fn] = module;
		if (module.register) {
			module.register(this);
		} else {
			this.logger.warn('service connector does not have a register method: ' + fn);
		}
		cb();
	} catch (ex) {
		var msg = 'Error loading service connector at ' + fn + '. ' + ex;
		cb && cb(msg);
	}
};

Arrow.prototype.loadSchema = function loadSchema(fn, cb) {
	this.logger.debug('attempting to load schema', fn, 'with scope, \'' + this.projectName + '\'');
	// adding schema as per the ticket RDPP-1673
	schemas.add(fn, 'schema:///schema/' + this.projectName + '/' + path.basename(fn, '.json'));
	cb();
};

/*
 * internally used to trigger a reloaded event if necessary
 */
Arrow.prototype.triggerReloadedIfRequired = function triggerReloadedIfRequired(force, obj, err) {
	if (!stopping && (force || this.loaded) && !this.pendingReload) {
		this.logger.debug('reloaded', obj);
		this.emit('reloaded', obj && Array.isArray(obj) ? obj : [ obj ], err);
	}
};

/**
 * Loads all project components.
 * @param {Function} callback Callback to execute after loading each component. Passed an Error object if any.
 * @param {Boolean} skipConnectors Set to `true` to not load Connectors.
 */
Arrow.prototype.loadComponents = function loadComponents(componentTypes, callback, skipConnectors) {
	var instance = this;
	var tasks = [];

	// make sure we first load any connectors specified in the configuration
	// so that we can setup the aliases correctly
	var allConnectors = this.config && this.config.connectors;
	for (var name in allConnectors) {
		if (allConnectors.hasOwnProperty(name)) {
			var loadedConnector = instance.getConnector(name, false);
			if (loadedConnector) {
				(function (loadedConnector) {
					tasks.push(function (cb) {
						startConnector(instance, loadedConnector, cb);
					});
				}(loadedConnector));
			}
		}
	}

	// load connectors, models, blocks, apis, and then routes from directories (in that order)
	// first using the node_modules (the true) and then
	// using the cwd/<type> (the false)
	componentTypes.forEach(function (type) {
		if (skipConnectors && type === 'connector') {
			return;
		}
		var xtype = type.replace(/^@/g, ''),
			typeName = xtype.charAt(0).toUpperCase() + xtype.substring(1),
			mn = 'load' + typeName,
			loadFn;
		if (!instance[mn]) {
			throw new Error('Missing method: ' + mn);
		}
		loadFn = instance[mn].bind(instance);

		// set a flag that we're loading
		tasks.push(function (cb) {
			instance['loading' + typeName + 's'] = true;
			cb();
		});

		// look inside project directories
		iterateComponentDir(instance, type, true, function (fn) {
			tasks.push(function (cb) {
				try {
					loadFn(fn, cb);
				} catch (e) {
					cb(e);
				}
			});
		});
		// then look inside node_modules
		iterateComponentDir(instance, type, false, function (fn) {
			tasks.push(function (cb) {
				try {
					loadFn(fn, cb);
				} catch (e) {
					cb(e);
				}
			});
		});
		tasks.push(function (cb) {
			// delete our flag
			delete instance['loading' + typeName + 's'];
			// fire an event that we're done loading in case
			// we have someone listening for pending models to finish before continuing
			instance.emit('loaded' + typeName + 's');
			cb();
		});
	});

	async.series(tasks, callback);
};

/*
 * called internally to start loading server. when you call start, it will wait until the
 * loaded event is fired
 */
Arrow.prototype.load = function load(callback) {
	var instance = this;

	// Load components
	this.loadComponents([ 'schema', 'connector', 'model', 'block', 'api', 'route' ], function (err) {
		if (!err) {
			// indicate we've started and emit loading event
			this.loaded = true;
			// convert models to schema and register them after all the models are loaded
			Object.keys(instance.models).forEach(function (name) {
				var schema = instance.modelToSchema(instance.models[name]);
				schemas.add(schema);
			});
			this.emit('loaded');
		} else if (callback) {
			callback(err);
		} else {
			this.emit('error', err);
		}
	}.bind(this));
};

/*
 * utility function to iterate a component directory and for each component found, call
 * the foundCallback function will the parameter of the path to the component
 */
function iterateComponentDir(instance, type, useNodeModuleDir, foundCallback) {
	var dir = instance.getComponentDir(type, useNodeModuleDir);
	instance.logger.trace('iterateComponentDir', type, dir);
	if (fs.existsSync(dir)) {
		if (type === 'model') {
			try {
				var appcJSON = require(dir + '/../appc.json');
				if (appcJSON && appcJSON.type === 'connector') {
					instance.logger.trace('skipping iterateComponentDir for ' + appcJSON.type, type, dir);
					return;
				}
			} catch (e) {
				// Ignore errors
			}
			if (loadedModelDirs.indexOf(dir) >= 0) {
				instance.logger.trace('iterateComponentDir already read', type, dir);
				return;
			}
			loadedModelDirs.push(dir);
		}

		// if node_modules or a connector, we load not the individual files but the directory as module
		if (useNodeModuleDir || type === 'serviceconnector') {
			var names = fs.readdirSync(dir);
			names.forEach(function nameIterator(name) {
				var ndir = path.join(dir, name),
					pkg = path.join(ndir, 'package.json');

				if (type === 'node' && (!name.startsWith('nodehandler-') || name === 'nodehandler-utils')) {
					// not a node handler
					return;
				}
				if ((type === 'serviceconnector') || fs.existsSync(pkg)) {
					foundCallback(ndir);
				} else {
					instance.logger.trace('iterateComponentDir - no package json at', pkg);
				}
			});
		} else if (type === 'connector') {
			var pkg = path.join(dir, 'package.json');
			if (fs.existsSync(pkg)) {
				foundCallback(dir);
			} else {
				instance.logger.trace('iterateComponentDir - no package json at', pkg);
			}
		} else if (type === 'codeblock' || type === 'flow' || type === 'endpoint' || type === 'schema') {
			var jsonfileRE = /^((?!_))(.*)?\.json$/;
			walkSync(dir).forEach(function fileIterator(file) {
				if (jsonfileRE.test(path.basename(file))) {
					var fn = path.join(dir, file);
					foundCallback(fn);
				} else {
					instance.logger.trace('iterateComponentDir - skipping...', file);
				}
			});
		} else if (type === 'node') {
			fs.readdirSync(dir).forEach(function fileIterator(file) {
				if (file.startsWith('nodehandler-')) {
					foundCallback(path.join(dir, file));
				}
			});
		} else {
			var jsfileRE = /^((?!_))(.*)?\.js$/;
			walkSync(dir).forEach(function fileIterator(file) {
				if (jsfileRE.test(path.basename(file))) {
					var fn = path.join(dir, file);
					foundCallback(fn);
				} else {
					instance.logger.trace('iterateComponentDir - skipping...', file);
				}
			});
		}
	} else {
		instance.logger.trace('iterateComponentDir not found', type, dir);
	}
}

/**
 * Returns a configuration value for the key (or a provided default value if not found).
 * @param {String} key Key to retrieve.
 * @param {Any} def Default value to return if the key cannot be found.
 */
Arrow.prototype.get = function get(key, def) {
	return this.config[key] || def;
};

/*
 * handle the authentication flow for both sync and async implementations
 */
function executeAuth(authstrategy, req, resp, next) {
	if (authstrategy.validateRequest.length < 3) {
		// this is a synchoronous interface for simplicity
		try {
			var passed = authstrategy.validateRequest(req, resp);
			next(null, passed);
		} catch (e) {
			return next(e);
		}
	} else {
		// this is asynchronous
		authstrategy.validateRequest(req, resp, next);
	}
}

/**
 * returns false if the model name passed in does not exist.
 * It handles the fatal error if the model does exist.
 *
 * At the moment it returns true, but it should stop the server
 */
function isModelDuplicate(modelName) {
	if (globalArrow && (modelName in globalArrow.models)) {
		if (globalArrow.ignoreDuplicateModels) {
			return false;
		}
		// Model already exists!
		throw new Error('Model name: ' + modelName + ' exists in multiple places');
	} else {
		return false;
	}
}

/**
 * Creates and executes a security middleware call, which authenticates the request.
 * @param {Object} req Request object.
 * @param {Object} resp Response object.
 * @param {Function} next Next function to call.
 */
Arrow.prototype.executeSecurityMiddleware = function executeSecurityMiddleware(req, resp, next) {

	// allow plugins to turn it off
	if (req.skipSecurityCheck) {
		return next();
	}

	// old server plugin. you could specify a authentication function
	// and we would call that. keep this in place for existing apps
	if (this.authentication) {
		return this.authorization(req, resp, next);
	}

	// we are using the newer authentication strategy plugin framework
	if (this.authstrategy.matchURL(req)) {
		return executeAuth(this.authstrategy, req, resp, function (err, passed, result) {
			if (!passed || err || result) {
				resp.status(err && err.statusCode || 401);
				if (req.accepts('json')) {
					resp.json(result || {
						id: err && err.id || 'com.appcelerator.api.unauthorized',
						message: err && err.message || 'Unauthorized',
						success: false
					});
				} else {
					resp.type('txt').send(err && err.message || 'Unauthorized');
				}
				return next(false);
			}
			next();
		});
	} else {
		next();
	}
};

/*
 * calls callback with true if available, false if not
 */
function isPortAvailable(port, cb, tries) {
	// if we are using PORT passed in from API Runtime Services -or-
	// if we're running in a cluster worker, just continue
	if (inProduction || cluster.isWorker) {
		return cb(true);
	}
	tries = (tries || 0) + 1;
	var net = require('net'),
		server = net.createServer();

	server.listen(port, function (err) {
		if (err) {
			return cb(err);
		}

		var newcb;
		if (port === 0) {
			// pick a random port when 0 is used
			// we need to increment in user land and then verify again (below)
			port = server.address().port + 10;
			newcb = cb;
			cb = null;
		}
		server.once('close', function () {
			cb && cb(true, port);
			if (newcb) {
				// we need to verify our new port assigned to
				// make sure it's available since platforms don't
				// guarantee they are available
				// http://stackoverflow.com/questions/9901043/how-does-node-js-choose-random-ports
				return isPortAvailable(port, newcb, tries);
			}
		});
		server.close();
	});
	server.once('error', function (err) {
		try {
			server.close();
		} catch (e) {
			// Ignore error
		}
		if (err.code !== 'EADDRINUSE' || tries > 3) {
			cb && cb(false);
		} else {
			// on restart, sometimes a bind will fail, so let's try it again
			// for up to 3 times
			setTimeout(function () {
				isPortAvailable(port, cb, tries);
			}, 10);
		}
	});
}

/**
 * Starts the server.
 * @param {Function} [callback] Callback passed an Error object.
 * @throws Error
 */
Arrow.prototype.start = function start(callback) {

	// this can happen if you call loadOnly in constructor and then later
	// try and start the server
	if (!this.app) {
		var error = new Error('invalid state. no internal app was created. did you call loadOnly in the Arrow constructor?');
		if (callback) {
			return callback(error);
		} else {
			throw error;
		}
	}

	// if we started and then stopped and now we're restarting, we need to reload this
	if (this.shuttingdown) {
		this.logger.trace('re-start after a shutdown');
		var self = this;
		this.shuttingdown = false;
		return async.each(this.apis, function (api, cb) {
			api.remove(self, cb);
		}, function (err) {
			if (err) {
				return callback(err);
			}
			async.each(self.routes, function (route, cb) {
				if (route) {
					route.remove(self, cb);
				} else {
					cb();
				}
			}, function (err) {
				if (err) {
					return callback(err);
				}
				Object.keys(self.blocks).forEach(function (name) {
					var block = self.blocks[name];
					block.removeAllListeners();
				});
				self.models = {};
				self.apis = [];
				self.blocks = {};
				self.routes = [];
				self.load(function (err) {
					if (err) {
						return callback(err);
					}
					self.start(callback);
				});
			});
		});
	}

	if (!callback) {
		callback = function (err) {
			if (err) {
				this.logger.error('server failed to start');
				this.logger.error(err);
				this.emit('error', err);
			} else if (this.port) {
				this.logger.info('server started on port', this.port);
			} else {
				this.logger.info('server started');
			}
		}.bind(this);
	}

	if (!this.loaded) {
		this.logger.debug('waiting on server to finish loading');
		// we haven't finished loading, wait for the loading event to
		// fire and then re-entrant the start function
		return this.on('loaded', function () {
			return this.start(callback);
		}.bind(this));
	}

	this.logger.debug('starting', this.port);
	this.emit('starting');
	if (process.send && process.connected) {
		process.send('starting');
	}

	var tasks = [],
		listener,
		instance = this;

	// check the port to make sure its free
	tasks.push(function checkPortTask(next) {
		isPortAvailable(this.port, function (available, port) {
			if (!available) {
				return next(new Error('Assigned port (' + this.port + ') is already in use. '
					+ 'Please see if you have a running instance of this service on this machine. '
					+ 'You can also specify the port using the PORT environment variable when starting '
					+ 'the server or change in your config file.'));
			}
			// assign it in case it was wildcard
			this.port = port || this.port;
			this.logger.debug('port', port, 'available for use');
			return next();
		}.bind(this));
	}.bind(this));

	// load schemas
	tasks.push(function loadSchemasTask(next) {
		this.logger.debug('loading schemas');
		try {
			schemas.loadSync();
			next();
		} catch (ex) {
			this.logger.error('error loading schemas', ex);
			next(ex);
		}
	}.bind(this));

	// start any connectors that haven't been connected
	Object.keys(connectors).forEach(function connectorIterator(connectorName) {
		var connector = connectors[connectorName];
		if (!connector.connected) {
			tasks.push(function connectorConnectTask(cb) {
				startConnector(instance, connector, cb);
			});
		}
	});

	// load node handlers
	tasks.push(function loadNodeHandlers(next) {
		this.loadComponents([ 'node' ], function (err) {
			this.logger.debug('Done loading nodes');
			next(err);
		}.bind(this));
	}.bind(this));

	// load service connectors
	tasks.push(function loadServiceConnectors(next) {
		this.loadComponents([ 'serviceconnector' ], function (err) {
			this.logger.debug('Done loading service-connectors');
			next(err);
		}.bind(this));
	}.bind(this));

	// finish loading flows, after registering node handlers
	tasks.push(function loadCodeblocks(next) {
		this.loadComponents([ 'codeblock' ], function (err) {
			this.logger.debug('Done loading codeblocks');
			next(err);
		}.bind(this));
	}.bind(this));

	// register node handlers.  has to be done after connectors, and done after checking
	// to see if port is in use (existing tests depend on that).
	tasks.push(function registerNodeHandlers(next) {
		try {
			registerFlowCoreNodeHandlers(instance.flowManager);
			registerArrowNodeHandlers(instance);
		} catch (ex) {
			return next(ex);
		}
		next();
	});

	// finish loading flows, after registering node handlers
	tasks.push(function loadFlows(next) {
		this.loadComponents([ 'flow', 'endpoint' ], function (err) {
			this.logger.debug('Done loading flows and endpoints');
			next(err);
		}.bind(this));
	}.bind(this));

	// turn our models into apis
	tasks.push(function createModelAPIs(next) {
		this.createAPIsFromModels();
		next();
	}.bind(this));

	// check our APIs and Routes for uniqueness
	tasks.push(function checkAPIs(next) {
		var uniqueMap = {},
			routesAndAPIs = [].concat(this.apis, this.routes);
		for (var i = 0; i < routesAndAPIs.length; i++) {
			var obj = routesAndAPIs[i];
			// replace path params to a placeholder identifier. /foo/:id and /foo/:bar should collide
			var pathTransformed = obj.path.replace(/(:(.*?)(?=\/|$))/g, ':pathParamPlacehdr');
			if (!obj.enabled) {
				continue;
			} else if (uniqueMap[obj.method.toLowerCase() + ':' + pathTransformed]) {
				this.logger.warn('Multiple APIs or Routes registered for the same path and method; please disable or change the path of all but one of them for consistent results:');
				this.logger.warn(' - ' + obj.method + ' ' + obj.path);
				this.logger.warn(' - to disable a Model method, use `actions: [ ... ]` or `disabledActions: [ "' + obj.describes + '" ]`');
				this.logger.warn(' - to disable an API or Route, use `enabled: false');
				break;
			} else {
				uniqueMap[obj.method.toLowerCase() + ':' + pathTransformed] = true;
			}
		}
		// check endpoints for duplicate routes, if found, mark the whole endpoint invalid
		var endpointsMap = {};
		Object.keys(this.endpoints).forEach(function (ep) {
			var basepath = Endpoints.getRuntimeBasePath(this, this.endpoints[ep]);
			Object.keys(this.endpoints[ep].paths).forEach(function (path) {
				if (SWAGGER_EXTENSION.test(path)) {
					return;
				}
				Object.keys(this.endpoints[ep].paths[path]).forEach(function (method) {
					if (SWAGGER_EXTENSION.test(method) || method === 'parameters') {
						return;
					}
					var fullpath = basepath + path;
					fullpath = Endpoints.endpointToExpress(fullpath);
					// replace path params to a placeholder identifier. /foo/:id and /foo/:bar should collide
					var pathTransformed = fullpath.replace(/(:(.*?)(?=\/|$))/g, ':pathParamPlacehdr');
					var pathSignature = method + ':' + pathTransformed;
					var seenEndpoint = endpointsMap[pathSignature];
					var spacer = chalk.grey('       | - ');
					var msg;

					// if route clashes with other endpoints, disable both endpoints
					if (seenEndpoint) {
						msg = 'Duplicate Endpoint for path "' + method.toUpperCase() + ' ' + path + '" found in Endpoint "' + seenEndpoint + '" and ' + ep + '\n';
						msg += spacer + 'to disable an API or Route, use `enabled: false`\n';
						msg += spacer + 'to disable flow based API endpoints group, use `x-enabled: { enabled: false }`';

						// Disable the whole endpoints
						this.endpoints[ep] = Endpoints.disableEndpoint(this.endpoints[ep], msg);
						this.endpoints[seenEndpoint] = Endpoints.disableEndpoint(this.endpoints[seenEndpoint], msg);

						// Use the other endpoint's basePath if it has one
						var pathTwo = ((this.endpoints[ep].basePath || '') + path).substring((this.endpoints[seenEndpoint].basePath || '').length);

						// Set the errors on the methods that have duplicate paths.
						this.endpoints[ep].paths[path][method] = Endpoints.disableEndpoint(this.endpoints[ep].paths[path][method], msg);
						this.endpoints[seenEndpoint].paths[pathTwo][method] = Endpoints.disableEndpoint(this.endpoints[seenEndpoint].paths[pathTwo][method], msg);
					} else {
						endpointsMap[pathSignature] = ep;
					}

					// if route clashes with API/Routes, disable the endpoint
					if (uniqueMap[pathSignature]) {
						msg = 'Duplicate Endpoint for path "' + method.toUpperCase() + ' ' + path + '": Multiple APIs or Routes registered for the same path and method\n';
						msg += spacer + 'to disable an API or Route, use `enabled: false`\n';
						msg += spacer + 'to disable flow based API endpoints group, use `x-enabled: { enabled: false }`';

						this.endpoints[ep] = Endpoints.disableEndpoint(this.endpoints[ep], msg);
						this.endpoints[ep].paths[path][method] = Endpoints.disableEndpoint(this.endpoints[ep].paths[path][method], msg);
					} else {
						uniqueMap[pathSignature] = true;
					}
				}.bind(this));
			}.bind(this));
		}.bind(this));
		next();
	}.bind(this));

	// bind our apis
	tasks.push(function (next) {
		sortAPIsOrRoutes(this.apis);
		var keys = {};
		this.apis.forEach(function (api) {
			if (api.enabled) {
				// keep track of already bound apis and only bind once (save memory)
				var key = api.method + api.path;
				if (key in keys) {
					return;
				}
				keys[key] = 1;
				api.bind(instance.app);
			}
		});
		next();
	}.bind(this));

	// bind our endpoints to flows
	tasks.push(function (next) {
		Endpoints.bind(instance, this.endpoints, Swagger.schemaIdToSwaggerName);
		next();
	}.bind(this));

	// bind our routes
	tasks.push(function (next) {
		sortAPIsOrRoutes(this.routes);
		var keys = {};
		this.routes.forEach(function (route) {
			if (route.enabled) {
				// keep track of already bound routes and only bind once (save memory)
				var key = route.method + route.path;
				if (key in keys) {
					return;
				}
				keys[key] = 1;
				route.bind(instance.app);
			}
		});
		next();
	}.bind(this));

	// bind swagger routes
	tasks.push(function (next) {
		Swagger.bindRoutes(this);
		next();
	}.bind(this));

	// start the admin server
	tasks.push(function (next) {
		if (this.admin) {
			this.admin.start(this, next);
		} else {
			next();
		}
	}.bind(this));

	// start up the server
	tasks.push(function appListenTask(next) {
		this.emit('listening');
		if (process.send && process.connected) {
			process.send('listening');
		}
		if (this.config.ssl && (!inProduction || this.config.sslInProduction)) {
			var https = require('https');
			var sslPort = process.env.SSLPORT || this.config.ssl.port || 8443;
			this.sslServer = https.createServer(this.config.ssl, this.app).listen(sslPort);
			if (this.config.timeout !== undefined) {
				this.sslServer.setTimeout(this.config.timeout);
			}
			this.logger.info('SSL bound to port', sslPort);
			this.sslPort = sslPort;
		}
		this.server = this.app.listen(this.port, next);
		var nextSocketId = 0;
		this.server.on('connection', function (socket) {
			var socketId = nextSocketId++;
			openSockets[socketId] = socket;

			socket.on('close', function () {
				delete openSockets[socketId];
			});
		});

		if (this.config.timeout !== undefined) {
			this.server.setTimeout(this.config.timeout);
		}
	}.bind(this));

	tasks.push(function startedTask(next) {
		this.emit('listen');
		this.emit('started');
		if (process.send && process.connected) {
			process.send('listen');
			process.send('started');
		}
		this.proxy && listener && this.proxy.removeListener('connected', listener);
		servers.push(this);
		next();
	}.bind(this));

	if (process.argv.indexOf('--repl') >= 0) {
		tasks.push(function startRepl(next) {
			var server = this;
			process.nextTick(function () {
				console.log('');
				var r = require('repl').start({
					prompt: 'API Builder Tools> ',
					useColors: true,
					useGlobal: true
				});
				r.context.server = server;
				r.context.Arrow = Arrow;
				r.context._ = _;
				r.context.fs = fs;
				r.context.path = path;
				r.on('exit', function () {
					server.stop();
				});
			});
			next();
		}.bind(this));
	}

	async.series(tasks, function (err) {
		callback(err);
	});
};

Arrow.prototype.getModelSchemaId = function (model) {
	// schema id as per the ticket RDPP-1673
	return 'schema:///model/' + model.name;
};

Arrow.prototype.modelToSchema = function (model) {
	var required = [],
		properties = {},
		retVal = {};

	Object.keys(model.fields).forEach(function (name) {
		var field = model.fields[name];

		if (field.required) {
			required.push(name);
		}
		properties[name] = {};

		// Record any defaults or descriptions
		if ('default' in field) {
			properties[name].default = field.default;
		}
		if ('description' in field) {
			properties[name].description = field.description;
		}

		// Build out or properties object
		properties[name].type = field.type;
		switch (field.type) {
			case 'number':
				properties[name].type = 'integer';
				break;
			case 'boolean':
				properties[name].type = 'boolean';
				break;
			case 'date':
				properties[name].type = 'string';
				properties[name].format = 'date-time';
				break;
			case 'array':
				// TODO: We need more information about the array sub-type here. See RDPP-1672
				properties[name].items = {};
				break;
			case 'object':
				// TODO: We need more information about the object properties here. See RDPP-1672
				properties[name].additionalProperties = true;
				break;
			default:
				properties[name].type = 'string';
				break;
		}
		retVal = {
			type: 'object',
			properties: properties,
			id: this.getModelSchemaId(model)
		};
		if (required.length > 0) {
			retVal.required = required;
		}
	}.bind(this));
	return retVal;
};

/**
 * Generates the standardized APIs from all loaded models.
 */
Arrow.prototype.createAPIsFromModels = function () {
	Object.keys(this.models).forEach(function routeModelIterator(name) {
		var model = this.models[name];
		this.createAPIsFromModel(model);
	}.bind(this));
};

/**
 * Generates the standardized APIs from a particular model.
 */
Arrow.prototype.createAPIsFromModel = function (model) {
	if (model.connector && typeof model.connector === 'string') {
		try {
			model._connector = model.connector;
			model.connector = this.getConnector(model.connector, true);
			model.connector.emit('init-model', model);
		} catch (e) {
			this.logger.trace(e.stack);
			throw new Error('Error loading connector: ' + model._connector + ' for model: ' + model.name + '. ' + e.message);
		}
	}
	if (model.autogen) {
		var modelAPIs = makeAPIsFromModel(model, this.config.apiPrefix);
		modelAPIs.forEach(function modelAPIConstructorIterator(API) {
			var api = new API(this.objConfig, this);
			this.apis.push(api);
		}.bind(this));
	}
};

/**
 * Sort the APIs or Routes (we need wildcard paths to be registered later in the process).
 */
function sortAPIsOrRoutes(apisOrRoutes) {
	apisOrRoutes.sort(function (a, b) {
		if (a.sort < b.sort) {
			return 1;
		} else if (a.sort > b.sort) {
			return -1;
		}
		// shortest paths first
		return a.path.length > b.path.length;
	});
}

function makeAPIsFromModel(model, apiPrefix) {
	// if autogen off, don't generate APIs for Model
	if (!model.autogen || (model.connector && model.connector.enabled === false) || !model.connector) {
		return [];
	}

	var apis = [],
		name = model.name;

	model.prefix = model.prefix || apiPrefix + '/' + name.toLowerCase();
	model.singular = model.singular || pluralize(name.toLowerCase(), 1);
	model.plural = model.plural || pluralize(name.toLowerCase());

	for (var key in model) {
		if (key.slice(-3) === 'API') {
			var val = model[key],
				isAPIDescriptor = _.isFunction(val),
				describes = key.slice(0, -3),
				describesUC = describes.substr(0, 1).toUpperCase() + describes.substr(1),
				enabled = true;

			if (!isAPIDescriptor) {
				continue;
			}
			var api = model[key]();
			if (!api) {
				continue;
			}

			// Check to see if the underlying connector has the necessary methods to support this API.
			var connectorMethods = (api.dependsOnAny || api.dependsOnAll || [ describes ]).filter(function (depConnectorMethod) {
				return !!model.getConnector()[depConnectorMethod];
			});
			if (connectorMethods.length < (api.dependsOnAll ? api.dependsOnAll.length : 1)) {
				enabled = false;
				delete api.enabled;
			}

			// Should we disable based on our action or action groups being disabled?
			if (model.actions.indexOf(describes) === -1 && (!api.actionGroup || model.actions.indexOf(api.actionGroup) === -1)) {
				enabled = false;
			}
			if (model.disabledActions && model.disabledActions.indexOf(describes) >= 0) {
				enabled = false;
				delete api.enabled;
			}

			// Handle some defaults for the API.
			if (!api.path) {
				api.path = model.prefix;
			} else if (api.path.substr(0, 2) === './') {
				api.path = model.prefix + api.path.substr(1);
			}
			_.defaultsDeep(api, {
				responses: {
					401: {
						description: 'This request requires user authentication, as configured by the server.',
						schema: {
							$ref: '#/definitions/ErrorModel'
						}
					},
					404: {
						description: 'No results were found.',
						schema: {
							$ref: '#/definitions/ErrorModel'
						}
					},
					500: {
						description: 'Something went wrong during the request; check out the logs on your server.',
						schema: {
							$ref: '#/definitions/ErrorModel'
						}
					},
					504: {
						description: 'The request took too long to process, and the server timed it out.',
						schema: {
							$ref: '#/definitions/ErrorModel'
						}
					},
					default: {
						description: 'Response from Server',
						schema: {
							$ref: '#/definitions/ResponseModel'
						}
					}
				}
			});

			apis.push(API.extend(_.defaults(api, {
				uiSort: Number.MAX_VALUE,
				enabled: enabled,
				generated: true,
				group: name,
				describes: describes,
				method: 'GET',
				parameters: {},
				singular: model.singular,
				plural: model.plural,
				model: name,
				pre: _.flatten(_.compact([
					model['pre' + describesUC], model['before' + describesUC],
					model['pre' + (api.method || 'GET')], model['before' + (api.method || 'GET')],
					model.pre, model.before
				])),
				post: _.flatten(_.compact([
					model['post' + describesUC], model['after' + describesUC],
					model['post' + (api.method || 'GET')], model['after' + (api.method || 'GET')],
					model.post, model.after
				]))
			})));
		}
	}

	return apis;
}

/**
 * Removes an API from the server.
 * @param {String} filename Name of the file of the API to remove.
 * @param {Function} [callback] Callback function passed an Error object (or null if successful).
 */
Arrow.prototype.removeAPIByFilename = function removeAPIByFilename(filename, callback) {
	var api = _.filter(this.apis, function (api) {
		return api.filename === filename;
	})[0];

	if (api) {
		api.remove(this, function (err) {
			this.triggerReloadedIfRequired(true, { filename: api }, err);
			callback && callback();
		}.bind(this));
	} else {
		callback && callback(new Error('couldn\'t find an API at ' + filename));
	}
};

/**
 * Reloads any changes found in Models, Blocks, Routes or APIs.
 * @param {Function} [callback] Callback to execute after the reload.
 */
Arrow.prototype.reload = function reload(callback) {
	this.logger.debug('reload called');
	this.stop(function () {
		delete this.config.apikey;
		globalArrow = new Arrow(this.config);
		globalArrow.start(function (err) {
			if (!err) {
				this.logger.debug('reload finished!');
			}
			if (callback) {
				callback(err);
			} else if (err) {
				this.emit('error', err);
			}
		}.bind(this));
	}.bind(this));
};

/**
 * Stops the Arrow server instance.
 * @param {Function} [callback] Callback to execute after the server stops.
 */
Arrow.prototype.stop = function stop(callback) {
	this.shuttingdown = true;

	if (!this.server) {
		this.logger.debug('stop called but server not started');
	}

	var tasks = [];

	// NOTE: the timing on this part of code is particularly sensitive to log_test
	// and tx_log_test (or at least I think it was timing).  The `schemas.clear`
	// used to reload global schemas on clear, but found that the child in log_test
	// was being prematurely exiting on `schemas.clear`.  Fixing the schemas so that
	// it did not reload, fixed the issue.  I doubt this will be the last time we
	// revisit the log_test/child timing issue.

	// clear schemas
	tasks.push(function (next) {
		this.logger.trace('clearing schemas');
		schemas.clear();
		next();
	}.bind(this));

	if (this.server && !this.stopped) {
		for (var c = 0; c < servers.length; c++) {
			var server = servers[c];
			if (server === this) {
				servers.splice(c, 1);
				break;
			}
		}

		this.stopped = true;
		this.logger.debug('stopping');
		this.emit('stopping');
		if (process.send && process.connected) {
			process.send('stopping');
		}

		// first stop the server so we don't serve request
		tasks.push(function serverCloseTask(next) {
			try {
				// ignore any errors on shutdown
				this.server.close(function () {
					next();
				});

				Object.keys(openSockets).forEach(function (socketID) {
					openSockets[socketID].destroy();
				});
			} catch (e) {
				next();
			}
		}.bind(this));

		// stop the SSL server if we have one
		if (this.sslServer) {
			tasks.push(function serverCloseTask(next) {
				try {
					// ignore any errors on shutdown
					this.sslServer.close(function () {
						next();
					});
				} catch (e) {
					next();
				}
			}.bind(this));
		}

		/**
		 * Disconnect all connectors if provided a disconnect method
		 * Delete the models associated with the connector (generated and fs)
		 * so that we don't run into duplicate errors when loadComponents tries to load fs models.
		 * Delete the _createdModelsFromSchema flag so arrow-orm knows to re-grab models from schema (generated).
		 * Delete connector.started so startConnector() will kick off
		 */
		Object.keys(connectors).forEach(function stopConnectorIterator(name) {
			var connector = connectors[name];
			connector.disconnect && tasks.push(function connectorDisconnectTask(next) {
				connector.disconnect(next);
			});

			tasks.push(function resetConnectors(next) {
				delete connectors[name];
				next();
			});
		});

		// stop the handlerbars watcher if running
		tasks.push(function (next) {
			var handlebars = this.getMiddleware().getRendererEngine('hbs');
			handlebars && handlebars.cleanupWatchers();
			next();
		}.bind(this));

		// now fire our lifecycle event
		async.series(tasks, function asyncCallback() {
			this.emit('stopped');
			if (process.send && process.connected) {
				process.send('stopped');
			}
			this.logger.info('Server stopped');
			loadedModelDirs = [];
			callback && callback();
		}.bind(this));
	} else {
		async.series(tasks, function asyncCallback() {
			this.logger.info('Server stopped');
			loadedModelDirs = [];
			callback && callback();
		}.bind(this));
	}

	// Unregister node handlers.  This is not done as a task because it is possible
	// to be partially started (and fail).  These need to be done reglardless of
	// start state.
	this.registeredNodes.forEach(function (uri) {
		this.flowManager.unregisterNode(uri);
	}.bind(this));
	this.registeredNodes = [];
	unregisterFlowCoreNodeHandlers(this.flowManager);
	unregisterArrowNodeHandlers(this);

	// Unregister service connector node handlers
	Object.keys(this.serviceconnectors).forEach(function (fn) {
		this.serviceconnectors[fn].unregister(this);
	}.bind(this));
	this.serviceconnectors = {};
};

/**
 * @method createLogger
 * Creates a logger instance.
 * @param {Object} config
 * @param {Object} opts Additional initialization options.
 * Refer to the [bunyan documentation](https://www.npmjs.com/package/bunyan).
 * @returns {Arrow.Logger}
 */
/**
 * @method createLogger
 * @static
 * Creates a logger instance.
 * @param {Object} config
 * @param {Object} opts Additional initialization options.
 * Refer to the [bunyan documentation](https://www.npmjs.com/package/bunyan).
 * @returns {Arrow.Logger}
 */
Arrow.prototype.createLogger
	= Arrow.createLogger = function createLogger(config, opts) {
		return Logger.createLogger(merge(config, opts));
	};

// create a continuation monkey patch in the case the server hasn't yet loaded
// and we've created a Model
function createModelClassContinuationPatch(Model) {
	if (globalArrow && !globalArrow.loaded) {
		// monkey patch any methods that must have a valid connector that is running before we can call it
		var methods = [
			'create', 'delete', 'replace', 'save', 'update', 'delete', 'deleteAll', 'find', 'findAll', 'findByID',
			'findById', 'findOne', 'fetch', 'query', 'remove', 'removeAll'
		];
		methods.forEach(function (fnName) {
			var ModelFn = Model[fnName];
			if (ModelFn) {
				Model[fnName] = createModelMethodMonkeyPatch(Model, ModelFn, fnName);
			}
		});

		// unwrap the methods after the arrow loads
		function builderLoader() {
			var methods = [
				'create', 'delete', 'replace', 'save', 'update', 'delete', 'deleteAll', 'find', 'findAll', 'findByID',
				'findById', 'findOne', 'fetch', 'query', 'remove', 'removeAll'
			];
			methods.forEach(function (fnName) {
				if (Model[fnName] && Model[fnName].originalFunction) {
					Model[fnName] = Model[fnName].originalFunction;
				}
			});
			globalArrow.removeListener('loaded', builderLoader);
		}
		globalArrow.on('loaded', builderLoader);
	}
}

// create a function wrapper that will watch for the server to finish loading
// (which will have started the connectors) before we actually continue with the
// function. the method (fn) being passed in must be async for this to work
function createModelMethodMonkeyPatch(ModelClass, fn, name) {
	// if we're not yet loaded, we can't call methods against the
	// ModelClass. in which case we're going to wait until we're loaded
	// and then once loaded, we'll continue
	function modelMethodMonkeyPatched() {
		var args = arguments;
		function builderLoader() {
			// make sure we resolve the connector to the real connector instance
			if (typeof ModelClass.connector === 'string') {
				ModelClass.connector = Arrow.getConnector(ModelClass.connector);
			}
			globalArrow.removeListener('loaded', builderLoader);
			// re-patch it back to the original so subsequent doesn't come back through this block anymore
			ModelClass[name] = fn;
			// go ahead invoke
			return fn.apply(ModelClass, args);
		}
		// wait for loaded to fire
		if (globalArrow.loaded) {
			builderLoader();
		} else {
			globalArrow.on('loaded', builderLoader);
		}
	}

	modelMethodMonkeyPatched.originalFunction = fn;

	return modelMethodMonkeyPatched;
}

/*
 * monkey patch Model.extend to make sure that we set the instance of the
 * connector before returning
 */
var ModelExtend = Arrow.Model.extend;
var ModelReduce = Arrow.Model.reduce;

Arrow.Model.extend = createModelMonkeyPatch(ModelExtend, 'extend');
Arrow.Model.reduce = createModelMonkeyPatch(ModelReduce, 'reduce');

function createModelMonkeyPatch(ModelClass, method) {
	function createModel() {
		// if we're extending a named model, resolve it first
		var model;
		if (arguments.length === 3) {
			// if we're in the middle of loading models on startup, we need to deal
			// with the case we are extending a model that has not been loaded yet,
			// in which case we want to record the dependency and then load later
			if (globalArrow && globalArrow.loadingModels) {
				var args = arguments,
					self = this;
				function fn() {
					globalArrow.removeListener('loadedModels', fn);
					return createModel.apply(self, args);
				}
				return globalArrow.on('loadedModels', fn);
			}
			// tricky. we need to check to see if the incoming connector referenced by
			// the new model is referencing a connector that is disabled and if so, just
			// return null so that the model load just fails silently (which is OK)
			if (arguments[2].connector) {
				var connector = typeof arguments[2].connector === 'string' ? Arrow.getConnector(arguments[2].connector) : arguments[2].connector;
				if (connector && !connector.enabled) {
					var connectorName = connector.name || arguments[2].connector;
					globalArrow && globalArrow.logger.debug('connector (' + connectorName + ') disabled, skipping model', arguments[1]);
					return;
				}
			}
			var extendModel = typeof arguments[0] === 'string' ? Arrow.getModel(arguments[0], true) : arguments[0],
				name = arguments[1],
				def = arguments[2];
			model = extendModel[method](name, def);
			// we need to set in case it wasn't set. this happens in cases where we loaded async
			model.name = name;
			model._parent = extendModel;
			model._supermodel = extendModel.name;
			if (!model.connector) {
				model.connector = extendModel.connector;
			}
			// if the extended model is autogen (like a built-in connector model) but we didn't
			// specify one in our own definition, assume we want to autogen it
			if (!extendModel.autogen && def.autogen === undefined) {
				model.autogen = true;
			}
			// make sure we record it. this happens in the case we async load and we didn't put it in
			// because of that...
			if (!isModelDuplicate(model.name)) {
				globalArrow.models[model.name] = model;
			}
		} else {
			// else we're creating a simple new model
			model = ModelClass.apply(Arrow.Model, arguments);
			isModelDuplicate(model.name);
		}

		if (model.connector && typeof model.connector === 'string') {
			// if we're running and we have a string, resolve it
			if (globalArrow && globalArrow.loaded) {
				model._connector = model.connector;
				model.connector = Arrow.getConnector(model.connector, true);
				model.connector.emit('init-model', model);
			} else {
				// we need to monkey patch to create continuation
				createModelClassContinuationPatch(model);
			}
		} else if (model.connector) {
			model.connector.emit('init-model', model);
		}

		return model;
	}
	return createModel;
}

/**
 * Creates a model class.
 * @static
 * @param {String} name Name of the new Model.
 * @param {ArrowModelDefinition} definition Model definition object.
 * @returns {Arrow.Model}
 */
Arrow.createModel = function _createModel() {
	return globalArrow.createModel.apply(globalArrow, arguments);
};

/**
 * @method createModel
 * @alias #static-method-createModel
 */
Arrow.prototype.createModel = Arrow.Model.extend;

/**
 * Adds a model class(es) on this instance.
 * @param {Arrow.Model/Array<Arrow.Model>} model Model class(es) to add.
 */
Arrow.prototype.addModel = function addModel() {
	for (var c = 0; c < arguments.length; c++) {
		var ModelClass = arguments[c];
		if (!isModelDuplicate(ModelClass.name)) {
			this.models[ModelClass.name] = ModelClass;
		}
		// Has the server already started?
		if (this.server) {
			var startAt = this.apis.length;
			this.createAPIsFromModel(ModelClass);
			for (var i = startAt; i < this.apis.length; i++) {
				this.apis[i].bind(this.app);
			}
		}
	}
};

/**
 * Gets a model by name.
 * @static
 * @param {String} name Name of the model to retrieve.
 * @param {Boolean} [failIfMissing] Set to `true` to throw an error if the model could not be found.
 * @returns {Arrow.Model}
 * @throws Error
 */
Arrow.getModel = function _getModel() {
	return globalArrow && globalArrow.getModel.apply(globalArrow, arguments);
};

/**
 * @alias #static-method-getModel
 */
Arrow.prototype.getModel = function getModel(name, failIfMissing) {
	// in case you specify connector/appc.mysql/model - strip out the connector portion
	name = String(name || '').replace('connector/', '');
	var result = this.models[name];
	if (!result) {
		var tokens = name.split('/');
		if (tokens.length > 1) {
			var connectorName = tokens[0],
				modelName = tokens[1],
				connector = connectors[connectorName];
			if (!connector && failIfMissing) {
				throw new Error('Couldn\'t find connector named: ' + connectorName);
			}
			result = connector && connector.models && (connector.models[modelName] || connector.models[connectorName + '/' + modelName] || connector.models[connector.name + '/' + modelName]);
		}
	}
	if (!result && failIfMissing) {
		throw new Error('Couldn\'t find model named: ' + name);
	}
	return result;
};

/**
 * Gets an array of APIs available to the instance.
 * @returns {Array<Arrow.API>}
 */
Arrow.prototype.getAPIs = function getAPIs() {
	return this.apis;
};

/**
 * Returns an API for the given path and optional method in the case where more than one method.
 * may be invoked on a path. If you defined a nickname when creating the API instance, you may pass
 * the nickname to the function rather than the path and method.
 * @param {String} path Path of the API (or its nickname).
 * @param {String} [method] HTTP verb.
 * @returns {Arrow.API}
 */
Arrow.prototype.getAPI = function getAPI(path, method) {
	var pathAsRoute = path;
	if (path.substring(0, 1) !== '/') {
		pathAsRoute = '/' + path;
	}
	for (var c = 0; c < this.apis.length; c++) {
		if ((this.apis[c].path === pathAsRoute
			|| this.apis[c].nickname === path) && (!method || (method && this.apis[c].method.toUpperCase() === method.toUpperCase()))) {
			return this.apis[c];
		}
	}
};

/**
 * Adds an API on this instance.
 * @param {Arrow.API} api API to add.
 */
Arrow.prototype.addAPI = function addAPI(APIConstructor) {
	if (_.isFunction(APIConstructor)) {
		var api = new APIConstructor(this.config, this);
		this.apis.push(api);
	} else {
		this.apis.push(APIConstructor);
	}
};

/**
 * Gets all models availabe to the instance.
 * @returns {Array<Arrow.Model>}
 */
Arrow.prototype.getModels = function getModels() {
	return this.models;
};

/**
 * Gets a block by name.
 * @param {String} name Name of the block to retrieve.
 * @param {Boolean} [failIfMissing] Set to `true` to throw an error if the block could not be found.
 * @returns {Arrow.Block}
 * @throws Error
 */
Arrow.prototype.getBlock = function getBlock(name, failIfMissing) {
	var result = this.blocks[name];
	if (!result && failIfMissing) {
		throw new Error('Couldn\'t find block named: ' + name);
	}
	return result;
};

/**
 * Gets all the flow definitions availabe to the instance.
 * @returns {Object}
 */
Arrow.prototype.getFlows = function getFlows() {
	return this.flowManager.getFlows();
};

/**
 * Gets the flow definition by id.
 * @param {String} flowId The id of the flow to retrieve.
 * @returns {Object}
 */
Arrow.prototype.getFlow = function getFlow(flowId) {
	return this.flowManager.getFlow(flowId);
};

/**
 * gets the schema for a specific node handlers
 * @param  {string} type - type/name of the schema
 * @return {Object}      - the schema for the handler
 */
Arrow.prototype.getRegisteredNodeSpec = function getRegisteredNodeSpec(type) {
	return this.flowManager.getRegisteredNodeSpec(type);
};

/**
 * gets all the schemas for the node handlers
 * @return {Object} - the schemas for the handlers
 */
Arrow.prototype.getRegisteredNodeSpecs = function getRegisteredNodeSpecs() {
	return this.flowManager.getRegisteredNodeSpecs();
};

/**
 * Gets an endpoint by path
 * @param  {String} endpoint The endpoint to get. ie '/greet'
 * @return {Object} or undefined
 */
Arrow.prototype.getEndpoint = function (endpoint) {
	return this.endpoints[endpoint];
};

/**
 * Gets all loaded endpoints
 * @return {Object}
 */
Arrow.prototype.getEndpoints = function () {
	return this.endpoints || {};
};

/**
 * Gets a route by name.
 * @param {String} name Name of the route to retrieve.
 * @param {Boolean} [failIfMissing] Set to `true` to throw an error if the route could not be found.
 * @returns {Arrow.Router}
 * @throws Error
 */
Arrow.prototype.getRoute = function getBlock(name, failIfMissing) {
	var result = _.find(this.routes, { name: name });
	if (!result && failIfMissing) {
		throw new Error('Couldn\'t find route named: ' + name);
	}
	return result;
};

/**
 * Adds the block(s) on this instance.
 * @param {Arrow.Block/Array<Arrow.Block>} block Block(s) to add.
 */
Arrow.prototype.addBlock = function () {
	for (var c = 0; c < arguments.length; c++) {
		var Block = arguments[c];
		this.blocks[Block.name] = Block;
	}
};

/**
 * Gets all blocks.
 * @returns Array<Arrow.Block>
 */
Arrow.prototype.getBlocks = function getBlocks() {
	return this.blocks;
};

/**
 * Gets a codeblock by name.
 * @param {String} name Name of the codeblock to retrieve.
 * @param {Boolean} [failIfMissing] Set to `true` to throw an error if the codeblock could not be found.
 * @returns {Arrow.Codeblock}
 * @throws Error
 */
Arrow.prototype.getCodeblock = function getCodeblock(name, failIfMissing) {
	var result = this.codeblocks[name];
	if (!result && failIfMissing) {
		throw new Error('Couldn\'t find codeblock named: ' + name);
	}
	return result;
};

/**
 * Gets all codeblocks.
 * @returns Array<Arrow.Codeblock>
 */
Arrow.prototype.getCodeblocks = function getCodeblocks() {
	return this.codeblocks;
};

/**
 * Returns a registered connector by name.
 * @static
 * @param {String} name Name of the connector to retrieve.
 * @param {Boolean} [failIfMissing] Set to `true` to throw an error if the connector could not be found.
 * @throws Error
 */
Arrow.getConnector = function _getConnector() {
	if (!globalArrow) {
		throw new Error('an Arrow instance has not yet been created');
	}
	return globalArrow.getConnector.apply(globalArrow, arguments);
};

/**
 * Gets a connector by name.
 * @param {String} name Name of the connector to retrieve.
 * @param {Boolean} [failIfMissing] Set to `true` to throw an error if the connector could not be found.
 * @throws Error
 */
Arrow.prototype.getConnector = function getConnector(name, failIfMissing) {
	if (!name) {
		throw new Error('missing name');
	}
	// trim off in case you specific connector/appc.salesforce which is acceptable
	name = name.replace('connector/', '');
	var found = connectors[name],
		askedName = name;
	if (!found) {
		if (name === 'memory') {
			// use memory if not found and specified. this is nice for testing
			connectors[name] = found = new Arrow.MemoryConnector();
			return found;
		}
		var config = this.config || new Loader() || {};
		// see if this is a mapped connector and if so, lookup the real connector
		if (config.connectors && name in config.connectors) {
			config = config.connectors[name];
			name = config.connector || askedName;
			config = config.config || config;
			// Note: we don't grab the cached `connectors[name]` because we need our own instance.
		} else if (config.connectors) {
			// not found, let's see if we have a connector specified
			var connectorsFound = _.filter(_.values(config.connectors), function (entry) {
				return entry.connector && entry.connector === askedName;
			});
			if (connectorsFound.length > 1) {
				this.logger.warn('Found ' + connectorsFound.length + ' connector configurations for ' + askedName + '. '
					+ 'Using the first one found. If this isn\'t the right connector, use the correct alias name to '
					+ 'specify the right connector');
				connectorsFound = [ connectorsFound[0] ];
			}
			if (connectorsFound.length === 1) {
				name = connectorsFound[0].connector || askedName;
				config = connectorsFound[0].config || connectorsFound[0];
			}
		}
		try {
			var ConnectorFactory = paths.findComponent('connector', name);
			if (ConnectorFactory) {
				if (!ConnectorFactory.create) {
					throw new Error(name + ' must be updated to use the Connector Factory API.  See https://jira.appcelerator.org/browse/API-138');
				}
				// re-entrant flag in case a Connector inadvertently calls Arrow.loadModelsForConnector
				// during this ConnectorFactory.create which will cause us to re-enter this method into an
				// infinite recursion problem .. so we note and then do it again later if we have this happen
				inGetConnector = true;
				var Connector = ConnectorFactory.create(Arrow, this);
				inGetConnector = false;
				found = new Connector(config[name] || config || {});
				if (found) {
					found.name = askedName;
					connectors[askedName] = found;
					// if we have a post create lifecycle callback, call it
					// this will allow connectors to do things like call Arrow.loadModelsForConnector
					// after the connector is instantiated but before it is returned. If we don't do this
					// we will get into an infinite loop where things done in the constructor (like load models)
					// that require the connector will attempt to re-instantiate the connector again (since it's not done registering)
					if (pendingModels) {
						found.models = Arrow.loadModelsForConnector(found.name, pendingModels.module, pendingModels.dir);
						pendingModels = null;
					}
					if (found.postCreate) {
						found.postCreate.call(found);
					}
				}
			}
		} catch (e) {
			this.logger.error('Error loading connector: ' + name, e);
			throw e;
		}
	}
	if (!found && name === 'memory') {
		// use memory if not found and specified. this is nice for testing
		connectors[name] = found = new Arrow.MemoryConnector();
	}
	if (!found && failIfMissing) {
		throw new Error('Couldn\'t find connector named: ' + name);
	}
	return found;
};

/**
 * @method getConnectors
 * Gets a list of registered connectors.
 * @static
 * @returns {Array<Arrow.Connector>}
 */
/**
 * @method getConnectors
 * @alias #static-method-getConnectors
 */
Arrow.getConnectors
	= Arrow.prototype.getConnectors = function getConnectors() {
		var combinedConnectors = Object.assign({}, connectors);
		var specs = this.flowManager.getRegisteredNodeSpecs();
		Object.keys(specs)
			.filter(function (type) {
				return type.startsWith('nodehandler://service-connector');
			})
			.forEach(function (type) {
				const spec = specs[type];
				combinedConnectors[type] = {
					version: spec.version,
					name: spec.name,
					description: spec.description,
					// orm glue
					config: {
						documented: false
					}
				};
			});
		return combinedConnectors;
	};

/**
 * @method registerConnector
 * @static
 * Registers a connector.
 * @param {Arrow.Connector} connector Connector to register.
 */
/**
 * @method registerConnector
 * @alias #static-method-registerConnector
 */
Arrow.registerConnector
	= Arrow.prototype.registerConnector = function registerConnector(connector) {
		connectors[connector.name] = connector;

		// attach a get model convenience function on the connector
		if (!connector.getModel) {
			connector.getModel = function (name) {
				return this.models && (this.models[name] || this.models[this.name + '/' + name]);
			};
		}

		if (connector.models) {
			Object.keys(connector.models).forEach(function keyIterator(name) {
				var model = connector.models[name];
				// map to the real connector instance
				model.connector = connector;
			});
		}
	};

// listen for connectors that are being created
Connector.on('register', Arrow.registerConnector);

function loadModels(models, dir, connectorName) {
	if (loadedModelDirs.indexOf(dir) >= 0) {
		return;
	}
	loadedModelDirs.push(dir);
	fs.readdirSync(dir).forEach(function modelResolver(name) {
		var p = path.join(dir, name);
		if (fs.statSync(p).isDirectory()) {
			loadModels(models, p, connectorName);
		} else if (path.extname(p) === '.js' && path.basename(p).charAt(0) !== '_') {
			// only do .js files that don't start with _
			var model = paths.requireComponent(p);
			if (model && !(model.name in models)) {
				if (model.fields && Object.keys(model.fields).length) {
					models[model.name] = model;
					globalArrow && (model.connector = Arrow.getConnector(connectorName));
					model.filename = p;
					globalArrow && globalArrow.addModel(model);
				}
			} else {
				throw new Error('Model: ' + model.name + ' already exists in connector: ' + connectorName);
			}
		}
	});
}

/**
 * Removes a model from this instance.
 * @param {Arrow.Model} model Model to remove.
 */
Arrow.prototype.removeModel = function (model) {
	delete this.models[model.name];
};

/**
 * Removes a connector.
 * @param {Arrow.Connector} connector Connector to remove.
 */
Arrow.prototype.removeConnector = function (connector) {
	delete this.connectors[connector.name];
};

/**
 * Removes a block.
 * @param {Arrow.Block} block Block to remove.
 */
Arrow.prototype.removeBlock = function (block) {
	delete this.blocks[block.name];
};

/**
 * Removes an API.
 * @param {Arrow.API} api API to remove.
 */
Arrow.prototype.removeAPI = function (api) {
	for (var c = 0; c < this.apis.length; c++) {
		var a = this.apis[c];
		// eslint-disable-next-line security/detect-possible-timing-attacks
		if (a === api) {
			this.apis.splice(c, 1);
			break;
		}
	}
	api.remove(this);
};

/**
 * Removes a route.
 * @param {Arrow.Router} route Route to remove.
 */
Arrow.prototype.removeRoute = function (route) {
	if (route) {
		for (var i = 0; i < this.routes.length; i++) {
			var currentRoute = this.routes[i];
			if (currentRoute === route) {
				this.routes.splice(i, 1);
				break;
			}
		}
		route.remove(this);
	}
};

/**
 * returns an Arrow toJSON description
 */
Arrow.prototype.toJSON = function () {
	return '[object Arrow]';
};

/**
 * returns an util.inspect description
 */
Arrow.prototype.inspect = function () {
	return '[object Arrow]';
};

/**
 * Dynamically loads the models into the server if the connector updates them dynamically
 * (i.e. after connect has run and started);
 */
Arrow.prototype.registerModelsForConnector = function registerModelsForConnector(connector, models) {
	if (!models || !_.isObject(models)) {
		throw new Error('Invalid argument passed to registerModelsForConnector: connector/' + connector.name + '; models must be an object.');
	}

	// Remove models that have no fields as they are not usable.
	models = Object.keys(models).reduce(function (col, name) {
		if (models[name].fields && Object.keys(models[name].fields).length) {
			col[name] = models[name];
		}
		return col;
	}, {});

	Object.keys(models).forEach(function (name) {
		var Model = models[name];
		if (Model.visible || Model.visible === undefined) {
			this.models[name] = Model;
		}
	}.bind(this));
};

/**
 * Called by a connector to attempt to load any connector bundled models.
 * @param {String} connectorName Name of the connector.
 * @param {Object} module Connector module instance.
 * @param {String} dir Directory of the connector's models. Default is the connector's models folder.
 */
Arrow.loadModelsForConnector = function loadModelsForConnector(connectorName, module, dir) {
	if (inGetConnector) {
		// handle re-entrant issue with ConnectorFactory that calls this during
		// instantiation if we're still loading. will cause us to do this after its done
		pendingModels = { module: module, dir: dir };
		return;
	}
	var modelsDir = path.resolve(dir || path.join(path.dirname(path.dirname(module.filename)), 'models'));

	// attempt to load any models packaged with the connector
	if (fs.existsSync(modelsDir)) {
		var models = {};
		loadModels(models, modelsDir, connectorName);
		return models;
	}
};

// map helper functions
Arrow.pluralize = function doPluralize(name) {
	return pluralize(name);
};

Arrow.singularize = function doSingularize(name) {
	return pluralize(name, 1);
};

function createRequestTransaction(config) {
	var logging = config.logging || {},
		prefix = config.prefix,
		enabled = logging.transactionLogEnabled === undefined || logging.transactionLogEnabled;
	return function requestTx(req, resp, next) {
		// handle serialization to the log so that we only dump a subset of the object
		req.inspect = function () {
			return '[object Request]';
		};
		req.toJSON = function () {
			return req.log.serializers.req(req);
		};
		resp.inspect = function () {
			return '[object Response]';
		};
		resp.toJSON = function () {
			return req.log.serializers.res(resp);
		};
		if (!req.url || (req.url && req.url.indexOf(prefix) === 0) || !enabled) {
			req.logmetadata = false;
			return next();
		}
		req.tx = new RequestTx(req, resp, prefix);
		next();
	};
}

/**
 * called at the end of a request once it's done sending
 */
function endRequestTransaction(req, resp) {
	if (req.pendingReqCount) {
		pendingRequests--;
		if (pendingRequests < 0) {
			pendingRequests = 0;
		}
		req.pendingReqCount = null;
		var logger = req.server.logger;
		// always fire since this also handles request logger in addition to transaction logger
		this.emit('txdone', req, resp);
		if (req.tx) {
			req.tx.done();
			req.tx = null;
		} else if (req.cleanStream) {
			req.cleanStream();
			req.cleanStream = null;
		}
		// if no pending requests and we haven't do a GC in awhile, let's attempt to GC if
		// our heap usage is >1M
		if (memwatch && pendingRequests === 0 && (Date.now() - lastGCCheck) > 60000) {
			lastGCCheck = Date.now();
			var heapUsed = process.memoryUsage().heapUsed / 1024;
			if (heapUsed > 1000000) {
				(logger.debug || consoleLog)('triggering gc, heap usage', heapUsed + 'k');
				memwatch.gc();
			}
		}
	}
}

// shutdown all servers and then exit
function shutdownAllServers(exitCode, dontexit) {
	if (stopping) {
		return;
	}
	stopping = true;
	exitCode = exitCode === undefined ? 0 : exitCode;
	async.each(servers, function (server, cb) {
		server.stop(cb);
	}, function () {
		stopping = false;
		if (dontexit) {
			return;
		}
		process.exit(exitCode || 0);
	});
}

// restart all servers by first stopping and then restarting them
function restartAllServers() {
	if (stopping) {
		return;
	}
	async.each(servers, function (server, cb) {
		server.pendingReload = true;
		server.loaded = false;
		server.stop(function (err) {
			if (err) {
				return cb(err);
			}
			stopping = false;
			pendingRequests = 0;
			server.pendingReload = false;
			server.start(function (err) {
				server.loaded = true;
				cb(err);
			});
		});
	});
}

// if not in production, remove our local logs on each shutdown
if (!inProduction) {
	debug('removing temporary log directory when in development on startup');
	process.on('exit', function (ec) {
		try {
			var logdir = Logger.arrowCloudLogDir || path.join((globalArrow && globalArrow.config.dir) || process.cwd(), 'logs');
			fs.removeSync(logdir);
		} catch (e) {
			// ignore any errors
		}
		cluster.isMaster && process.exit(ec);
	});
}

// normal shutdown type signals
// for now, we're going to ignore SIGHUP since that can be sent on terminal
// disconnect or backgrounding
// we only use this when we're not in cluster mode. otherwise, let the cluster handle below
// if we are in master, assume that we aren't running with cluster (such as unit tests)
if (cluster.isMaster || cluster.isWorker) {
	[ 'exit', 'SIGINT', 'SIGTERM', 'SIGQUIT' ].forEach(function (name) {
		process.on(name, () => shutdownAllServers(0));
	});

	// restart if we receive the SIGUSR2 signal
	process.on('SIGUSR2', function () {
		consoleLog('arrow.js: signal received SIGUSR2 restarting');
		restartAllServers();
	});
}

// on SIGABRT we are going to send an abort which should core on *nix platforms
process.on('SIGABRT', function () {
	shutdownAllServers(0, true);
	process.abort();
});

// monitor any unhandled exceptions
process.on('uncaughtException', function (error) {
	if (_.isObject(error)) {
		consoleLog('Uncaught Exception', error.message);
		try {
			error.stack && consoleLog(error.stack);
		} catch (e) {
			// Ignore errors
		}
	} else {
		consoleLog('Uncaught Exception', error);
	}
	// if we get an unhandled exception we need to crash the process
	process.exit(1);
});

// monitor any memory leaks
memwatch && memwatch.on('leak', function (info) {
	consoleLog('memory leak detected', info);
});

if (cluster.isWorker) {
	// monitor any cluster messages
	process.on('message', function (msg) {
		switch (msg) {
			case 'shutdown':
				return shutdownAllServers();
			case 'restart':
				return restartAllServers();
			default:
				break;
		}
	});
}
