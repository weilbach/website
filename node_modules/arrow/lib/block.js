/*
 * This code is closed source and Confidential and Proprietary to
 * Appcelerator, Inc. All Rights Reserved. This code MUST not be
 * modified, copied or otherwise redistributed without express
 * written permission of Appcelerator. This file is licensed as
 * part of the Appcelerator Platform and governed under the terms
 * of the Appcelerator license agreement.
 */

/**
 * @class Arrow.Block
 */
var merge = require('lodash.merge'),
	util = require('util'),
	events = require('events'),
	blocks = [],
	BlockClass = new events.EventEmitter();

util.inherits(Block, events.EventEmitter);

function Block(impl, config, arrow) {

	impl && merge(this, impl);

	this.arrow = arrow;

	// incoming constructor config should overwrite implementation
	this.config = merge(impl && impl.config || {}, config);

	// if we provided a constructor in our impl, use it
	if (this.constructor && this.constructor !== Block && !this.constructor.super_) {
		this.constructor.call(this);
		Block.constructor.call(this);
	}

	if (!this.name) {
		throw new Error('required name missing on Block');
	}
}

Block.on = function on() {
	BlockClass.on.apply(BlockClass, arguments);
};

Block.removeListener = function removeListener() {
	BlockClass.removeListener.apply(BlockClass, arguments);
};

Block.removeAllListeners = function removeAllListeners() {
	BlockClass.removeAllListeners.apply(BlockClass, arguments);
};

// NOTE: this is internal and only used by the test and should never be called directly
Block.clearBlocks = function clearBlocks() {
	blocks.length = 0;
};

/**
 * Returns a constructor function to generate a new Block.
 * Pass the constructor an Arrow configuration object and Arrow instance.
 * @static
 * @param {Dictionary<Arrow.Block>} impl Implementation object.
 * @returns {Function}
 * @throws {Error} Missing name parameter or not called from a valid Arrow instance.
 */
Block.extend = function classExtend(impl) {
	return function BlockConstructor(config, arrow) {
		if (!arrow) {
			throw new Error('invalid constructor. must be called with arrow instance as 2nd argument');
		}
		return new Block(impl, config, arrow);
	};
};

/**
 * Returns a constructor function to generate a new Block.
 * Pass the constructor an Arrow configuration object and Arrow instance.
 * @param {Dictionary<Arrow.Block>} impl Implementation object.
 * @returns {Function}
 * @throws {Error} Missing name parameter or not called from a valid Arrow instance.
 */
Block.prototype.extend = function instanceExtend(impl) {
	return Block.extend(merge(this, impl));
};

/**
 * Gets the middleware block that provides access to the
 * block's execute implementation.
 * Pass the function returned by this method a request object,
 * response object, and the function to call next.
 * @returns {Function}
 */
Block.prototype.getMiddleware = function getMiddleware() {
	var fn = function blockMiddleware(req, resp, next) {
		try {
			var blockFn = this.action || this.execute;
			if (blockFn) {
				if (blockFn.length === 3) {
					blockFn(req, resp, next);
				} else {
					blockFn(req, resp);
					next();
				}
			} else {
				return next();
			}
		} catch (e) {
			next(e);
		}
	}.bind(this);
	fn._name = 'block:' + this.name;
	fn.filename = this.filename;
	fn.description = this.description;
	return fn;
};

module.exports = Block;
