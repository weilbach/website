const ipaddr = require('ipaddr.js');

/**
 * Normalize an IP address to IPv6
 * @callback expressCallback
 * @param {string|object} addr - An IP address object or string as IPv4 or IPv6.
 * @return {object} An IPv6 address
 */
function getNormalizedIP(addr) {
	if (!addr) {
		return null;
	}
	if (typeof addr !== 'string') {
		addr = addr.toString();
	}
	if (ipaddr.IPv4.isValid(addr)) {
		// An IPv4 address can be mapped to an IPv6 address, e.g. 127.0.0.1 is
		// ::ffff:127.0.0.1
		return ipaddr.parse(addr).toIPv4MappedAddress();
	} else if (ipaddr.IPv6.isValid(addr)) {
		// Just parse IPv6 address
		return ipaddr.parse(addr);
	} else {
		return null;
	}
}

/**
 * Gets an array of IP filters capable of testing IPv4 and IPv6 addresses and ranges.
 *
 * @param {string[]} allowedIps - An array of IP addresses to allow.
 * @return {object[]} An array of IP filters, e.g. `filters.find(a => a.match(ip))`
 */
function getIPFilters(allowedIps = []) {
	if (!allowedIps) {
		return [];
	}
	return allowedIps.map((addr) => {
		if (ipaddr.IPv4.isValid(addr)) {
			// If the IP to test is IPv4, then it needs to be mapped to IPv6 equivalent.
			// The filter will conver the ip and test against `addr`.
			return {
				match: (ip) => {
					return ipaddr.parse(addr).toIPv4MappedAddress().match(ip, 128);
				}
			};
		} else if (ipaddr.IPv6.isValid(addr)) {
			// If the IP to test is IPv6, then just match it against `addr`.
			return {
				match: (ip) => {
					return ipaddr.parse(addr).match(ip, 128);
				}
			};
		} else if (addr.includes('/')) {
			// ^ FIXME: use is-cidr instead
			// If the address contains a slash, then it is a range.  Parse the CIDR range to
			// get the network segment bits.
			const [ segment, bits ] = ipaddr.parseCIDR(addr);

			return {
				match: (ip) => {
					if (segment.kind() === 'ipv4'
						&& ip.isIPv4MappedAddress
						&& ip.isIPv4MappedAddress()) {
						// The allowed range is IPv4, and the IP address is also IPv4 (as IPv6),
						// so convert IP back to IPv4 and test range.
						const ipv4 = ip.toIPv4Address();
						return ipv4.match(segment, bits);
					} else if (segment.kind() === 'ipv6') {
						// The allowed range is IPv6, and the IP address is IPv6, safe to match
						return ip.match(segment, bits);
					} else {
						// else, the ip/segment are incompatible
						return false;
					}
				}
			};
		} else {
			throw new Error(`Invalid IP address: ${addr}`);
		}
	});
}

/**
 * Express middleware to filter IPv4 and IPv6 addresses
 * @param {object} [options={}] - Filter options
 * @param {string[]} [allowedIps] - An array of IPv4 or IPv6 addresses.  If not provided or empty, no filtering is done.
 * @return {function} Express middleware function for IP filtering
 */
function expressFilterIP(options = {}) {
	const allowedIPaddrs = getIPFilters(options.allowedIps);

	// middleware
	return function (req, resp, next) {
		if (!options.allowedIps || !allowedIPaddrs.length) {
			// this filter is not configured to filter hosts, so allow all
			return next();
		}

		const ip = getNormalizedIP(req.ip);
		const found = ip && allowedIPaddrs.find((addr) => addr.match(ip, 128));
		if (found) {
			return next();
		} else {
			if (options.log) {
				const addr = ipaddr.parse(req.ip);
				let sip = req.ip;

				if (addr.isIPv4MappedAddress && addr.isIPv4MappedAddress()) {
					// if IPv6 and is a mapped IPv4 address, then convert it to IPv4 so
					// that it looks normal in the log.
					sip = addr.toIPv4Address(req.ip).toString();
				}
				options.log(`Access denied to IP address: ${sip}`);
			}
			return resp
				.set('Content-Type', 'text/plain; charset=utf-8')
				.status(403)
				.send('403 Forbidden');
		}
	};
}

module.exports = {
	getMiddleware: expressFilterIP,
	getNormalizedIP,
	getIPFilters
};
