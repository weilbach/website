var _ = require('lodash');
var chalk = require('chalk');
var util = require('util');
var om = require('arrow-objectmodel');
var Swagger = require('openapi-doc');
var pluralize = require('pluralize');
var schemas = require('axway-schema');

var verbMap = {
	POST: 'create',
	GET: 'find',
	PUT: 'update',
	DELETE: 'delete'
};

var ResponseModel = {
	type: 'object',
	required: [
		'success',
		'request-id'
	],
	additionalProperties: true,
	properties: {
		code: {
			type: 'integer',
			format: 'int32'
		},
		success: {
			type: 'boolean',
			default: false
		},
		'request-id': {
			type: 'string'
		},
		message: {
			type: 'string'
		},
		url: {
			type: 'string'
		}
	}
};

var ErrorModel = {
	type: 'object',
	required: [
		'message',
		'code',
		'success',
		'request-id'
	],
	properties: {
		code: {
			type: 'integer',
			format: 'int32'
		},
		success: {
			type: 'boolean',
			default: false
		},
		'request-id': {
			type: 'string'
		},
		message: {
			type: 'string'
		},
		url: {
			type: 'string'
		}
	}
};

module.exports.bindRoutes = bindRoutes;
module.exports.generateSwagger = generateSwagger;
module.exports.schemaIdToSwaggerName = schemaIdToSwaggerName;

/**
 * Converts a schema id to a swagger friendly name. Conversion as per the ticket RDPP-1673
 *
 * @param {object} arrow - Arrow instance
 * @param {string} id - Schema identifier, e.g. schema:///foo
 */
function schemaIdToSwaggerName(id) {
	if (id.startsWith('schema:///')) {
		var ids = id.slice(10).split('/');
		var name = ids.slice(1).join('_');

		if (ids[0] && ids[0] !== 'model') {
			name = ids[0] + '.' + name;
		}
		return name;
	}
	return id;
}

function bindRoutes(arrow) {
	var adminConfig = arrow.config.admin || {};
	var app = arrow.app;

	if (!adminConfig.disableAPIDoc || arrow.config.env === 'development') {
		var docsRoutePrefix = adminConfig.apiDocPrefix || '/apidoc';
		arrow.logger.trace('Registering swagger routes under path ' + docsRoutePrefix);
		app.get(docsRoutePrefix + '/docs.json', util.deprecate(getDefinition, docsRoutePrefix + '/swagger.json should be used instead.'));
		app.get(docsRoutePrefix + '/swagger.json', getDefinition);
		arrow.logger.info('Access the swagger API documentation at ' + chalk.yellow.underline(arrow.baseurl + docsRoutePrefix + '/swagger.json'));
	}

	var objectModel = new om.ObjectModel(arrow);
	function getDefinition(req, res) {
		try {
			var keys = Object.keys(req.query),
				typeKeys = keys.filter(function (a) {
					return a.startsWith('endpoints/') || a.startsWith('apis/');
				}),
				force = req.query.force ? (req.query.force === 'true' || req.query.force === '1') : false,
				host = objectModel.server.host ? objectModel.server.host : (req.get('host') || ('127.0.0.1' + (objectModel.server.port ? ':' + objectModel.server.port : ''))),
				name,
				type,
				result;
			// extract name and type. eg. ?apis/appc.arrowdb/acl (type=apis, name=appc.arrowdb/acl)
			if (typeKeys.length) {
				type = typeKeys[0].split('/')[0];
				name = typeKeys[0].substr(type.length + 1, typeKeys[0].length).replace(/\.(json|html)/g, '');
			}
			result = generateSwagger(arrow, host, objectModel, type, name, force);
			if (typeof result === 'number') {
				res.sendStatus(result);
			} else {
				res.set('Content-Type', 'application/json');
				res.send(result);
			}
		} catch (ex) {
			arrow.logger.error('Error generating swagger', ex);
			res.status(500).send({ error: 'Server error' });
		}
	}
}

/**
 * Get the models referenced by fields in model composition.
 */
function getCompositionModels(om, modelName, models) {
	var model = om.models[modelName];
	if (model) {
		var referencedModels = new Set(
			Object.keys(model.fields)
				.map(function (fieldName) {
					return model.fields[fieldName];
				})
				.filter(function (field) {
					return field.model && (field.type === 'array' || field.type === Array || field.type === 'object' || field.type === Object);
				})
				.map(function (field) {
					return field.model;
				})
				.filter(function (modelName) {
					return !models || !models.has(modelName);
				})
		);

		// Add the referenced models
		models = models || new Set();
		referencedModels.forEach(function (m) {
			models.add(m);
		});

		// Look for nested dependencies
		referencedModels.forEach(function (m) {
			getCompositionModels(om, m, models);
		});
	}

	return models;
}

// Get the models reference by the APIs
function getAPIModels(om) {
	var referenceModels = new Set();

	// Get a unique list of models reference by the API endpoints.
	Object.keys(om.apis).forEach(function (apiName) {
		var api = om.apis[apiName];
		referenceModels.add(apiName);
		(api.endpoints || []).forEach(function (endpoint) {
			if (endpoint.model) {
				referenceModels.add(endpoint.model);
			}
			if (endpoint.response) {
				referenceModels.add(endpoint.response);
			}
			if (endpoint.models) {
				endpoint.models.forEach(function (model) {
					referenceModels.add(model);
				});
			}
		});
	});

	// Extend the list to include models referenced via field composition
	var referenceAndCompositionlModels = new Set(Array.from(referenceModels).map(
		function (m) {
			return transformKeyForComparison(m);
		}
	));

	referenceModels.forEach(
		function (model) {
			var compModel = getCompositionModels(om, model);
			compModel && compModel.forEach(function (compModel) {
				return referenceAndCompositionlModels.add(transformKeyForComparison(compModel));
			});
		}
	);

	return pickBy(om.models, function (value, name) {
		return referenceAndCompositionlModels.has(transformKeyForComparison(name));
	});
}

function generateSwagger(arrow, host, objectModel, type, name, force) {
	var swagger = new Swagger(),
		om,
		sec,
		defs;
	// Set the swagger API info
	swagger.info(
		objectModel.metadata.name || 'API',
		objectModel.metadata.version || '1.0',
		objectModel.metadata.description || 'API description')
		.host(
			objectModel.server.host ? objectModel.server.host : (host || ('127.0.0.1' + (objectModel.server.port ? ':' + objectModel.server.port : ''))))
		.basePath(objectModel.config.apiPrefix)
		.schemes(createSchemes(objectModel));

	// Security definition (see: arrow/lib/authentication/index.js)
	if (!arrow || !arrow.config.APIKeyAuthType || [ 'basic', 'ldap' ].indexOf(arrow.config.APIKeyAuthType) >= 0) {
		swagger.securityDefinition('basicAuth', {
			type: 'basic',
			description: 'Require authorized access to API'
		})
			.security('basicAuth');
	} else if (arrow.authstrategy) {
		if (arrow.config.APIKeyAuthType !== 'saml') {
			sec = arrow.authstrategy.getSwaggerSecurity();
			if (sec) {
				if (sec.securityDefinitions) {
					defs = sec.securityDefinitions;
					if (defs) {
						Object.keys(defs).forEach(function (key) {
							swagger.securityDefinition(key, defs[key]);
						});
					}
				}
				if (sec.security) {
					if (sec.security instanceof Array) {
						swagger.security(sec.security);
					} else {
						arrow.logger && arrow.logger.error('invalid swagger security definition: ', sec.security);
					}
				}
			}
		} else {
			arrow.logger && arrow.logger.trace('unsupported swagger security definition: ' + arrow.config.APIKeyAuthType);
		}
	}

	objectModel.metadata.author && swagger.contact(objectModel.metadata.author);
	objectModel.metadata.license && swagger.license(objectModel.metadata.license);
	objectModel.metadata.termsOfService && swagger.termsOfService(objectModel.metadata.termsOfService);

	// return 404 for undefined name or invalid types
	if (type && (!name || [ 'apis', 'endpoints' ].indexOf(type) === -1)) {
		return 404;
	}

	// Merge in the valid enabled endpoints
	if (!type || type === 'endpoints') {
		if (arrow && arrow.endpoints) {
			if (type && Object.keys(arrow.endpoints).indexOf(name) === -1) {
				return 404;
			}
			function filter(swagger, path, verb) {
				if (force) {
					return true;
				}
				var xenabled = swagger.paths[path][verb]['x-enabled'];
				if (xenabled && xenabled.enabled === false) {
					return false;
				}
				return true;
			}
			Object.keys(arrow.endpoints).forEach(function (epName) {
				const xEnabled = arrow.endpoints[epName]['x-enabled'];
				if (!type && xEnabled && xEnabled.enabled) {
					// in case of a consolidated swagger, merge endpoints on their basepath to avoid
					// collision.  also need to filter out the disabled endpoint paths
					swagger.merge(arrow.endpointSwaggers[epName], {
						prefix: arrow.endpointSwaggers[epName].basePath,
						filter: filter,
						extensions: /^x-(?!(enabled|flow)$)/
					});
				} else if (epName === name) {
					swagger.basePath(objectModel.config.apiPrefix + (arrow.endpointSwaggers[epName].basePath || ''));
					swagger.merge(arrow.endpointSwaggers[epName], {
						filter: filter,
						extensions: /^x-(?!(enabled|flow)$)/
					});
				}
			});
		}
	}

	// Merge in the model endpoints
	var lookupDefinitions = {};
	if (!type || type === 'apis') {
		if (type) {
			om = _.clone(objectModel);
			var transQuery = transformKeyForComparison(name); // lower-case
			function matchesQuery(value, key) {
				return transformKeyForComparison(key) === transQuery;
			}
			om.apis = pickBy(om.apis, matchesQuery);
			if (!Object.keys(om.apis).length) {
				return 404;
			}
			om.models = getAPIModels(om);
		} else {
			om = objectModel;
		}
		if (om && om.apis && Object.keys(om.apis).length) {
			swagger.consumes([
				'application/json',
				'application/x-www-form-urlencoded',
				'multipart/form-data'
			], true);
			swagger.produces([
				'application/json',
				'application/xml',
				'text/yaml',
				'text/csv',
				'text/plain'
			], true);
			swagger.schemas(createDefinitions(arrow, om, lookupDefinitions));
			swagger.paths(createPaths(om, lookupDefinitions));
		}
	}
	var doc = swagger.apidoc();
	// dereference all $ref to loaded schemas
	return schemas.dereference(doc, {
		target: '#/definitions',
		rename: schemaIdToSwaggerName
	});
}

function transformKeyForComparison(val) {
	return val.replace(/[^a-z0-9]/ig, '').toLowerCase();
}

function createDefinitions(arrow, objectModel, lookupDefinitions) {
	var retVal = {},
		models = objectModel.models;

	for (var i = 0, keys = Object.keys(models); i < keys.length; i++) {
		var modelName = keys[i];
		var id = 'schema:///model/' +  modelName;
		var schema = schemas.get(id);
		if (!schema) {
			var msg = 'failed to get schema for model: ' + modelName;
			arrow.logger.error(msg);
			throw new Error(msg);
		}
		// can not use modelNameToLower as it wont match in the wrapResponses function
		lookupDefinitions['#/definitions/' + modelName.replace(/\//, '_')] = id;
	}

	retVal.ResponseModel = ResponseModel;
	retVal.ErrorModel = ErrorModel;

	return retVal;
}

// This mirrors the logic in Arrow.API for determining
// the api's singular/plural.
function getResponseKey(objectModel, endpoint, isArray) {
	var model;

	var singular = endpoint.singular;
	var plural = endpoint.plural;

	if (endpoint.response) {
		model = objectModel.models[endpoint.response];
		if (model) {
			singular = singular || model.singular || model.name;
			plural = plural || model.plural || model.name;
		}
	} else if (endpoint.model) {
		model = objectModel.models[endpoint.model];
		if (model) {
			singular = singular || model.singular || model.name;
			plural = plural || model.plural || model.name;
		}
	}

	var key = isArray ? plural : singular;
	if (!key) {
		return;
	}
	var i = key.lastIndexOf('/');
	if (i > 0) {
		key = key.substring(i + 1);
	}
	return pluralize(key.toLowerCase(), isArray ? null : 1) || 'result';
}

// Wrap the defined response in the ResponsModel structure.
function wrapResponses(objectModel, endpoint, responses, lookupDefinitions) {
	var wrapped = responses && {};
	Object.keys(responses || {}).forEach(function (status) {
		var response = responses[status];
		if (status === '200') {
			var schema = JSON.parse(JSON.stringify(ResponseModel));

			if (response.schema) {
				var isArray = response.schema.type === 'array';
				var key = getResponseKey(objectModel, endpoint, isArray);
				schema.required.push('key');
				schema.properties.key = {
					type: 'string',
					enum: [ key ]
				};
				if (isArray && response.schema.items.$ref) {
					if (lookupDefinitions.hasOwnProperty(response.schema.items.$ref)) {
						// swap #/definitions/testuser with schema:///packageName/testuser
						response.schema.items.$ref = lookupDefinitions[response.schema.items.$ref];
					}
				} else if (response.schema.$ref) {
					if (lookupDefinitions.hasOwnProperty(response.schema.$ref)) {
						// swap #/definitions/testuser with schema:///packageName/testuser
						response.schema.$ref = lookupDefinitions[response.schema.$ref];
					}
				}
				schema.properties[key] = JSON.parse(JSON.stringify(response.schema));
				schema.properties[key].description && delete schema.properties[key].description;
			}

			wrapped[status] = {
				description: response.description || endpoint.name + ' Response',
				schema: schema,
				headers: responses.headers,
				examples: responses.examples
			};
		} else {
			// Only wrapping success
			wrapped[status] = response;
		}
	});
	return wrapped;
}

function createPaths(objectModel, lookupDefinitions) {
	var paths = {},
		apis = objectModel.apis;
	for (var groupName in apis) {
		if (apis.hasOwnProperty(groupName)) {
			var api = apis[groupName];
			for (var i = 0; i < api.endpoints.length; i++) {
				var endpoint = api.endpoints[i],
					relativePath = translatePath(endpoint.path.split(objectModel.config.apiPrefix).pop()),
					def = paths[relativePath];
				if (endpoint.enabled === false) {
					continue;
				}
				if (!def) {
					paths[relativePath] = def = {};
				}
				var pathID = endpoint.method.toLowerCase();
				def[pathID] = compact({
					description: endpoint.description,
					operationId: getOperationId(endpoint),
					deprecated: endpoint.deprecated,
					parameters: translateParameters(endpoint),
					responses: wrapResponses(objectModel, endpoint, endpoint.responses || api.responses || [], lookupDefinitions),
					tags: [ groupName ]
				});

				if (!def[pathID].responses || Object.keys(def[pathID].responses).length === 0) {
					def[pathID].responses = {
						default: {
							description: 'Response from Server',
							schema: {
								$ref: '#/definitions/ResponseModel'
							}
						}
					};
				}
			}
		}
	}
	return {
		paths: paths
	};
}

function createSchemes(objectModel) {
	var retVal = [ 'http' ],
		config = objectModel.config || {};

	if (config.ssl && (config.env === 'development' || config.sslInProduction)) {
		retVal.push('https');
	}
	return retVal;
}

function translatePath(path) {
	return path.replace(/:([^/]+)/g, '{$1}');
}

function translateParameters(endpoint) {
	var retVal = [],
		bodyParams;
	if (_.find(endpoint.parameters, { type: 'body' })) {
		bodyParams = {
			name: endpoint.nickname,
			in: 'body',
			description: endpoint.nickname + ' body',
			schema: {
				type: 'object',
				required: [],
				properties: {}
			}
		};
	}
	for (var name in endpoint.parameters) {
		if (endpoint.parameters.hasOwnProperty(name)) {
			var param = endpoint.parameters[name];
			switch (param.type) {
				case 'body':
					if (param.required) {
						bodyParams.schema.required.push(name);
					}
					bodyParams.schema.properties[name] = transformArrowProperty(param);
					break;
				default:
					if (param.type === 'form') {
						// We can't define both body and form params; there can be only one body per endpoint.
						if (bodyParams && param.required) {
							bodyParams.schema.required.push(name);
						}
						if (bodyParams) {
							bodyParams.schema.properties[name] = transformArrowProperty(param);
							break;
						}
					}
					// Force form parameters to be required (as required by the Swagger spec).
					if (param.type === 'path') {
						param.required = true;
					}
					var translated = {
						name: name,
						in: param.type,
						description: param.description,
						required: !!param.required,
						type: param.dataType || 'string'
					};
					// TODO: We need more information about the sub-types of objects and arrays.
					if (param.dataType === 'object') {
						translated.type = 'string';
					}
					if (param.dataType === 'array') {
						translated.items = { type: 'object' };
					}
					retVal.push(compact(translated));
					break;
			}
		}
	}
	if (bodyParams) {
		if (bodyParams.schema.required.length === 0) {
			delete bodyParams.schema.required;
		}
		retVal.push(bodyParams);
	}
	return retVal;
}

function transformArrowProperty(arrowProperty) {
	var dataType = arrowProperty.dataType || 'string';
	var swaggerProperty = {
		type: dataType,
		description: arrowProperty.description
	};
	switch (dataType) {
		case 'date':
			swaggerProperty.type = 'string';
			swaggerProperty.format = 'date';
			break;
		case 'array': {
			swaggerProperty.items = { type: 'string' };
			break;
		}
	}

	return swaggerProperty;
}

function getOperationId(endpoint) {
	var retVal = verbMap[endpoint.method] || endpoint.method.toLowerCase(),
		splits = endpoint.path.replace(/appc\./, '')
			.replace(/_[a-z]/ig, function (val) {
				return val[1].toUpperCase();
			})
			.slice(1).split('/');
	for (var i = 1; i < splits.length; i++) {
		var split = splits[i];
		if (split[0] === ':') {
			retVal += 'By' + split.slice(1).toUpperCase();
		} else if (split[0] !== undefined) {
			retVal += split[0].toUpperCase() + split.slice(1);
		}
	}
	return retVal;
}

function compact(obj) {
	return omitBy(obj, function (val, key) {
		if (_.isArray(val)) {
			return val.length === 0;
		}
		if (_.isObject(val)) {
			obj[key] = compact(val);
			if (_.keys(obj[key]).length === 0) {
				return false;
			}
		}

		return !val;
	});
}

/**
 * Emulates the behaviour of _.omitBy until we can upgrade to lodash 4
 *
 * @see https://lodash.com/docs/4.16.4#omitBy
 * @param {Object} obj The source object
 * @param {Function} predicate The predicate function invoked per property
 * @return {Object} Returns the new object
 */
function omitBy(obj, predicate) {
	return pickBy(obj, _.negate(_.iteratee(predicate)));
}

/**
 * Emulates the behaviour of _.pickBy until we can upgrade to lodash 4
 *
 * @see https://lodash.com/docs/4.16.4#pickBy
 * @param {Object} obj The source object
 * @param {Function} predicate The predicate function invoked per property
 * @return {Object} Returns the new object
 */
function pickBy(obj, predicate) {
	var index = -1;
	var props = _.keysIn(obj);
	var length = props.length;
	var result = {};

	while (++index < length) {
		var key = props[index];
		var value = obj[key];

		if (predicate(value, key)) {
			result[key] = value;
		}
	}
	return result;
}
