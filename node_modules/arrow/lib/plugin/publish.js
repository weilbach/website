/**
 * This code is closed source and Confidential and Proprietary to
 * Appcelerator, Inc. All Rights Reserved.  This code MUST not be
 * modified, copied or otherwise redistributed without express
 * written permission of Appcelerator. This file is licensed as
 * part of the Appcelerator Platform and governed under the terms
 * of the Appcelerator license agreement.
 */
// will get set in execute
var appc;

var _ = require('lodash'),
	async = require('async'),
	chalk = require('chalk'),
	exec = require('child_process').exec,
	fs = require('fs'),
	path = require('path'),
	util = require('./util');

var exports = module.exports = {
	name: 'Arrow',
	type: 'arrow_publish',
	find: find,
	execute: publish
};

function find(appc, opts) {
	if (opts.image) {
		return [{
			value: {
				type: 'image',
				dir: opts.projectDir || process.cwd(),
				plugin: module.exports
			}
		}];
	}
	return util.findArrowComponent(appc, opts, module.exports);
}

function checkContainerSize(appcJSON, inquirer, callback) {
	if (appcJSON && appcJSON.cloud && appcJSON.cloud.container
	&& [ 'small', 'dev' ].indexOf(appcJSON.cloud.container.toLowerCase()) >= 0) {
		inquirer.prompt([{
			type: 'confirm',
			name: 'continue',
			message: 'For optimum memory performance please use a "Medium" or higher size container. Do you want to continue with a Small Container?'
		}], function (err, answers) {
			// grunt tests use an err first callback, appc publish does not
			if (err && err.hasOwnProperty('continue')) {
				answers = err;
				err = null;
			}
			if (err) {
				return callback(err);
			}
			if (!answers.continue) {
				var error = new Error('Edit appc.json to increase your container size.');
				return callback(error);
			} else {
				return callback(null);
			}
		});
	} else {
		return callback(null);
	}
}

function publish(_appc, args, opts, callback) {
	appc = _appc;
	opts = _.clone(opts || {});

	var inquirer = appc.inquirer;

	// validate required fields
	if (!opts.component) {
		appc.log.trace('no component specified for ' + exports.name + ' publish, skipping...');
		return callback();
	}
	var component = opts.component;
	opts.publishDir = component.dir;
	opts.pkg = {};
	if (component.type !== 'image') {
		var pkgFile = path.join(opts.publishDir, 'package.json');
		appc.log.trace('loading for publish ' + chalk.yellow(pkgFile));
		try {
			opts.pkg = JSON.parse(fs.readFileSync(pkgFile, 'utf8'));
		} catch (e) {
			return callback(new Error('unable to parse package.json\n' + e.toString()));
		}
	}
	// if this is an API Project, we want to use ACS for publish
	if (component.type === 'api' || component.type === 'image') {
		var appcFn = path.join(opts.publishDir, 'appc.json'),
			appcJSON;
		try {
			appcJSON = JSON.parse(fs.readFileSync(appcFn, 'utf8'));
		} catch (e) {
			return callback(new Error('Unable to parse appc.json\n' + e.toString()));
		}
		checkContainerSize(appcJSON, inquirer, function (err) {
			if (err) {
				return callback(err);
			}
			// entitlement checks --- don't worry, if you hack this code, we'll check it on the server too :<
			var entitlements = JSON.parse(process.env.APPC_SESSION_ENTITLEMENTS || '{}');
			var entitled = entitlements && entitlements.arrowPublish;
			if (!entitled) {
				return callback(new Error('Your current login session is not entitled to publish to production. '
					+ 'Please login to a different organization with entitlements or upgrade to a plan that supports '
					+ 'production deployment.'));
			}

			var ArrowCloud = require('../cloud');
			var org_id = opts.session && opts.session.org_id || opts.config && opts.config.org_id;
			var cloud = new ArrowCloud(opts.pkg.name, org_id, appc);
			if (args && args.length) {
				var url = require('url').parse(args[0]);
				if (url && url.protocol && url.hostname) {
					var sid = _appc.commands.config.get('sid');
					cloud.host = url.protocol  + '//' + url.hostname;
					cloud.port = url.port;
					cloud.path = url.path === '/' ? '' : url.path;
					cloud.username = opts.session.username;
					cloud.password = 'sid:' + sid;
				}
			}
			cloud.opts = opts;
			cloud.appc = appc;
			cloud.publish(opts.publishDir, opts.force, function (err, result) {
				// check if the error message contains App not found!
				if (err && err.message === 'App not found!') {
					appc.log.debug(err);
					appc.log.warn('The API Builder app needs to be registered before it is published.');
					return inquirer.prompt([
						{
							type: 'confirm',
							name: 'import',
							message: 'Would you like to register the API Builder app?'
						}
					], function (err, answers) {
						if (arguments.length === 1) {
							answers = err;
							err = null;
						}
						if (err) {
							return callback(err);
						}
						if (!answers.import) {
							return callback(new Error('The API Builder app must be registered before it can be published.'));
						}

						// import the service
						appc.spinner.start(); // start spinner
						return require('./new').acsNew(appc, opts, opts.pkg.name, opts.publishDir, function (err) {
							appc.spinner.stop(); // stop spinner
							if (err) {
								return callback(err);
							}

							appc.log.info('Arrow service successfully imported');
							return publish(appc, args, opts, callback);
						});
					});
				}

				if (err) {
					return callback(err);
				}
				cloud.getCName(function (err, details) {
					var url = result.url;
					if (details && details.domain && details.domain.length) {
						url = details.domain[0];
					}
					appc.log.info('Application deployed to', appc.chalk.green(url));
					callback(null, {
						url: url,
						type: 'api',
						name: opts.pkg.name,
						version: opts.pkg.version
					});
				});
			});
		});
	} /* publish to registry*/ else if (_.contains([ 'block', 'model', 'connector' ], component.type)) {

		// load the package.json

		async.waterfall([

			// feed opts into waterfall
			function (cb) {
				return cb(null, opts);
			},

			// package the module, via npm pack
			packModule,

			// sha1 the dist
			sha1Dist,

			// upload packaged module to registry
			uploadModule

		], function (err, result) {
			if (opts.packFile) {
				try {
					fs.unlinkSync(opts.packFile);
				} catch (e) {
					// Ignore error
				}
			}
			return callback(err, result);
		});
	} /* invalid publish type*/ else {
		return callback(new Error('invalid publish type "' + component.type
			+ '" for plugin ' + exports.name));
	}

}

function packModule(opts, callback) {
	appc.log.info('Packaging ' + opts.pkg.name);
	appc.spinner.start();

	exec('npm pack', { cwd: opts.publishDir }, function (err, stdout) {
		appc.spinner.stop();
		if (err) {
			return callback(err);
		}
		opts.packFile = path.join(opts.publishDir, (stdout || '').trim());
		return callback(null, opts);
	});
}

function sha1Dist(opts, callback) {
	appc.log.info('Encoding ' + opts.pkg.name);
	var hash = require('crypto').createHash('sha1');
	hash.setEncoding('hex');
	var fd = fs.createReadStream(opts.packFile);
	fd.on('end', function () {
		hash.end();
		opts.shasum = hash.read();
		callback(null, opts);
	});
	fd.pipe(hash);
}

function uploadModule(opts, callback) {
	appc.spinner.start();

	// add the shasum to the package.json
	opts.pkg._shasum = opts.shasum;

	// attempt to find a suitable README and bring it in like npm publish does
	var readmeNames = [ 'README.md', 'README', 'README.txt' ];
	for (var c = 0; c < readmeNames.length; c++) {
		var readme = path.join(opts.publishDir, readmeNames[c]);
		if (fs.existsSync(readme)) {
			opts.pkg.readme = fs.readFileSync(readme).toString();
			opts.pkg.readmeFilename = readmeNames[c];
			break;
		}
	}

	// get the TYPE if there's one and this is a appc-cli-plugin
	if (opts.pkg && opts.pkg.keywords && opts.pkg.keywords.indexOf('appc-cli-plugin') !== -1) {
		var appcfn = path.join(opts.publishDir, 'appc.js');
		if (fs.existsSync(appcfn)) {
			try {
				var m = require(appcfn);
				opts.subtype = m.TYPE;
			} catch (e) {
				appc.log.debug('Error attempting to determine appc-cli-plugin TYPE by loading', appcfn, '. Error: ', e);
			}
		}
	}

	var appcFile = path.join(opts.publishDir, 'appc.json');

	appc.publish.validateAppC(appcFile, opts.pkg, opts.session, function (err, appcJSON) {
		if (err) {
			appc.spinner.stop();
			return callback(err);
		}
		opts.appcJSON = appcJSON;
		appc.publish.uploadModule(opts, callback);
	});

}
