/**
 * API Runtime Services REST API wrapper
 */
var request = require('request'),
	fs = require('fs-extra'),
	path = require('path'),
	chalk = require('chalk'),
	os = require('os'),
	async = require('async'),
	debug = require('debug')('appc:arrowcloud'),
	dockerUtil = require('./dockerUtil'),
	acsConfig,
	configHost,
	configPort,
	configCookie,
	appc;

function getDefaultHost() {
	if (process.env.APPC_ENV === 'preproduction') {
		return 'https://admin.cloudapp-enterprise-preprod.appctest.com';
	}
	return 'https://admin.cloudapp-enterprise.appcelerator.com';
}

function formatBody(body, resp) {
	return body && typeof(body) === 'string' && resp && resp.headers['content-type'] && resp.headers['content-type'].indexOf('/json') > 0 ? JSON.parse(body) : body;
}

function getCredentials(instance, callback, retries) {
	if (instance.username && instance.password && !instance.cookie) {
		var hostname = instance.host || getDefaultHost(),
			port = instance.port || 443,
			instancePath = instance.path || '',
			opts = {
				url: hostname + ':' + port + instancePath + '/login',
				method: 'post',
				headers: {
					'Content-Type': 'application/x-www-form-urlencoded',
					'User-Agent': appc && appc.sdk && appc.sdk.userAgent || 'Appcelerator',
					Accept: 'text/json, application/json'
				},
				form: {
					login: instance.username,
					password: instance.password
				}
			};
		debug('sending %j', opts);
		return request(opts, function (err, resp, body) {
			body = formatBody(body, resp);
			debug('receiving err1=%j, body=%j', err, body);
			// if we receive a cloud error that looks like a restart, try again
			if (resp && /^(408|500|502|503|404)$/.test(String(resp.statusCode))) {
				retries = retries || 1;
				debug('detected server error, will re-try again in %d ms', 500 * retries);
				return setTimeout(function () {
					getCredentials(instance, callback, retries + 1);
				}, 500 * retries);
			}
			if (err) {
				return callback(err);
			}
			if (body && body.success) {
				var cookie = resp.headers['set-cookie'];
				if (cookie && cookie.length) {
					var sid;
					for (var c = 0; c < cookie.length; c++) {
						var line = cookie[c].split(';')[0],
							token = line.split('=');
						if (token[0] === 'connect.sid') {
							sid = line;
							break;
						}
					}
					if (!sid) {
						return callback(new Error('invalid login. no session was created'));
					}
					instance.port = port;
					instance.cookie = sid;
					instance.host = hostname;
					instance.path = instancePath;
					return callback(null, {
						host: hostname,
						port: port,
						path: instancePath,
						cookie: sid
					});
				}
			} else if (body && body.message) {
				return callback(new Error(body.message));
			}
			return callback(new Error('login error'));
		});
	} else if (instance && instance.cookie) {
		return callback(null, {
			host: instance.host,
			port: instance.port,
			path: instance.path,
			cookie: instance.cookie
		});
	} else if (!acsConfig) {
		var acsFile = path.join(os.homedir(), '.acs');
		var error;
		if (!fs.existsSync(acsFile)) {
			error = new Error('You are not logged in. Please login again.');
			error.errcode = 'loggedout';
			return callback(error);
		}
		try {
			acsConfig = JSON.parse(fs.readFileSync(acsFile));
		} catch (e) {
			error = new Error('You are not logged in. Please login again.');
			error.errcode = 'loggedout';
			return callback(error);
		}
		configHost = acsConfig.publishHost;
		configPort = acsConfig.publishPort || 443;
		configCookie = acsConfig.cookie && acsConfig.cookie[0] && acsConfig.cookie[0].split(';')[0];
		if (!configHost || !configPort || !configCookie) {
			error = new Error('You are not logged in. Please login again.');
			error.errcode = 'loggedout';
			return callback(error);
		}
		debug('loaded config host=%s, port=%d, sid=%s', configHost, configPort, configCookie);
	}
	return callback(null, {
		host: configHost,
		port: configPort,
		cookie: configCookie,
		path: ''
	});
}

function sendHTTPRequest(instance, method, uriPath, json, callback, optsCallback, reqCallback, retries) {
	startSpinner();
	getCredentials(instance, function (err, credentials) {
		if (err) {
			return callback(err);
		}
		var opts = {
			method: method,
			url: credentials.host + ':' + credentials.port + (credentials.path || '') + uriPath,
			headers: {
				Cookie: credentials.cookie,
				'User-Agent': appc && appc.sdk && appc.sdk.userAgent || 'Appcelerator',
				Accept: 'text/json, application/json'
			},
			gzip: true
		};
		if (json instanceof Buffer) {
			opts.headers['Content-Type'] = 'application/octet-stream';
			opts.headers['Content-Disposition'] = 'attachment;filename=sslcert';
			opts.headers['Content-Length'] = String(Buffer.byteLength(json));
			opts.body = json;
		} else if (json && typeof(json) === 'object') {
			opts.json = json;
		} else if (json && typeof(json) === 'string') {
			opts.url += '?' + json;
		}
		optsCallback && optsCallback(opts);
		debug('sending %j', opts);
		startSpinner();
		var req = request(opts, function (err, resp, body) {
			body = formatBody(body, resp);
			stopSpinner();
			debug('receiving err2=%j, body=%j', err, body);
			// if we receive a cloud error that looks like a restart, try again
			if (resp && /^(408|500|502|503|404)$/.test(String(resp.statusCode))) {
				retries = retries || 1;
				debug('detected server error, will re-try again in %d ms', 500 * retries);
				return setTimeout(function () {
					sendHTTPRequest(instance, method, uriPath, json, callback, optsCallback, reqCallback, retries + 1);
				}, 500 * retries);
			}
			if (err) {
				if (err.code === 'ENOTFOUND') {
					return callback('Either you are offline, or the server cannot be reached. Please check your connection and try again.');
				}
				return callback(err);
			}
			var error;
			if (resp.statusCode > 200 && typeof(body) === 'string') {
				error = new Error(body);
				error.statusCode = resp.statusCode;
				return callback && callback(error);
			}
			if (body && !body.success) {
				error = new Error(body.message);
				error.errcode = body.errcode;
				error.statusCode = resp.statusCode;
				return callback && callback(error);
			}
			callback(err, body);
		});
		reqCallback && reqCallback(req);
	});
}

function ArrowCloudApp(name, org_id, appc_) {
	this.name = name;
	this.org_id = org_id || process.env.APPC_SESSION_ORGID;
	appc = appc_;
	if (appc && appc.log) {
		// if we provided an appc ref, use that instead of debug lib
		debug = appc.log.debug.bind(appc.log);
	}
	this.docker = dockerUtil;
}

/**
 * remove an app
 */
ArrowCloudApp.prototype.remove = function (callback) {
	sendHTTPRequest(this, 'post', '/remove/' + encodeURIComponent(this.name), 'orgid=' + this.org_id, callback);
};

/**
 * unpublish app
 */
ArrowCloudApp.prototype.unpublish = function (version, callback) {
	if (typeof(version) === 'function') {
		callback = version;
		version = null;
	}
	var verString = '/' + encodeURIComponent(version || 'deployed');
	sendHTTPRequest(this, 'post', '/unpublish/' + encodeURIComponent(this.name) + verString, 'orgid=' + this.org_id, callback);
};

/**
 * get current versions of app
 */
ArrowCloudApp.prototype.getVersions = function (callback) {
	var regex = /Published versions?: (.*)?. The version (?:is )?deployed currently: (.*)./;
	sendHTTPRequest(this, 'get', '/publish/' + encodeURIComponent(this.name), 'orgid=' + this.org_id, function (err, body) {
		if (err) {
			return callback(err);
		}
		var tokens = regex.exec(body.message);
		var versions = tokens && tokens.length && tokens[1].split(',').map(function (v) {
			return v.trim();
		});
		callback(null, {
			current_version: tokens && tokens.length && tokens[2].trim(),
			versions: versions
		});
	});
};

/**
 * get current versions of app
 */
ArrowCloudApp.prototype.setVersion = function (version, callback) {
	sendHTTPRequest(this, 'post', '/publish/' + encodeURIComponent(this.name) + '/' + encodeURIComponent(version), 'orgid=' + this.org_id, callback);
};

/**
 * get the details about an app
 */
ArrowCloudApp.prototype.getDetails = function (callback) {
	var orgid = this.org_id;
	sendHTTPRequest(this, 'get', '/list/' + encodeURIComponent(this.name), 'orgid=' + orgid, function (err, body) {
		if (err) {
			return callback(err);
		}
		if (!body.apps || !body.apps.length) {
			var error = new Error(body.message);
			return callback && callback(error);
		}
		if (body && body.apps && body.apps.length) {
			// find the current org
			body.apps = body.apps.filter(function (app) {
				return app.orgid === orgid || app.orgid === String(orgid);
			});
		}
		var result = {
			success: true,
			app: body && body.apps && body.apps[0],
			quota: body && body.quotas && body.apps && body.quotas.filter(function (e) {
				return e.orgid === body.apps.length && body.apps[0].orgid;
			})[0]
		};
		callback && callback(null, result);
	});
};

/**
 * create an app
 */
ArrowCloudApp.prototype.create = function (callback) {
	sendHTTPRequest(this, 'post', '/create/' + encodeURIComponent(this.name), { orgid: this.org_id }, callback);
};

/**
 * set the CNAME to the app
 */
ArrowCloudApp.prototype.setCName = function (cname, callback) {
	sendHTTPRequest(this, 'post', '/cname/set/' + encodeURIComponent(this.name) + '/' + encodeURIComponent(cname), { orgid: this.org_id }, callback);
};

/**
 * get the CNAME to the app
 */
ArrowCloudApp.prototype.getCName = function (callback) {
	sendHTTPRequest(this, 'post', '/cname/check/' + encodeURIComponent(this.name), { orgid: this.org_id }, function (err, body) {
		if (err) {
			return callback(err);
		}
		// NOTE: this is so hacky.  we get back a semi structure (escaped in weird way) json as part
		// of the body message and we have to parse it out
		var re = /name: '(.*)'/.exec(body.message);
		var name = re && re.length && re[1];
		re = /domain: \[(.*)\]/.exec(body.message);
		var domain = re && re.length && re[1];
		domain = domain && domain.replace(/'/g, '');
		callback(null, {
			name: name,
			domain: domain && domain.split(',').map(function (n) {
				return n.trim();
			})
		});
	});
};

/**
 * set the CNAME to the app
 */
ArrowCloudApp.prototype.removeCName = function (cname, callback) {
	if (typeof (cname) === 'function') {
		callback = cname;
		cname = '';
	}
	sendHTTPRequest(this, 'post', '/cname/remove/' + encodeURIComponent(this.name) + (cname ? '/' + encodeURIComponent(cname) : ''), { orgid: this.org_id }, callback);
};

/**
 * set the path to the app
 */
ArrowCloudApp.prototype.setCNamePath = function (cpath, callback) {
	sendHTTPRequest(this, 'post', '/cname/path/' + encodeURIComponent(this.name) + '/' + encodeURIComponent(cpath), { orgid: this.org_id }, callback);
};

/**
 * set the domain to the app
 */
ArrowCloudApp.prototype.setDomain = function (cname, callback) {
	sendHTTPRequest(this, 'post', '/domain/set/' + encodeURIComponent(this.name) + '/' + encodeURIComponent(cname), { orgid: this.org_id }, callback);
};

/**
 * get the domain to the app
 */
ArrowCloudApp.prototype.getDomain = function (cname, callback) {
	sendHTTPRequest(this, 'post', '/domain/check/' + encodeURIComponent(this.name), { orgid: this.org_id }, callback);
};

/**
 * set the domain to the app
 */
ArrowCloudApp.prototype.removeDomain = function (cname, callback) {
	if (typeof (cname) === 'function') {
		callback = cname;
		cname = '';
	}
	sendHTTPRequest(this, 'post', '/domain/remove/' + encodeURIComponent(this.name) + (cname ? '/' + encodeURIComponent(cname) : ''), { orgid: this.org_id }, callback);
};

/**
 * set the path to the app
 */
ArrowCloudApp.prototype.setDomainPath = function (cpath, callback) {
	sendHTTPRequest(this, 'post', '/domain/path/' + encodeURIComponent(this.name) + '/' + encodeURIComponent(cpath), { orgid: this.org_id }, callback);
};

/**
 * set the container size of the app
 */
ArrowCloudApp.prototype.setContainer = function (size, callback) {
	size = size.toLowerCase();
	switch (size) {
		case 'dev':
			size = 'Dev';
			break;
		case 'small':
			size = 'Small';
			break;
		case 'medium':
			size = 'Medium';
			break;
		case 'large':
			size = 'Large';
			break;
		case 'xlarge':
			size = 'XLarge';
			break;
		default:
			return callback(new Error('unsupported size: ' + size));
	}
	sendHTTPRequest(this, 'post', '/server/' + encodeURIComponent(this.name) + '/set/' + size, { orgid: this.org_id }, callback);
};

/**
 * get the app environment variables
 */
ArrowCloudApp.prototype.getEnvironment = function (callback) {
	sendHTTPRequest(this, 'get', '/config/' + encodeURIComponent(this.name) + '/env', { orgid: this.org_id }, function (err, body) {
		if (err && err.errcode === 247) {
			return callback && callback(null, {});
		}
		var env = {};
		body.message && body.message.split(/\n/).forEach(function (line) {
			var i = line.indexOf(' = ');
			var k = line.substring(0, i).trim();
			var v = line.substring(i + 2).trim();
			env[k] = v;
		});
		return callback(err, env);
	});
};

/**
 * set the app environment variables
 */
ArrowCloudApp.prototype.setEnvironment = function (env, callback) {
	sendHTTPRequest(this, 'post', '/config/' + encodeURIComponent(this.name) + '/env?orgid=' + this.org_id, env, callback);
};

/**
 * set the app environment variables
 */
ArrowCloudApp.prototype.getSSLCertificate = function (callback) {
	sendHTTPRequest(this, 'get', '/certs/show/' + encodeURIComponent(this.name), { orgid: this.org_id }, callback);
};

/**
 * set the app environment variables
 */
ArrowCloudApp.prototype.removeSSLCertificate = function (callback) {
	sendHTTPRequest(this, 'delete', '/certs/' + encodeURIComponent(this.name), { orgid: this.org_id }, callback);
};

/**
 * set a SSL certificate. the cert must be a Buffer
 */
ArrowCloudApp.prototype.setSSLCertificate = function (cert, callback) {
	if (!(cert instanceof Buffer) && typeof(cert) !== 'string') {
		return callback(new Error('certificate must be a Buffer or String'));
	}
	sendHTTPRequest(this, 'post', '/certs/' + encodeURIComponent(this.name) + '?orgid=' + this.org_id, cert, callback);
};

/**
 * download the app
 */
ArrowCloudApp.prototype.download = function (version, filename, callback) {
	sendHTTPRequest(this, 'get', '/download/' + encodeURIComponent(this.name) + '/' + encodeURIComponent(version), { orgid: this.org_id }, callback);
};

/**
 * set min containers
 */
ArrowCloudApp.prototype.setMinimum = function (value, callback) {
	sendHTTPRequest(this, 'get', '/config/' + encodeURIComponent(this.name) + '/min/' + encodeURIComponent(value), { orgid: this.org_id }, callback);
};

/**
 * set max containers
 */
ArrowCloudApp.prototype.setMaximum = function (value, callback) {
	sendHTTPRequest(this, 'get', '/config/' + encodeURIComponent(this.name) + '/max/' + encodeURIComponent(value), { orgid: this.org_id }, callback);
};

/**
 * set max queued requests before scaling
 */
ArrowCloudApp.prototype.setMaximumQueuedRequests = function (value, callback) {
	sendHTTPRequest(this, 'get', '/config/' + encodeURIComponent(this.name) + '/maxqueuedrequests/' + encodeURIComponent(value), { orgid: this.org_id }, callback);
};

/**
 * set whether the container should autoscale up
 */
ArrowCloudApp.prototype.setAutoscaleUp = function (value, callback) {
	sendHTTPRequest(this, 'get', '/config/' + encodeURIComponent(this.name) + '/autoup/' + (value ? 'true' : 'false'), { orgid: this.org_id }, callback);
};

/**
 * set whether the container should autoscale down
 */
ArrowCloudApp.prototype.setAutoscaleDown = function (value, callback) {
	sendHTTPRequest(this, 'get', '/config/' + encodeURIComponent(this.name) + '/autodown/' + (value ? 'true' : 'false'), { orgid: this.org_id }, callback);
};

/**
 * get the status for the app
 */
ArrowCloudApp.prototype.getStatus = function (callback) {
	sendHTTPRequest(this, 'get', '/config/' + encodeURIComponent(this.name) + '/appstatus', { orgid: this.org_id }, function (err, body) {
		if (err) {
			return callback(err);
		}
		return callback(null, body.message);
	});
};

/**
 * start the spinner
 */
function startSpinner() {
	if (appc) {
		appc.spinner.start();
	}
}

/**
 * stop the spinner
 */
function stopSpinner() {
	if (appc) {
		appc.spinner.stop();
	}
}

/**
 * write a wait message and start spinner
 */
function waitMessage(msg) {
	if (appc) {
		appc.log.info(msg);
	}
}

/**
 * if we have more than 10 versions, we should remove the oldest
 */
function undeployEarliestVersionIfNeeded(app, cb) {
	// check and see if we have more than 10 published and remove the oldest
	return app.getVersions(function (err, detail) {
		if (detail && detail.versions && detail.versions.length === 10) {
			debug('undeploying old version: %s', detail.versions[0]);
			app.unpublish(detail.versions[0], cb);
		} else {
			cb();
		}
	});
}

/**
 * publish the image
 */
function publishImage(instance, force, callback) {
	var self = instance;
	var opts = self.opts;
	var docker = self.docker || dockerUtil;

	if (!appc) {
		appc = self.appc;
	}

	var password = configCookie && configCookie.split('=')[1];
	var email = opts.session && opts.session.username || '';
	var image = opts.image;
	var name = opts.appname;
	var version = opts.app_version;

	async.waterfall([
		function (cb) {
			docker.isDockerInstalled(appc, function (err) {
				if (err) {
					return callback(err);
				}
				cb();
			});
		},

		function (cb) {
			docker.doDocketInspect(
				appc,
				{
					image: opts.image,
					args: [ '--format', '{{json .Config.Healthcheck }}' ]
				},
				function (err, result) {
					if (err) {
						return callback(err);
					}

					if (result !== 'null') {
						return cb();
					}

					appc.inquirer.prompt([{
						type: 'confirm',
						name: 'confirm',
						message: 'The image does not have HEALTHCHECK instruction. Do you want to continue publishing?',
						default: false
					}], function (err, answer) {
						if (arguments.length === 1) {
							answer = err;
							err = null;
						}

						if (err) {
							return callback(err);
						}

						if (answer.confirm) {
							return cb();
						}

						return callback('Publish aborted');
					});
				}
			);
		},

		// get the docker registry URL from stratus
		function (cb) {
			sendHTTPRequest(self, 'get', '/push/' + encodeURIComponent(name), '', function (err, body) {
				if (!body.success) {
					if (body.message) {
						return callback(body.message + ' ' + (body.extended || ''), body.errcode ? body.errcode : 1);
					} else {
						return callback('Failed to retrieve docker registry url: ' + body);
					}
				}
				cb(null, body);
			});

		},

		// tag the docker image provided by user based on the rule: dockerRegistralURL/orgid/appname:version
		function (body, cb) {
			var url = body.dockerRegistryURL;
			var imageRepoNameRemote = dockerUtil.getImageRepoName(name, self.org_id, url);

			docker.tagDockerImage(appc, image, imageRepoNameRemote, version, function (err) {
				if (err) {
					return callback(err);
				}
				cb(null, imageRepoNameRemote, url);
			});
		},

		// push the image to the remote docker registry
		function (imageRepoNameRemote, dockerRegistryURL, cb) {
			var dockerRegistryAuthConfig = {
				username: email,
				password: password,
				auth: '',    // leave empty
				email: email
			};

			docker.loginDockerReg(appc, dockerRegistryAuthConfig, dockerRegistryURL, function (err) {
				if (err) {
					return callback(err);
				}

				cb(null, imageRepoNameRemote);
			});
		},

		function (imageRepoNameRemote, cb) {
			var imageRepoName = imageRepoNameRemote + ':' + version;
			docker.pushDockerImage(appc, imageRepoName, function (err) {
				if (err) {
					return callback(err);
				}

				cb(null, imageRepoName);
			});
		},

		function (imageRepoName, cb) {
			docker.removeDockerImage(appc, imageRepoName, function (err) {
				if (err) {
					return cb(err);
				}

				cb(null, imageRepoName);
			});
		},

		// send the publish request to stratus
		function (imageRepoName, cb) {
			// var force = 1;
			var endPoint = '/publish/' + encodeURIComponent(name) + '/' + encodeURIComponent(version) + '/' + (+force) + '?orgid=' + self.org_id;
			var data = {
				image: imageRepoName
			};
			sendHTTPRequest(self, 'post', endPoint, data, function (err, body) {
				// check if a client side timeout waiting on server and if so, give a more friendly reason
				if (err && err.code === 'ETIMEDOUT') {
					err.message = 'Timed out waiting for deployment to complete. Please try your publish again in a few minutes.';
					return callback(err);
				}
				if (err) {
					return callback(err);
				}

				cb(null, body);
			});
		}
	], function (err, body) {
		if (err === 'Publish aborted') {
			console.log('App publishing aborted.');
		}

		if (body) {
			if (body.name && body.version) {
				console.log('App ' + chalk.blue(body.name) + ' version ' + chalk.blue(body.version) + ' published.');
			} else {
				console.log('App published.');
			}
			if (body.url) {
				console.log('App will be available at ' + chalk.cyan(body.url));
			}
		}

		callback(err, body);
	});
}

/**
 * build image using the dockerfile and publish the image
 */
function publishBuiltImage(instance, dir, pkg, force, callback) {
	var name = pkg.name;
	var version = pkg.version;
	var tmpImageRepoName = 'arrowcloud/' + name + ':' + version;

	if (!appc) {
		appc = instance.appc;
	}

	if (instance && !instance.opts) {
		instance.opts = {};
	}

	var docker = instance.docker || dockerUtil;

	docker.isDockerInstalled(appc, function (err) {
		if (err) {
			return callback(err);
		}
		docker.buildDockerImage(appc, tmpImageRepoName, dir, function (err) {
			if (err) {
				return callback(err);
			}
			instance.opts.image = tmpImageRepoName;
			instance.opts.appname = name;
			instance.opts.app_version = version;
			publishImage(instance, force, callback);
		});
	});
}

/**
 * publish the app
 */
ArrowCloudApp.prototype.publish = function (dir, force, callback) {
	startSpinner();
	if (typeof(force) === 'function') {
		callback = force;
		force = false;
	}
	var pkg,
		appcJSON,
		dockerFile;

	if (this && this.opts && this.opts.image) {
		pkg = {};
		appcJSON = {};
		this.name = this.opts.appname;
		pkg.version  = this.opts.app_version;
	} else {
		try {
			var packageJSON = path.join(dir, 'package.json');
			if (!fs.existsSync(packageJSON)) {
				return callback(new Error('couldn\'t find ' + packageJSON));
			}
			pkg = JSON.parse(fs.readFileSync(packageJSON));
		} catch (e) {
			stopSpinner();
			return callback(new Error('error parsing application package.json. ' + e.message));
		}
		try {
			appcJSON = path.join(dir, 'appc.json');
			if (fs.existsSync(appcJSON)) {
				appcJSON = JSON.parse(fs.readFileSync(appcJSON));
			} else {
				appcJSON = {};
			}
		} catch (e) {
			appcJSON = {};
		}

		dockerFile = path.join(dir, 'Dockerfile');
	}

	var self = this;
	force = +force;

	if (isNaN(force)) {
		force = false;
	}

	waitMessage('Publishing application ... this could take several minutes');

	undeployEarliestVersionIfNeeded(self, function () {

		sendHTTPRequest(self, 'get', '/publish/' + encodeURIComponent(self.name) + '/' + encodeURIComponent(pkg.version) + '/' + (+force), 'orgid=' + self.org_id, function (err) {
			if (err) {
				stopSpinner();
				return callback(err);
			}

			if (self && self.opts && self.opts.image) {
				return publishImage(self, force, callback);
			} else if (fs.existsSync(dockerFile)) {
				return publishBuiltImage(self, dir, pkg, force, callback);
			}

			var Targz = require('targz'),
				exec = require('child_process').exec,
				crypto = require('crypto'),
				tmpdir = require('os').tmpdir(),
				// Group all the deployment data together and remove that folder afterwards
				groupDir = path.join(tmpdir, 'arrowcloud-deploy-' + Date.now()),
				deployDir = path.join(groupDir, 'arrowcloud-publish-' + Date.now()),
				extractDir = path.join(deployDir, 'extract-' + pkg.name + '-' + pkg.version),
				uploadFile = path.join(groupDir, 'arrowcloud-publish-' + pkg.name + '-' + pkg.version + '.tgz'),
				length = 0,
				md5sum = crypto.createHash('md5'),
				arrowReponse,
				currentVersion;

			waitMessage('Packaging application ... ');

			async.series([

				function (cb) {
					// check and see if we have a successfully deployed app that we can use to rollback if failured
					self.getDetails(function (err, details) {
						if (details && details.app && details.app.status !== 'Failed to deploy' && details.app.currentPublish) {
							currentVersion = Object.keys(details.app.currentPublish)[0];
							debug('current version %s', currentVersion);
						}
						cb();
					});
				},

				function (cb) {
					// create temp directory
					fs.ensureDirSync(groupDir);
					// copy into a temporary directory
					fs.copySync(dir, deployDir, {
						filter: function (filename, adir) {
							var relative = path.relative(deployDir, adir);
							if (relative === 'node_modules') {
								return false;
							}
							if (relative === 'logs') {
								return false;
							}
							return true;
						}
					});

					// remove these directories
					[ 'node_modules', 'logs' ].forEach(function (name) {
						var adir = path.join(deployDir, name);
						fs.removeSync(adir);
					});

					// remove these files since they aren't needed
					[ '.gitignore', 'Gruntfile.js', '.jshintrc', 'README.md', '.travis.yml', 'npm-debug.log', 'conf/local.js', 'conf/development.js' ].forEach(function (name) {
						var fn = path.join(deployDir, name);
						fs.existsSync(fn) && fs.unlinkSync(fn);
					});

					// don't publish any possibly sensitive local config files
					var confDir = path.join(deployDir, 'conf');
					fs.existsSync(confDir) && fs.readdirSync(confDir).forEach(function (name) {
						if (/.*\.(development|local)\.js/.test(name)) {
							var fn = path.join(deployDir, 'conf', name);
							debug('removing %s', fn);
							fs.unlinkSync(fn);
						}
					});

					cb();
				},

				function (cb) {
					debug('npm pack %s', deployDir);
					exec('npm pack', { cwd: deployDir }, cb);
				},

				function (cb) {
					var packFile = path.join(deployDir, pkg.name + '-' + pkg.version + '.tgz');
					debug('extract %s -> %s', packFile, extractDir);
					Targz.decompress({ src: packFile, dest: extractDir }, cb);
				},

				function (cb) {
					// install our npm lifecycle script
					var arrowPkg = JSON.parse(fs.readFileSync(path.join(__dirname, '..', '..', 'package.json')));
					pkg.scripts = pkg.scripts || {};
					// add our install scripts
					pkg.scripts.install = 'node ./__arrow_install.js; ' + (pkg.scripts.install || '');
					pkg.scripts.postinstall = 'node ./__arrow_postinstall.js; ' + (pkg.scripts.postinstall || '');
					if (pkg.scripts.start && pkg.scripts.start !== 'appc run') {
						pkg.scripts.poststart = pkg.scripts.start;
					}
					pkg.scripts.start = 'node ./__arrow_start.js; ';
					pkg.dependencies = pkg.dependencies || {};
					pkg.dependencies.arrow = pkg.dependencies.arrow || arrowPkg.version;
					pkg.dependencies.async = pkg.dependencies.async || '^2.6.0'; // __arrow_install.js requires this
					pkg.dependencies.debug = pkg.dependencies.debug || '^3.1.0';
					delete pkg.ensureLatest;
					delete pkg.devDependencies;
					pkg._main = pkg.main;
					delete pkg.main;
					// migrate old projects in case they aren't set but don't touch
					// if it's changed by the developer
					if (pkg.healthCheck === undefined && appcJSON.type === 'api') {
						pkg.healthCheck = true;
					}
					var pkgFile = path.join(extractDir, 'package', 'package.json');
					var pkgContents = JSON.stringify(pkg, null, 2);
					debug('writing package.json(1) %s', pkgContents);
					fs.writeFile(pkgFile, pkgContents, cb);
				},

				function (cb) {
					// write the install script
					var from = path.join(__dirname, '..', '..', 'templates', 'publish', '__arrow_install.js');
					var to = path.join(extractDir, 'package', '__arrow_install.js');
					debug('copy %s -> %s', from, to);
					fs.writeFile(to, fs.readFileSync(from), cb);
				},

				function (cb) {
					// write the postinstall script
					var from = path.join(__dirname, '..', '..', 'templates', 'publish', '__arrow_postinstall.js');
					var to = path.join(extractDir, 'package', '__arrow_postinstall.js');
					debug('copy %s -> %s', from, to);
					fs.writeFile(to, fs.readFileSync(from), cb);
				},

				function (cb) {
					// write the start script
					var from = path.join(__dirname, '..', '..', 'bin', 'run.js');
					var to = path.join(extractDir, 'package', '__arrow_start.js');
					debug('copy %s -> %s', from, to);
					fs.writeFile(to, fs.readFileSync(from), cb);
				},

				function (cb) {
					// install our appc dependencies
					if (!appc) {
						return cb();
					}
					var baseDir = path.join(extractDir, 'package');
					debug('appc install %s', baseDir);
					var level = appc.log.level();
					appc.log.level('warn');
					appc.plugins.install.execute(appc, [],
						{ projectDir: baseDir, skipNpm: true, quiet: true },
						function (err, result) {
							appc.log.level(level);
							cb(err, result);
						});
				},

				function (cb) {
					startSpinner();
					// remove our node_modules, we'll re-install on the server side
					[ 'connectors', 'models', 'blocks' ].forEach(function (name) {
						var nmd = path.join(extractDir, 'package', 'node_modules', name);
						debug('checking %s', nmd);
						if (fs.existsSync(nmd)) {
							var dirs = fs.readdirSync(nmd);
							for (var c = 0; c < dirs.length; c++) {
								var cnmd = path.join(nmd, dirs[c], 'node_modules');
								if (fs.existsSync(cnmd)) {
									debug('removing %s', cnmd);
									fs.removeSync(cnmd);
								}
							}
						}
					});
					cb();
				},

				function (cb) {
					// install any private node_modules
					if (pkg.dependencies && Object.keys(pkg.dependencies).length) {
						Object.keys(pkg.dependencies).forEach(function (k) {
							var ver = pkg.dependencies[k];
							// if this looks like an invalid version range it's probably a github
							// url (such as foo/bar or git@github.com:foo/bar.git) or empty version
							if (!ver || (appc && appc.semver && !appc.semver.validRange(ver))) {
								var nmd = path.join(dir, 'node_modules', k);
								if (fs.existsSync(nmd)) {
									// place in a special directory that will be handled in __arrow_install.js
									var tnmd = path.join(extractDir, 'package', 'node_modules');
									if (!fs.existsSync(tnmd)) {
										fs.mkdir(tnmd);
									}
									debug('copying private module %s -> %s', nmd, tnmd);
									fs.copySync(nmd, path.join(tnmd, k));
									// delete it so that we don't try and npm install it again on server side
									// since that will failå
									delete pkg.dependencies[k];
								} else {
									appc && appc.log.warn('Couldn\'t find required node module: ' + k + ' at ' + nmd);
								}
							}
						});
						// re-write it
						var pkgFile = path.join(extractDir, 'package', 'package.json');
						var pkgContents = JSON.stringify(pkg, null, 2);
						debug('writing package.json(2) %s', pkgContents);
						return fs.writeFile(pkgFile, pkgContents, cb);
					} else {
						cb();
					}
				},

				function (cb) {
					var packageDir = path.join(extractDir, 'package');
					deployDir = path.join(extractDir, '' + pkg.version);
					debug('rename %s -> %s', packageDir, deployDir);
					fs.rename(packageDir, deployDir, cb);
				},

				function (cb) {
					// stepping a level back to compress the whole folder not just the files inside
					deployDir = path.join(deployDir, '..');
					debug('compress %s -> %s', deployDir, uploadFile);
					Targz.compress({ src: deployDir, dest: uploadFile }, cb);
				},

				function (cb) {
					startSpinner();
					var stream = fs.createReadStream(uploadFile);
					stream.on('data', function (buf) {
						md5sum.update(buf, 'utf8');
						length += buf.length;
					});
					stream.on('end', cb);
				},

				function (cb) {
					function pre(opts) {
						opts.headers['Content-Type'] = 'application/octet-stream';
						opts.headers['Content-Length'] = String(length);
						opts.headers['Content-Disposition'] = 'attachment;filename=' + path.basename(uploadFile);
						opts.headers['X-Content-Checksum'] = md5sum.digest('hex');
						opts.timeout = 5 * 60000;
					}
					function post(req) {
						fs.createReadStream(uploadFile)
							.on('end', function () {
								waitMessage('Deploying application ... ');
							})
							.pipe(req);
					}
					var endPoint = '/publish/' + encodeURIComponent(self.name) + '/' + encodeURIComponent(pkg.version) + '/' + (+force);

					sendHTTPRequest(self, 'post', endPoint, 'async=true&orgid=' + self.org_id, function (err, body) {
						// check if a client side timeout waiting on server and if so, give a more friendly reason
						if (err && err.code === 'ETIMEDOUT') {
							err.message = 'Timed out waiting for deployment to complete. Please try your publish again in a few minutes.';
							return cb(err);
						}
						if (err) {
							return cb(err);
						}
						arrowReponse = body;
						cb();
					}, pre, post);
				},

				function (cb) {
					// wait for deployment to finish
					waitMessage('Starting application ... ');
					var started = false;
					var deployStarted = Date.now();
					async.whilst(
						function () {
							return !started;
						},
						function (next) {
							startSpinner();
							self.getDetails(function (err, details) {
								if (err) {
									return next(err);
								}
								var error;
								if (details.app.servers && details.app.servers.length) {
									for (var c = 0; c < details.app.servers.length; c++) {
										var server = details.app.servers[c];
										// if we find at least one server running, we can break out
										// ACS with OpenVZ is Deployed
										// ACS with Docker is Running
										if (/(Running|Deployed)/.test(server.status)) {
											started = true;
											break;
										} else if (server.status === 'Failed') {
											stopSpinner();
											error = new Error('Deployment failed');
											error.errno = 'deployment_failed';
											error.failure = server.message;
											return next(error);
										}
									}
								}
								// check to see if this is a failure
								if (details.app.status === 'Failed to deploy') {
									stopSpinner();
									error = new Error('Deployment failed. ' + (details.app.message || 'Please run "appc cloud loglist" to see what errors are reported.'));
									return next(error);
								}
								// timed out
								if (Date.now() - deployStarted > (5 * 60000)) {
									stopSpinner();
									error = new Error('Deployment failed');
									error.errno = 'deployment_timeout';
									return next(error);
								}
								startSpinner();
								setTimeout(next, 1000);
							});
						},
						cb
					);
				}

			], function (err) {
				fs.removeSync(groupDir);
				stopSpinner();

				if (err && err.errno === 'deployment_failed' && currentVersion) {
					debug('deployment failed, attempting to rollback to %s', currentVersion);
					console.log('Deployment failed. Rolling back to version: ' + currentVersion);
					return self.setVersion(currentVersion, function () {
						// NODEJS-2018 - force a env change to cause reployment
						self.setEnvironment({ ARROW_FAILED_DEPLOY: '' + Date.now() }, function () {
							err.rollback_version = currentVersion;
							return callback(err);
						});
					});
				}

				callback(err, arrowReponse);
			});
		});

	});
};

module.exports = ArrowCloudApp;

if (module.id === '.') {
	var app = new ArrowCloudApp('appc-registry-server', 14301);
	app.host = 'https://admin.cloudapp-enterprise-preprod.appctest.com';
	app.username = process.argv[2];
	app.password = process.argv[3];
	app.getCName(function (err, details) {
		details && console.log('status', details);
	});
}
