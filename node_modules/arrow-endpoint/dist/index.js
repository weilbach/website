'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var chalk = require('chalk');
var fs = require('fs');
var pathUtil = require('path');
var tools = require('swagger-tools');
var swaggerMetadata = require('swagger-tools/middleware/swagger-metadata');
var swaggerValidator = require('swagger-tools/middleware/swagger-validator');
var swaggerParser = require('swagger-parser');
var parseJson = require('parse-json');
var jsonrefs = require('json-refs');
var schemas = require('axway-schema');
var swagger20 = require('swagger-tools/schemas/2.0/schema.json');

schemas.register(swagger20).loadSync();
var PATH_PATTERN = new RegExp(/(?:\{.*?\})/g);
var EXTENTION_PATTERN = new RegExp(/^x-/);

var Endpoints = function () {
	function Endpoints() {
		_classCallCheck(this, Endpoints);
	}

	_createClass(Endpoints, null, [{
		key: 'load',

		/**
   * Loads and validates an endpoint from a given file directory
   *
   * @static
   * @param {string} file - file path of the endpoint to be loaded
   * @param {array} flows - the array of available flows (used in validation)
   * @returns {object} promise - resolves to give the loaded endpoint
   *
   * @memberOf Endpoints
   */
		value: function load(file, flows) {
			var promise = new Promise(function (resolve, reject) {
				return fs.readFile(file, function (err, data) {
					if (err) {
						reject(err);
						return;
					}
					var id = pathUtil.basename(file, pathUtil.extname(file));

					// Check if its a valid JSON
					var swagger = void 0;
					try {
						swagger = parseJson(data.toString(), file);
					} catch (ex) {
						return reject(new Error('Unable to load endpoint ' + id + '. ' + ex.message));
					}
					Endpoints.validateSwagger(swagger, file).then(function (dereferencedSwagger) {
						// Load dereferenced swagger into memory
						return Endpoints.validateEndpoint(dereferencedSwagger, flows);
					}).then(function (endpoint) {
						resolve({
							swagger: swagger,
							endpoint: endpoint
						});
					}, reject);
				});
			});
			return promise;
		}

		/**
   * Validate a swagger document
   *
   * @static
   * @param {object} swagger - swagger document
   * @returns {Promise<object>} the valid swagger document (dereferenced)
   */

	}, {
		key: 'validateSwagger',
		value: function validateSwagger(swagger) {
			var promise = new Promise(function (resolve, reject) {
				var err = schemas.validate('http://swagger.io/v2/schema.json#', swagger);
				if (err) {
					return reject(err);
				}

				swaggerParser.validate(JSON.parse(JSON.stringify(swagger)), {
					resolve: {
						external: false
					},
					// not using this schema validation because you don't get back a useful error
					// Otherwise we could use it if we don't care.
					dereference: {
						circular: false // Don't allow circular $refs
					},
					validate: {
						schema: false
					}
				}).then(function (validated) {
					// Ideally we'd use a custom swagger-parser/json-schema-ref-parser resolver to
					// dereference the schema against Axway-Schema
					// but that doesn't work well with non-schema:// style refs
					// so for now check that all refs exist.
					var refs = jsonrefs.findRefs(swagger, { filter: ['remote', 'invalid', 'relative'], includeInvalid: true });

					if (refs && Object.keys(refs).length > 0) {
						var invalid = [];
						Object.keys(refs).forEach(function (loc) {
							var schemaUrl = refs[loc].uri;
							if (!schemas.get(schemaUrl)) {
								invalid.push(schemaUrl);
							}
						});

						if (invalid.length > 0) {
							throw new Error('Undefined schemas: ' + invalid.join(', '));
						}
					}
					return validated;
				}).then(resolve, reject);
			});
			return promise;
		}

		/**
   * validates a given endpoint for internal errors. Flows are required in validation.
   *
   * @static
   * @param {object} endpoint - an endpoint's definition
   * @param {array} flows - an array of the available flows (used in validation)
   * @returns {object} endpoint - validated endpoint's definition
   *
   * @memberOf Endpoints
   */

	}, {
		key: 'validateEndpoint',
		value: function validateEndpoint(endpoint, flows) {
			var xEnabled = endpoint['x-enabled'] = endpoint['x-enabled'] || { enabled: true };
			var disabled = 0;
			var invalid = 0;
			var total = 0;

			xEnabled.warnings = [];
			xEnabled.errors = [];

			Object.keys(endpoint.paths).forEach(function (path) {
				if (EXTENTION_PATTERN.test(path)) {
					return;
				}
				Object.keys(endpoint.paths[path]).forEach(function (methodName) {
					if (methodName === 'parameters' || EXTENTION_PATTERN.test(methodName)) {
						return;
					}
					var method = endpoint.paths[path][methodName];
					Endpoints.validateMethod(method, flows);
					if (!Endpoints.isEnabled(method)) {
						if (!Endpoints.isValid(method)) {
							xEnabled.warnings.push('Problem in ' + methodName.toUpperCase() + ' ' + path + ': ' + method['x-enabled'].errors.join());
							invalid++;
						} else {
							disabled++;
						}
					}
					total++;

					// If the group is manually disabled, disable each method
					if (!Endpoints.isEnabled(endpoint)) {
						Endpoints.disableEndpoint(method);
					}
				});
			});

			// If the group is manually disabled, do not apply additional validation and bail
			if (!Endpoints.isEnabled(endpoint)) {
				return endpoint;
			}

			// if all methods are disabled, disable the whole group
			if (disabled === total) {
				Endpoints.disableEndpoint(endpoint);
			} else if (invalid === total - disabled) {
				// if all the methods are invalid (contain error), invalidate the whole group
				Endpoints.disableEndpoint(endpoint, 'All methods contain errors');
			}
			return endpoint;
		}

		/**
   * Validates a given method against flow related errors.
   *
   * @static
   * @param {object} method - a single operation object of a valid swagger doc. https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#operationObject
   * @param {object} flows - an array of the available flows (used in validation)
   * @memberof Endpoints
   */

	}, {
		key: 'validateMethod',
		value: function validateMethod() {
			var method = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
			var flows = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

			// start with existing value to support manual enable/disable
			var xEnabled = method['x-enabled'] = method['x-enabled'] || { enabled: true };
			xEnabled.warnings = [];
			xEnabled.errors = [];
			var flowName = method['x-flow'];
			var flow = flows[flowName];
			if (!flowName) {
				Endpoints.disableEndpoint(method);
				delete xEnabled.errors;
			} else if (!flow) {
				Endpoints.disableEndpoint(method, 'Flow not found: ' + flowName);
			} else if (!flow['x-validation'] || !flow['x-validation'].valid) {
				Endpoints.disableEndpoint(method, 'Invalid flow: ' + flowName);
			}
		}

		/**
   * marks a given endpoint invalid with a given error message. No error means its just disabled
   *
   * @static
   * @param {object} endpoint - an endpoint's definition
   * @param {string} [error] - optional error message to set
   * @returns {object} endpoint - the given endpoint's definition marked invalid
   *
   * @memberOf Endpoints
   */

	}, {
		key: 'disableEndpoint',
		value: function disableEndpoint(endpoint, error) {
			var xEnabled = endpoint['x-enabled'] = endpoint['x-enabled'] || {};
			var errors = xEnabled.errors = xEnabled.errors || [];

			// If we're dissabling an endpoint, disable all the methods
			if (endpoint && endpoint.paths) {
				Object.keys(endpoint.paths).forEach(function (path) {
					if (EXTENTION_PATTERN.test(path)) {
						return;
					}
					Object.keys(endpoint.paths[path]).forEach(function (methodName) {
						if (methodName === 'parameters' || EXTENTION_PATTERN.test(methodName)) {
							return;
						}
						var method = endpoint.paths[path][methodName];
						Endpoints.disableEndpoint(method);
					});
				});
			}

			xEnabled.enabled = false;
			error && errors.push(error);
			return endpoint;
		}

		/**
   * Confirms a given endpoint's active status. Could've been manually disabled w/o any error
   *
   * @static
   * @param {object} endpoint - an endpoint's definition
   * @returns {boolean}
   *
   * @memberOf Endpoints
   */

	}, {
		key: 'isEnabled',
		value: function isEnabled(endpoint) {
			return endpoint['x-enabled'] && endpoint['x-enabled'].enabled;
		}

		/**
   * Confirms a given endpoint's validity. Based on the presence of any error.
   *
   * @static
   * @param {object} endpoint - an endpoint's definition
   * @returns {boolean}
   *
   * @memberOf Endpoints
   */

	}, {
		key: 'isValid',
		value: function isValid(endpoint) {
			return !Endpoints.isEnabled(endpoint) && (!endpoint['x-enabled'].errors || endpoint['x-enabled'].errors.length === 0);
		}

		/**
   * Callback function to rename a schema when used as a swagger dereference
   * target.
   *
   * @public
   * @callback targetRenameCallback
   * @param {id} id - The schema id.
   * @return {boolean} Return `true` if valid, or `false` if invalid.
   */

		/**
   * binds the given endpoints to the arrow's express app
   *
   * @static
   * @param {object} arrowInstance - the running arrow instance to be bound with
   * @param {object} endpoints - the endpoints to be bound
   * @param {targetRenameCallback} [rename] - a callback function to rename swagger definitions
   *
   * @memberOf Endpoints
   */

	}, {
		key: 'bind',
		value: function bind(arrowInstance, endpoints, rename) {
			Object.keys(endpoints).forEach(function (endpointName) {
				var ep = endpoints[endpointName];
				if (!Endpoints.isEnabled(ep)) {
					var errors = ep['x-enabled'] && ep['x-enabled'].errors;
					errors && errors.length && errors.forEach(function (errorMessage) {
						arrowInstance.logger.error(endpointName + ' - ' + errorMessage);
					});
					return;
				}
				var endpoint = schemas.dereference(ep, {
					target: '#/definitions',
					rename: rename
				});
				var basePath = Endpoints.getRuntimeBasePath(arrowInstance, endpoint);
				var cloned = JSON.parse(JSON.stringify(endpoint));
				cloned.basePath = basePath;
				var swagerMetadataMiddleware = Endpoints.deserializeParameters(cloned);

				Object.keys(endpoint.paths).sort(function (left, right) {
					// Parameterized paths last
					var lParamCount = (left.match(/{/g) || []).length;
					var rParamCount = (right.match(/{/g) || []).length;

					if (lParamCount > rParamCount) {
						return lParamCount - rParamCount;
					}
					// shortest paths first
					return left > right;
				}).forEach(function (path) {
					if (EXTENTION_PATTERN.test(path)) {
						return;
					}
					var bindPath = Endpoints.endpointToExpress(basePath + path);
					var bound = false;
					// adding CORS headers for the OPTIONS request
					arrowInstance.app.options(bindPath, Endpoints.addCors(arrowInstance, endpoint.paths[path]), Endpoints.authenticate(arrowInstance));
					Object.keys(endpoint.paths[path]).forEach(function (method) {
						if (EXTENTION_PATTERN.test(method) || method === 'parameters') {
							return;
						}
						arrowInstance.logger.debug('binding api (' + method + ')', bindPath);

						// Bind to the express path and apply middlewares
						var EPdefinition = endpoint.paths[path][method];
						if (!Endpoints.isEnabled(EPdefinition)) {
							arrowInstance.logger.debug('binding api failed for (' + method + ')', bindPath);
							return;
						}
						arrowInstance.app[method](bindPath, Endpoints.addCors(arrowInstance, endpoint.paths[path]), Endpoints.authenticate(arrowInstance), swagerMetadataMiddleware, Endpoints.validateParameters(), Endpoints.invokeFlow(arrowInstance, endpoint, EPdefinition));
						bound = true;
					});

					if (!bound) {
						return;
					}
					// Bind the error handler
					arrowInstance.app.use(bindPath, function (err, req, res, next) {
						// eslint-disable-line
						// jjp: we trust that the above middleware functions are doing their jobs
						// to not leak unexpected errors.  they were specifically written that way.
						// the purpose of this method is to log and send the "clean" error back to
						// the client.  this is intentional.  the default response is 200, so unless
						// the status code is already set to an error condition, explicitly set it.
						if (res.statusCode < 400) {
							arrowInstance.logger.error(err);
							res.status(500);
						} else {
							arrowInstance.logger.debug(err);
						}
						res.send({ error: err.message });
					});
				});
			});
		}

		/**
   * Returns an Express middleware to add CORS headers to the response
   *
   * @static
   * @param {any} arrowInstance - the arrow instance
   * @param {any} endpointPathItemObj - the endpoint's path item object containing methods
   * @returns {function} Express middleware
   *
   * @memberOf Endpoints
   */

	}, {
		key: 'addCors',
		value: function addCors(arrowInstance) {
			var endpointPathItemObj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

			return function (req, res, next) {
				// if cross origin req, extract defined methods and headers for the requested path
				if (arrowInstance && arrowInstance.isCORSReq(req, arrowInstance.config.cors)) {
					var corsConf = Object.assign({}, arrowInstance.config.cors || {}),
					    preflight = arrowInstance.isPreflight(req),
					    methods = [],
					    headers = {};

					// extract related data from the api object (methods, headers etc)
					if (preflight) {
						Object.keys(endpointPathItemObj).forEach(function (method) {
							if (EXTENTION_PATTERN.test(method) || method === 'parameters') {
								return;
							}
							methods.push(method.toUpperCase());
						});
					} else {
						Object.keys(endpointPathItemObj).forEach(function (method) {
							if (EXTENTION_PATTERN.test(method) || method === 'parameters') {
								return;
							}
							var responses = endpointPathItemObj[method].responses;
							// extract headers from the response definition
							responses && Object.keys(responses).forEach(function (response) {
								var hdrs = responses[response].headers;
								hdrs && Object.keys(hdrs).forEach(function (header) {
									// storing in an object to avoid dedupe cost
									headers[header] = undefined;
								});
							});
						});
					}

					// insert extracted data into the cors configs to be used by the addCORsHeaders
					corsConf.defMethods = methods;
					corsConf.defHeaders = Object.keys(headers);
					arrowInstance.addCORsHeaders(corsConf, req, res);
					if (preflight) {
						return res.status(200).end();
					}
				}
				next();
			};
		}

		/**
   * Returns an Express middleware to handle authentication.
   *
   * @static
   * @param {any} arrowInstance - the arrow instance
   * @returns {function} Express middleware
   *
   * @memberOf Endpoints
   */

	}, {
		key: 'authenticate',
		value: function authenticate(arrowInstance) {
			return function (req, res, next) {
				return arrowInstance.executeSecurityMiddleware(req, res, function (err) {
					if (err !== false) {
						next();
					}
				});
			};
		}

		/**
   * Returns an Express middleware to deserialize the swagger parameters from the express request.
   *
   * @static
   * @param {object} endpoint - the endpoint's swagger definition
   * @returns {function} Express middleware
   *
   * @memberOf Endpoints
   */

	}, {
		key: 'deserializeParameters',
		value: function deserializeParameters(endpoint) {
			var middleware = void 0;
			return function () {
				for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
					args[_key] = arguments[_key];
				}

				if (middleware) {
					return middleware.apply(undefined, args);
				}
				// the metadata generator relies on the endpoint to be cached. It actually
				// runs sync even though it has a callback, and will fail if the cache is
				// not present. calling validate first will populate the cache async then
				// we run the middleware. Ideally we would run resolveRefs which is much
				// faster but that's not exported...
				tools.initializeMiddleware(endpoint, function () {
					var swaggerMetadataMiddleware = swaggerMetadata(endpoint);

					middleware = function middleware(req, res, next) {
						swaggerMetadataMiddleware(req, res, function () {
							if (!req.swagger) {
								res.status(404);
								res.send();
							} else {
								next && next();
							}
						});
					};

					middleware.apply(undefined, args);
				});
			};
		}

		/**
  	 * Returns an Express middleware that validates the swagger parameters.
  	 *
  	 * @static
  	 * @returns {function} Express middleware
  	 *
  	 * @memberOf Endpoints
  	 */

	}, {
		key: 'validateParameters',
		value: function validateParameters() {
			return swaggerValidator();
		}

		/**
  	 * Log the transaction response record.
  	 *
  	 * @static
   * @param {Request} flowtx - the request being logged against.
   * @param {Object} record - the record details to log.
  	 *
  	 * @memberOf Endpoints
  	 */

	}, {
		key: 'logTxResponse',
		value: function logTxResponse(flowtx, record) {
			flowtx && flowtx.log && flowtx.log.info(_extends({}, record, {
				ignore: true,
				type: 'response'
			}));
		}

		/**
   * Returns an Express middleware to invoke flow
   *
   * @static
   * @param {object} arrowInstance - the arrow instance
   * @param {object} endpoint - the endpoint's swagger definition
   * @param {object} EPdefinition - the specific path/method from the endpoint
   * @returns {function} Express middleware
   *
   * @memberOf Endpoints
   */

	}, {
		key: 'invokeFlow',
		value: function invokeFlow(arrowInstance, endpoint, EPdefinition) {
			var produces = EPdefinition.produces || endpoint.produces;
			var flowName = EPdefinition['x-flow'];

			// A middleware closure to invoke flow
			return function (req, res, next) {
				var flowtx = req.tx && req.tx.start('flow:' + flowName);

				if (produces && !req.accepts(produces)) {
					res.status(406);
					Endpoints.logTxResponse(flowtx, {
						headers: res.getHeaders ? res.getHeaders() : res._headers,
						status: 406
					});
					return next();
				} else {
					// require flow response to match
					var data = {
						params: Endpoints.getFlowInput(req),
						request: req,
						config: arrowInstance.config,
						env: process.env
					};
					data.params && flowtx && flowtx.addArguments(data.params);

					arrowInstance.flowManager.flow(flowName, data).then(function (result) {
						var status = +(result && result.status) || 200;
						var body = result && result.body;
						var headers = result && result.headers;

						// TODO: cast responses to match schema or enforce schema
						if (headers) {
							Object.keys(headers).forEach(function (key) {
								arrowInstance.logger.debug(chalk.green('Setting header', key, headers[key]));
								res.setHeader(key, headers[key]);
							});
							// expose the new headers added by the flow
							var exposeHeaders = res.get['Access-Control-Expose-Headers'];
							exposeHeaders = exposeHeaders ? exposeHeaders.split(/\s*,\s*/) : [];
							exposeHeaders = new Set([].concat(_toConsumableArray(exposeHeaders), _toConsumableArray(Object.keys(headers))));
							exposeHeaders = [].concat(_toConsumableArray(exposeHeaders)).join(', ');
							res.setHeader('Access-Control-Expose-Headers', exposeHeaders);
						}

						// Tx Log the result before sending the response (or log gets out of order).
						body && flowtx && flowtx.addResult(body);
						flowtx && flowtx.end();

						var dataString = '';
						res.status(status);
						if (body !== undefined) {
							dataString = JSON.stringify(body);
							res.setHeader('Content-Type', 'application/json; charset=utf-8');
							res.send(dataString);
						} else {
							res.send();
						}

						arrowInstance.logger.debug(chalk.green('Response', status, dataString));

						// Log the end transaction.
						Endpoints.logTxResponse(flowtx, {
							headers: res.getHeaders ? res.getHeaders() : res._headers,
							status: status,
							body: body
						});
					}).catch(function (err) {
						// Unexpected error processing the flow response
						flowtx && flowtx.addError(err);
						flowtx && flowtx.end();
						arrowInstance.logger.error(err);
						var body = { error: 'Server Error' };
						res.status(500).send(body);

						// Log the end transaction.
						Endpoints.logTxResponse(flowtx, {
							headers: res.getHeaders ? res.getHeaders() : res._headers,
							status: 500,
							body: body
						});
					});
				}
			};
		}

		/**
   * Converts an Swaggger endpoint path to an Express one.
   *
   * @static
   * @param {string} str - the endpoint path to convert.
   * @returns {string} The express path.
   *
   * @memberOf Endpoints
   */

	}, {
		key: 'endpointToExpress',
		value: function endpointToExpress(str) {
			var match = PATH_PATTERN.exec(str);
			while (match !== null) {
				str = str.replace(/{/, ':').replace(/}/, '');
				match = PATH_PATTERN.exec(str);
			}
			return str;
		}

		/**
   * Helper to get flow parameters from the swagger context
   * on the request.
  	 *
  	 * @static
  	 * @param {object} req - the Express request object.
  	 * @returns {object} A map of the deserialized parameters.
  	 *
  	 * @memberOf Endpoints
  	 */

	}, {
		key: 'getFlowInput',
		value: function getFlowInput(req) {
			var data = {};
			if (req.swagger && req.swagger.params) {
				Object.keys(req.swagger.params).forEach(function (paramName) {
					var param = req.swagger.params[paramName];
					data[paramName] = param.value;
				});
			}
			return data;
		}

		/**
   * Get the runtime basepath.
  	 *
  	 * @static
  	 * @param {Arrow} arrow - the arrow instance.
   * @param {object} endpoint - the endpoint.
  	 * @returns {string} - the runtime basePath.
  	 *
  	 * @memberOf Endpoints
  	 */

	}, {
		key: 'getRuntimeBasePath',
		value: function getRuntimeBasePath(arrow, endpoint) {
			var basePath = arrow.config.apiPrefix || '';

			if (endpoint.basePath) {
				basePath += endpoint.basePath;
			}

			return basePath;
		}
	}]);

	return Endpoints;
}();

module.exports = Endpoints;